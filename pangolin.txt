FILE CONCATENATION REPORT
Root Directory: Pangolin/
Excluded Directories: public, ios, node_modules
File Extensions: *.swift, *.plist, *.entitlements, *.jsx, *.css, *.html, *.json, *.hbs, *.mdx
================================================================================

File: PangolinApp.swift
// PangolinApp.swift

import SwiftUI

@main
struct PangolinApp: App {
    @StateObject private var libraryManager = LibraryManager.shared
    @State private var showLibrarySelector = false
    @State private var showCreateLibrary = false
    @State private var hasAttemptedAutoOpen = false
    @State private var isAttemptingAutoOpen = false
    
    var body: some Scene {
        WindowGroup {
            Group {
                if libraryManager.isLibraryOpen {
                    // REFACTORED: Pass the configured libraryManager into MainView's initializer.
                    // This ensures the entire view hierarchy, including the FolderNavigationStore,
                    // uses the correct, active Core Data context.
                    MainView(libraryManager: libraryManager)
                        .environmentObject(libraryManager)
                } else if isAttemptingAutoOpen {
                    // Show loading state while attempting to auto-open
                    VStack(spacing: 20) {
                        ProgressView()
                            .scaleEffect(1.5)
                        Text("Opening last library...")
                            .font(.headline)
                    }
                    .frame(minWidth: 600, minHeight: 500)
                } else {
                    LibraryWelcomeView(
                        showLibrarySelector: $showLibrarySelector,
                        showCreateLibrary: $showCreateLibrary
                    )
                    .environmentObject(libraryManager)
                }
            }
            .onAppear {
                if !hasAttemptedAutoOpen {
                    attemptAutoOpenLastLibrary()
                }
            }
            .fileImporter(
                isPresented: $showLibrarySelector,
                allowedContentTypes: [.folder],
                allowsMultipleSelection: false
            ) { result in
                switch result {
                case .success(let urls):
                    if let url = urls.first {
                        Task {
                            do {
                                let _ = try await libraryManager.openLibrary(at: url)
                            } catch {
                                print("Failed to open library: \(error)")
                                // In a real app, show an error alert to the user
                            }
                        }
                    }
                case .failure(let error):
                    print("Error selecting library: \(error)")
                }
            }
            .fileImporter(
                isPresented: $showCreateLibrary,
                allowedContentTypes: [.folder],
                allowsMultipleSelection: false
            ) { result in
                switch result {
                case .success(let urls):
                    if let url = urls.first {
                        Task {
                            do {
                                let _ = try await libraryManager.createLibrary(at: url, name: "My Library")
                            } catch {
                                print("Failed to create library: \(error)")
                                // In a real app, show an error alert to the user
                            }
                        }
                    }
                case .failure(let error):
                    print("Error creating library: \(error)")
                }
            }
        }
        #if os(macOS)
        .commands {
            CommandGroup(replacing: .newItem) {
                Button("New Library...") {
                    showCreateLibrary = true
                }
                .keyboardShortcut("N", modifiers: [.command, .shift])
                
                Button("Open Library...") {
                    showLibrarySelector = true
                }
                .keyboardShortcut("O", modifiers: .command)
                
                Divider()
                
                Menu("Recent Libraries") {
                    ForEach(libraryManager.recentLibraries) { library in
                        Button(library.name) {
                            Task { @MainActor in
                                try? await libraryManager.openLibrary(at: library.path)
                            }
                        }
                        .disabled(!library.isAvailable)
                    }
                }
            }
            
            CommandMenu("Video") {
                Button("Generate Thumbnails") {
                    generateThumbnails()
                }
                .disabled(!libraryManager.isLibraryOpen)
            }
        }
        #endif
    }
    
    private func attemptAutoOpenLastLibrary() {
        hasAttemptedAutoOpen = true
        isAttemptingAutoOpen = true
        
        Task {
            do {
                try await libraryManager.openLastLibrary()
                await MainActor.run {
                    isAttemptingAutoOpen = false
                }
            } catch {
                // Failed to auto-open, show welcome screen
                print("Failed to auto-open last library: \(error)")
                await MainActor.run {
                    isAttemptingAutoOpen = false
                }
            }
        }
    }
    
    private func generateThumbnails() {
        guard let library = libraryManager.currentLibrary,
              let context = libraryManager.viewContext else { return }
        
        Task {
            await FileSystemManager.shared.rebuildAllThumbnails(for: library, context: context)
        }
    }
}


================================================================================

File: Info.plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>NSServices</key>
	<array>
		<dict/>
	</array>
	<key>NSSpeechRecognitionUsageDescription</key>
	<string>Pangolin uses speech recognition to generate transcripts of your video content, making it searchable and accessible.</string>
</dict>
</plist>


================================================================================

File: Pangolin.entitlements
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.files.bookmarks.app-scope</key>
	<true/>
	<key>com.apple.security.files.bookmarks.document-scope</key>
	<true/>
	<key>com.apple.security.temporary-exception.files.absolute-path.read-write</key>
	<array>
		<string>/</string>
	</array>
</dict>
</plist>


================================================================================

File: ViewModels/VideoPlayerViewModel.swift
//
//  VideoPlayerViewModel.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//


// ViewModels/VideoPlayerViewModel.swift
import Foundation
import AVFoundation
import Combine

class VideoPlayerViewModel: ObservableObject {
    @Published var player: AVPlayer?
    @Published var isPlaying = false
    @Published var currentTime: TimeInterval = 0
    @Published var duration: TimeInterval = 0
    @Published var isLoading = false
    @Published var volume: Float = 1.0
    @Published var playbackRate: Float = 1.0
    @Published var availableSubtitles: [Subtitle] = []
    @Published var selectedSubtitle: Subtitle?
    @Published var currentVideo: Video?
    
    private var timeObserver: Any?
    private var cancellables = Set<AnyCancellable>()
    
    func loadVideo(_ video: Video) {
        currentVideo = video
        
        guard let url = video.fileURL else { return }
        
        isLoading = true
        let playerItem = AVPlayerItem(url: url)
        
        // Load subtitles
        if let subtitles = video.subtitles {
            availableSubtitles = Array(subtitles as! Set<Subtitle>)
            // Load subtitle tracks into player item
        }
        
        player = AVPlayer(playerItem: playerItem)
        
        // Restore playback position
        if video.playbackPosition > 0 {
            player?.seek(to: CMTime(seconds: video.playbackPosition, preferredTimescale: 1))
        }
        
        setupTimeObserver()
        setupNotifications()
        
        isLoading = false
    }
    
    func play() {
        player?.play()
        isPlaying = true
    }
    
    func pause() {
        player?.pause()
        isPlaying = false
    }
    
    func togglePlayPause() {
        if isPlaying {
            pause()
        } else {
            play()
        }
    }
    
    func seek(to time: TimeInterval) {
        player?.seek(to: CMTime(seconds: time, preferredTimescale: 1))
    }
    
    func skipForward(_ seconds: TimeInterval = 10) {
        let newTime = currentTime + seconds
        seek(to: min(newTime, duration))
    }
    
    func skipBackward(_ seconds: TimeInterval = 10) {
        let newTime = currentTime - seconds
        seek(to: max(newTime, 0))
    }
    
    func setPlaybackRate(_ rate: Float) {
        playbackRate = rate
        player?.rate = isPlaying ? rate : 0
    }
    
    func selectSubtitle(_ subtitle: Subtitle?) {
        selectedSubtitle = subtitle
        // Apply subtitle to player
    }
    
    private func setupTimeObserver() {
        let interval = CMTime(seconds: 0.5, preferredTimescale: CMTimeScale(NSEC_PER_SEC))
        timeObserver = player?.addPeriodicTimeObserver(forInterval: interval, queue: .main) { [weak self] time in
            self?.currentTime = CMTimeGetSeconds(time)
            
            if let duration = self?.player?.currentItem?.duration {
                self?.duration = CMTimeGetSeconds(duration)
            }
            
            // Save playback position periodically
            self?.savePlaybackPosition()
        }
    }
    
    private func setupNotifications() {
        NotificationCenter.default.publisher(for: .AVPlayerItemDidPlayToEndTime)
            .sink { [weak self] _ in
                self?.handlePlaybackEnded()
            }
            .store(in: &cancellables)
    }
    
    private func savePlaybackPosition() {
        // Save to Core Data
        currentVideo?.playbackPosition = currentTime
    }
    
    private func handlePlaybackEnded() {
        isPlaying = false
        // Update play count
        if let video = currentVideo {
            video.playCount += 1
            video.lastPlayed = Date()
        }
    }
    
    deinit {
        if let observer = timeObserver {
            player?.removeTimeObserver(observer)
        }
    }
}

================================================================================

File: Managers/LibraryManager.swift
//
//  LibraryManager.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//

import Foundation
import CoreData
import Combine

// MARK: - Library Manager
@MainActor
class LibraryManager: ObservableObject {
    static let shared = LibraryManager()
    
    // MARK: - Published Properties
    @Published var currentLibrary: Library?
    @Published var isLibraryOpen = false
    @Published var recentLibraries: [LibraryDescriptor] = []
    @Published var isLoading = false
    @Published var loadingProgress: Double = 0
    @Published var error: LibraryError?
    
    // MARK: - Private Properties
    private let userDefaults = UserDefaults.standard
    private let fileManager = FileManager.default
    private var coreDataStack: CoreDataStack?
    private var cancellables = Set<AnyCancellable>()
    
    // MARK: - Constants
    private let libraryExtension = "pangolin"
    private let currentVersion = "1.0.0"
    private let recentLibrariesKey = "RecentLibraries"
    private let lastOpenedLibraryKey = "LastOpenedLibrary"
    
    // MARK: - Initialization
    private init() {
        loadRecentLibraries()
    }
    
    // MARK: - Public Properties
    
    /// Access to the current Core Data context
    var viewContext: NSManagedObjectContext? {
        return coreDataStack?.viewContext
    }
    
    // MARK: - Public Methods
    
    /// Saves the current library's data context if there are changes.
    func save() async {
        print("💽 LIBRARY: save() called")
        
        guard let context = self.viewContext else {
            print("❌ LIBRARY: No viewContext available")
            return
        }
        
        print("📊 LIBRARY: Context hasChanges: \(context.hasChanges)")
        print("📊 LIBRARY: Context insertedObjects count: \(context.insertedObjects.count)")
        print("📊 LIBRARY: Context updatedObjects count: \(context.updatedObjects.count)")
        print("📊 LIBRARY: Context deletedObjects count: \(context.deletedObjects.count)")
        
        // Log details about updated objects
        for obj in context.updatedObjects {
            print("📝 LIBRARY: Updated object: \(obj)")
            if let folder = obj as? Folder {
                print("📁 LIBRARY: Updated folder: '\(folder.name ?? "nil")' (ID: \(folder.id?.uuidString ?? "nil"))")
            } else if let video = obj as? Video {
                print("🎥 LIBRARY: Updated video: '\(video.title ?? "nil")' (ID: \(video.id?.uuidString ?? "nil"))")
            }
        }
        
        guard context.hasChanges else {
            print("ℹ️ LIBRARY: No changes to save")
            return
        }
        
        do {
            print("💾 LIBRARY: Attempting context.save()...")
            try context.save()
            print("✅ LIBRARY: Save successful!")
            
            // Verify that changes were actually saved by re-fetching
            print("🔄 LIBRARY: Verifying save by checking context state...")
            print("📊 LIBRARY: After save - hasChanges: \(context.hasChanges)")
            print("📊 LIBRARY: After save - updatedObjects count: \(context.updatedObjects.count)")
            
        } catch {
            print("💥 LIBRARY: Save failed: \(error.localizedDescription)")
            self.error = .saveFailed(error)
            context.rollback()
            print("🔄 LIBRARY: Context rolled back")
        }
    }
    
    /// Create a new library at the specified URL
    func createLibrary(at url: URL, name: String) async throws -> Library {
        isLoading = true
        loadingProgress = 0
        
        defer {
            isLoading = false
            loadingProgress = 0
        }
        
        // Create library package directory
        let libraryURL = url.appendingPathComponent("\(name).\(libraryExtension)")
        
        // Check if already exists
        if fileManager.fileExists(atPath: libraryURL.path) {
            throw LibraryError.libraryAlreadyExists(libraryURL)
        }
        
        // Create directory structure
        try createLibraryStructure(at: libraryURL)
        loadingProgress = 0.3
        
        // Initialize Core Data stack
        let stack = try CoreDataStack(libraryURL: libraryURL)
        self.coreDataStack = stack
        loadingProgress = 0.6
        
        // Create library entity using NSEntityDescription
        let context = stack.viewContext
        
        // Debug: Check if the managed object model is loaded correctly
        guard let model = context.persistentStoreCoordinator?.managedObjectModel else {
            print("ERROR: No managed object model found")
            throw LibraryError.corruptedDatabase
        }
        
        print("Available entities: \(model.entitiesByName.keys)")
        
        guard let entityDescription = model.entitiesByName["Library"] else {
            print("ERROR: Library entity not found in model")
            throw LibraryError.corruptedDatabase
        }
        
        print("Creating library entity with description: \(entityDescription)")
        let library = Library(entity: entityDescription, insertInto: context)
        
        // Verify library was created successfully
        guard library.entity == entityDescription else {
            print("ERROR: Library entity creation failed")
            throw LibraryError.corruptedDatabase
        }
        
        print("Library entity created successfully, setting properties...")
        
        library.id = UUID()
        library.name = name
        library.libraryPath = libraryURL.path
        library.createdDate = Date()
        library.lastOpenedDate = Date()
        library.version = currentVersion
        
        print("Basic properties set, setting default settings...")
        
        // Set default settings
        library.copyFilesOnImport = true
        library.organizeByDate = true
        library.autoMatchSubtitles = true
        library.defaultPlaybackSpeed = 1.0
        library.rememberPlaybackPosition = true
        
        print("All properties set successfully")
        
        // Create default smart folders
        createDefaultSmartFolders(for: library, in: context)
        loadingProgress = 0.8
        
        // Save context
        try context.save()
        
        // Update current library
        self.currentLibrary = library
        self.isLibraryOpen = true
        
        print("Library created successfully: \(library.name ?? "Untitled")")
        print("Library open state: \(self.isLibraryOpen)")
        
        // Add to recent libraries
        addToRecentLibraries(library)
        
        // Save as last opened
        saveLastOpenedLibrary(libraryURL)
        
        loadingProgress = 1.0
        
        return library
    }
    
    /// Open an existing library
    func openLibrary(at url: URL) async throws -> Library {
        isLoading = true
        loadingProgress = 0
        
        defer {
            isLoading = false
            loadingProgress = 0
        }
        
        // Validate library
        let validation = try validateLibrary(at: url)
        guard validation.isValid else {
            throw LibraryError.invalidLibrary(validation.errors)
        }
        loadingProgress = 0.2
        
        // Close current library if open
        if currentLibrary != nil {
            await closeCurrentLibrary()
        }
        loadingProgress = 0.3
        
        // Initialize Core Data stack
        let stack = try CoreDataStack(libraryURL: url)
        self.coreDataStack = stack
        loadingProgress = 0.5
        
        // Fetch library entity
        let context = stack.viewContext
        let request = Library.fetchRequest()
        request.fetchLimit = 1
        
        guard let library = try context.fetch(request).first else {
            throw LibraryError.libraryNotFound
        }
        loadingProgress = 0.7
        
        // Check for migration needs
        if library.version! != currentVersion {
            try await migrateLibrary(library, from: library.version!, to: currentVersion)
        }
        loadingProgress = 0.8
        
        // Ensure smart folders exist
        await ensureSmartFoldersExist(for: library, in: context)
        
        // Update library
        library.lastOpenedDate = Date()
        try context.save()
        
        // Set as current
        self.currentLibrary = library
        self.isLibraryOpen = true
        
        // Update recent libraries
        addToRecentLibraries(library)
        saveLastOpenedLibrary(url)
        
        loadingProgress = 1.0
        
        // Generate thumbnails for videos that don't have them (async in background)
        Task {
            await FileSystemManager.shared.generateMissingThumbnails(for: library, context: context)
        }
        
        return library
    }
    
    /// Close the current library
    func closeCurrentLibrary() async {
        guard currentLibrary != nil else { return }
        
        // Save any pending changes
        await save()
        
        // Clean up
        coreDataStack = nil
        currentLibrary = nil
        isLibraryOpen = false
    }
    
    /// Switch to a different library
    func switchToLibrary(_ descriptor: LibraryDescriptor) async throws {
        _ = try await openLibrary(at: descriptor.path)
    }
    
    /// Open the last used library
    func openLastLibrary() async throws {
        guard let lastLibraryPath = userDefaults.url(forKey: lastOpenedLibraryKey) else {
            throw LibraryError.noLastLibrary
        }
        
        _ = try await openLibrary(at: lastLibraryPath)
    }
    
    // MARK: - Library Validation
    
    struct LibraryValidation {
        let isValid: Bool
        let errors: [String]
        let isRepairable: Bool
    }
    
    func validateLibrary(at url: URL) throws -> LibraryValidation {
        var errors: [String] = []
        
        // Check if directory exists
        guard fileManager.fileExists(atPath: url.path) else {
            return LibraryValidation(isValid: false,
                                    errors: ["Library does not exist"],
                                    isRepairable: false)
        }
        
        // Check for required subdirectories
        let requiredDirs = ["Videos", "Subtitles", "Thumbnails", "Backups"]
        for dir in requiredDirs {
            let dirPath = url.appendingPathComponent(dir)
            if !fileManager.fileExists(atPath: dirPath.path) {
                errors.append("Missing directory: \(dir)")
            }
        }
        
        // Check for database
        let dbPath = url.appendingPathComponent("Library.sqlite")
        if !fileManager.fileExists(atPath: dbPath.path) {
            errors.append("Database file not found")
        }
        
        // Check Info.plist
        let infoPlistPath = url.appendingPathComponent("Info.plist")
        if !fileManager.fileExists(atPath: infoPlistPath.path) {
            errors.append("Info.plist not found")
        }
        
        let isValid = errors.isEmpty
        let isRepairable = !errors.contains("Database file not found")
        
        return LibraryValidation(isValid: isValid,
                                errors: errors,
                                isRepairable: isRepairable)
    }
    
    // MARK: - Private Methods
    
    private func createLibraryStructure(at url: URL) throws {
        // Create main directory
        try fileManager.createDirectory(at: url,
                                       withIntermediateDirectories: true)
        
        // Create subdirectories
        let subdirectories = ["Videos", "Subtitles", "Thumbnails", "Backups"]
        for dir in subdirectories {
            let dirURL = url.appendingPathComponent(dir)
            try fileManager.createDirectory(at: dirURL,
                                          withIntermediateDirectories: true)
        }
        
        // Create Info.plist
        let info: [String: Any] = [
            "Version": currentVersion,
            "CreatedDate": Date(),
            "BundleIdentifier": "com.pangolin.library",
            "LibraryType": "VideoLibrary"
        ]
        
        let infoPlistURL = url.appendingPathComponent("Info.plist")
        let plistData = try PropertyListSerialization.data(fromPropertyList: info,
                                                          format: .xml,
                                                          options: 0)
        try plistData.write(to: infoPlistURL)
    }
    
    
    private func loadRecentLibraries() {
        if let data = userDefaults.data(forKey: recentLibrariesKey),
           let libraries = try? JSONDecoder().decode([LibraryDescriptor].self, from: data) {
            self.recentLibraries = libraries
        }
    }
    
    private func addToRecentLibraries(_ library: Library) {
        guard let url = library.url else { return }
        
        let descriptor = LibraryDescriptor(
            id: library.id!,
            name: library.name!,
            path: url,
            lastOpenedDate: library.lastOpenedDate!,
            createdDate: library.createdDate!,
            version: library.version!,
            thumbnailData: nil,
            videoCount: library.videoCount,
            totalSize: library.totalSize
        )
        
        // Remove if already exists
        recentLibraries.removeAll { $0.id == descriptor.id }
        
        // Add to front
        recentLibraries.insert(descriptor, at: 0)
        
        // Keep only last 10
        if recentLibraries.count > 10 {
            recentLibraries = Array(recentLibraries.prefix(10))
        }
        
        // Save
        if let data = try? JSONEncoder().encode(recentLibraries) {
            userDefaults.set(data, forKey: recentLibrariesKey)
        }
    }
    
    private func saveLastOpenedLibrary(_ url: URL) {
        userDefaults.set(url, forKey: lastOpenedLibraryKey)
    }
    
    private func migrateLibrary(_ library: Library, from oldVersion: String, to newVersion: String) async throws {
        // Implement migration logic here
        library.version = newVersion
    }
    
    private func createDefaultSmartFolders(for library: Library, in context: NSManagedObjectContext) {
        guard let folderEntityDescription = context.persistentStoreCoordinator?.managedObjectModel.entitiesByName["Folder"] else {
            print("Could not find Folder entity description")
            return
        }
        
        let smartFolders = [
            ("All Videos", "video.fill"),
            ("Recent", "clock.fill"),
            ("Favorites", "heart.fill")
        ]
        
        // CORRECTED: The unused 'index' variable is replaced with '_'
        for (_, folderInfo) in smartFolders.enumerated() {
            let folder = Folder(entity: folderEntityDescription, insertInto: context)
            folder.id = UUID()
            folder.name = folderInfo.0
            folder.isTopLevel = true
            folder.isSmartFolder = true
            folder.dateCreated = Date()
            folder.dateModified = Date()
            folder.library = library
        }
    }
    
    private func ensureSmartFoldersExist(for library: Library, in context: NSManagedObjectContext) async {
        // Check if smart folders already exist
        let request = Folder.fetchRequest()
        request.predicate = NSPredicate(format: "library == %@ AND isSmartFolder == YES", library)
        
        do {
            let existingSmartFolders = try context.fetch(request)
            let existingNames = Set(existingSmartFolders.map { $0.name })
            
            let requiredSmartFolders = ["All Videos", "Recent", "Favorites"]
            
            // Create any missing smart folders
            for folderName in requiredSmartFolders {
                if !existingNames.contains(folderName) {
                    guard let folderEntityDescription = context.persistentStoreCoordinator?.managedObjectModel.entitiesByName["Folder"] else {
                        continue
                    }
                    
                    let folder = Folder(entity: folderEntityDescription, insertInto: context)
                    folder.id = UUID()
                    folder.name = folderName
                    folder.isTopLevel = true
                    folder.isSmartFolder = true
                    folder.dateCreated = Date()
                    folder.dateModified = Date()
                    folder.library = library
                }
            }
            
            try context.save()
        } catch {
            print("Failed to ensure smart folders exist: \(error)")
        }
    }
}

// MARK: - Library Errors
enum LibraryError: LocalizedError {
    case libraryAlreadyExists(URL)
    case libraryNotFound
    case invalidLibrary([String])
    case migrationFailed(String)
    case noLastLibrary
    case corruptedDatabase
    case insufficientPermissions
    case diskSpaceInsufficient
    case saveFailed(Error)
    
    var errorDescription: String? {
        switch self {
        case .libraryAlreadyExists(let url):
            return "A library already exists at \(url.lastPathComponent)"
        case .libraryNotFound:
            return "Library not found"
        case .invalidLibrary(let errors):
            return "Invalid library: \(errors.joined(separator: ", "))"
        case .migrationFailed(let reason):
            return "Migration failed: \(reason)"
        case .noLastLibrary:
            return "No previously opened library found"
        case .corruptedDatabase:
            return "The library database is corrupted"
        case .insufficientPermissions:
            return "Insufficient permissions to access library"
        case .diskSpaceInsufficient:
            return "Not enough disk space available"
        case .saveFailed(let error):
            return "Failed to save the library. \(error.localizedDescription)"
        }
    }
    
    var recoverySuggestion: String? {
        switch self {
        case .libraryAlreadyExists:
            return "Choose a different location or name for your library"
        case .libraryNotFound, .noLastLibrary:
            return "Create a new library or open an existing one"
        case .invalidLibrary:
            return "Try repairing the library or create a new one"
        case .migrationFailed, .saveFailed:
            return "Please try the operation again. If the problem persists, restart the application."
        case .corruptedDatabase:
            return "Restore from a backup or rebuild the library"
        case .insufficientPermissions:
            return "Check file permissions and try again"
        case .diskSpaceInsufficient:
            return "Free up disk space and try again"
        }
    }
}


================================================================================

File: Managers/FileSystemManager.swift
//
//  FileSystemManager.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//

import Foundation
import CoreData
import AVFoundation
#if os(macOS)
import AppKit
#else
import UIKit
#endif

class FileSystemManager {
    static let shared = FileSystemManager()
    
    private let fileManager = FileManager.default
    private let dateFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd"
        return formatter
    }()
    
    private init() {}
    
    // MARK: - Video File Operations
    
    func importVideo(from sourceURL: URL, to library: Library, context: NSManagedObjectContext, copyFile: Bool = true) async throws -> Video {
        guard let libraryURL = library.url else {
            throw FileSystemError.invalidLibraryPath
        }
        
        // Validate video file
        guard isVideoFile(sourceURL) else {
            throw FileSystemError.unsupportedFileType(sourceURL.pathExtension)
        }
        
        // Start accessing security-scoped resources for both source and destination
        let sourceAccessing = sourceURL.startAccessingSecurityScopedResource()
        let libraryAccessing = libraryURL.startAccessingSecurityScopedResource()
        defer {
            if sourceAccessing {
                sourceURL.stopAccessingSecurityScopedResource()
            }
            if libraryAccessing {
                libraryURL.stopAccessingSecurityScopedResource()
            }
        }
        
        // Create date-based subdirectory
        let importDate = Date()
        let dateString = dateFormatter.string(from: importDate)
        let videosDir = libraryURL.appendingPathComponent("Videos").appendingPathComponent(dateString)
        
        // Ensure directory exists
        try fileManager.createDirectory(at: videosDir, withIntermediateDirectories: true)
        
        // Determine destination URL
        let fileName = sourceURL.lastPathComponent
        var destinationURL = videosDir.appendingPathComponent(fileName)
        
        // Handle duplicates
        destinationURL = try uniqueURL(for: destinationURL)
        
        // Copy or move file
        if copyFile {
            try fileManager.copyItem(at: sourceURL, to: destinationURL)
        } else {
            try fileManager.moveItem(at: sourceURL, to: destinationURL)
        }
        
        // Get relative path
        let relativePath = destinationURL.path.replacingOccurrences(of: libraryURL.path + "/Videos/", with: "")
        
        // Get video metadata
        let metadata = try await getVideoMetadata(from: destinationURL)
        
        // Generate thumbnail
        let thumbnailPath = try await generateThumbnail(for: destinationURL, in: library)
        
        // Create video entity in Core Data context using entity description
        guard let videoEntityDescription = context.persistentStoreCoordinator?.managedObjectModel.entitiesByName["Video"] else {
            throw FileSystemError.importFailed("Could not find Video entity description")
        }
        
        let video = Video(entity: videoEntityDescription, insertInto: context)
        video.id = UUID()
        video.title = sourceURL.deletingPathExtension().lastPathComponent
        video.fileName = fileName
        video.relativePath = relativePath
        video.duration = metadata.duration
        video.fileSize = metadata.fileSize
        video.dateAdded = importDate
        video.videoFormat = sourceURL.pathExtension
        video.resolution = metadata.resolution
        video.frameRate = metadata.frameRate
        video.playbackPosition = 0
        video.playCount = 0
        video.thumbnailPath = thumbnailPath
        video.library = library
        
        return video
    }
    
    func importFolder(at folderURL: URL, to library: Library, context: NSManagedObjectContext) async throws -> [Video] {
        var importedVideos: [Video] = []
        
        let enumerator = fileManager.enumerator(at: folderURL,
                                               includingPropertiesForKeys: [.isRegularFileKey],
                                               options: [.skipsHiddenFiles])
        
        while let fileURL = enumerator?.nextObject() as? URL {
            if isVideoFile(fileURL) {
                do {
                    let video = try await importVideo(from: fileURL, to: library, context: context)
                    importedVideos.append(video)
                } catch {
                    // Log error but continue importing other files
                    print("Failed to import \(fileURL): \(error)")
                }
            }
        }
        
        return importedVideos
    }
    
    // MARK: - Subtitle Operations
    
    func findMatchingSubtitles(for videoURL: URL) -> [URL] {
        let videoName = videoURL.deletingPathExtension().lastPathComponent
        let directory = videoURL.deletingLastPathComponent()
        
        var subtitles: [URL] = []
        
        do {
            let files = try fileManager.contentsOfDirectory(at: directory,
                                                           includingPropertiesForKeys: nil)
            
            for file in files {
                if isSubtitleFile(file) {
                    let subtitleName = file.deletingPathExtension().lastPathComponent
                    
                    // Check various matching patterns
                    if subtitleName == videoName ||
                       subtitleName.hasPrefix(videoName + ".") ||
                       subtitleName.hasPrefix(videoName + "_") {
                        subtitles.append(file)
                    }
                }
            }
        } catch {
            print("Error finding subtitles: \(error)")
        }
        
        return subtitles
    }
    
    // MARK: - Helper Methods
    
    private func isVideoFile(_ url: URL) -> Bool {
        let videoExtensions = VideoFormat.supportedExtensions
        return videoExtensions.contains(url.pathExtension.lowercased())
    }
    
    private func isSubtitleFile(_ url: URL) -> Bool {
        let subtitleExtensions = ["srt", "vtt", "ssa", "ass", "sub"]
        return subtitleExtensions.contains(url.pathExtension.lowercased())
    }
    
    private func uniqueURL(for url: URL) throws -> URL {
        var uniqueURL = url
        var counter = 1
        
        while fileManager.fileExists(atPath: uniqueURL.path) {
            let name = url.deletingPathExtension().lastPathComponent
            let ext = url.pathExtension
            uniqueURL = url.deletingLastPathComponent()
                .appendingPathComponent("\(name)_\(counter)")
                .appendingPathExtension(ext)
            counter += 1
        }
        
        return uniqueURL
    }
    
    private func getVideoMetadata(from url: URL) async throws -> VideoMetadata {
        let asset = AVURLAsset(url: url)
        
        // Get duration
        let duration = try await asset.load(.duration)
        let durationSeconds = CMTimeGetSeconds(duration)
        
        // Get file size
        let attributes = try fileManager.attributesOfItem(atPath: url.path)
        let fileSize = attributes[.size] as? Int64 ?? 0
        
        // Get video track for resolution and frame rate
        let tracks = try await asset.loadTracks(withMediaType: .video)
        var resolution = ""
        var frameRate = 0.0
        
        if let videoTrack = tracks.first {
            let size = try await videoTrack.load(.naturalSize)
            resolution = "\(Int(size.width))x\(Int(size.height))"
            
            let rate = try await videoTrack.load(.nominalFrameRate)
            frameRate = Double(rate)
        }
        
        return VideoMetadata(
            duration: durationSeconds,
            fileSize: fileSize,
            resolution: resolution,
            frameRate: frameRate
        )
    }
    
    // MARK: - Thumbnail Generation
    
    private func generateThumbnail(for videoURL: URL, in library: Library) async throws -> String? {
        guard let libraryURL = library.url else {
            throw FileSystemError.invalidLibraryPath
        }
        
        // Start accessing security-scoped resources for both video and library
        let videoAccessing = videoURL.startAccessingSecurityScopedResource()
        let libraryAccessing = libraryURL.startAccessingSecurityScopedResource()
        defer {
            if videoAccessing {
                videoURL.stopAccessingSecurityScopedResource()
            }
            if libraryAccessing {
                libraryURL.stopAccessingSecurityScopedResource()
            }
        }
        
        let asset = AVURLAsset(url: videoURL)
        let imageGenerator = AVAssetImageGenerator(asset: asset)
        imageGenerator.appliesPreferredTrackTransform = true
        imageGenerator.maximumSize = CGSize(width: 1280, height: 720) // High quality 16:9 aspect ratio
        
        // Generate thumbnail at 10% of video duration, or 5 seconds, whichever is smaller
        let duration = try await asset.load(.duration)
        let durationSeconds = CMTimeGetSeconds(duration)
        let thumbnailTime = CMTime(seconds: min(durationSeconds * 0.1, 5.0), preferredTimescale: 600)
        
        do {
            let cgImage = try await imageGenerator.image(at: thumbnailTime).image
            
            // Create thumbnail directory structure
            let videoRelativePath = videoURL.path.replacingOccurrences(of: libraryURL.path + "/Videos/", with: "")
            let thumbnailDir = libraryURL.appendingPathComponent("Thumbnails")
                .appendingPathComponent(URL(fileURLWithPath: videoRelativePath).deletingLastPathComponent().path)
            
            try fileManager.createDirectory(at: thumbnailDir, withIntermediateDirectories: true)
            
            // Save thumbnail as JPEG
            let thumbnailFileName = URL(fileURLWithPath: videoRelativePath).deletingPathExtension().lastPathComponent + ".jpg"
            let thumbnailURL = thumbnailDir.appendingPathComponent(thumbnailFileName)
            
            #if os(macOS)
            let nsImage = NSImage(cgImage: cgImage, size: NSSize(width: cgImage.width, height: cgImage.height))
            if let tiffData = nsImage.tiffRepresentation,
               let bitmapRep = NSBitmapImageRep(data: tiffData),
               let jpegData = bitmapRep.representation(using: .jpeg, properties: [.compressionFactor: 0.8]) {
                try jpegData.write(to: thumbnailURL)
            }
            #else
            let uiImage = UIImage(cgImage: cgImage)
            if let jpegData = uiImage.jpegData(compressionQuality: 0.8) {
                try jpegData.write(to: thumbnailURL)
            }
            #endif
            
            // Return relative path for thumbnail
            return thumbnailURL.path.replacingOccurrences(of: libraryURL.path + "/Thumbnails/", with: "")
            
        } catch {
            print("Failed to generate thumbnail for \(videoURL.lastPathComponent): \(error)")
            return nil
        }
    }
    
    // MARK: - Thumbnail Generation for Existing Videos
    
    nonisolated func generateMissingThumbnails(for library: Library, context: NSManagedObjectContext) async {
        guard library.url != nil else { return }
        
        let request = Video.fetchRequest()
        request.predicate = NSPredicate(format: "library == %@ AND thumbnailPath == nil", library)
        
        do {
            let videosWithoutThumbnails = try context.fetch(request)
            print("Found \(videosWithoutThumbnails.count) videos without thumbnails")
            
            for video in videosWithoutThumbnails {
                guard let videoURL = video.fileURL else { continue }
                
                do {
                    let thumbnailPath = try await generateThumbnail(for: videoURL, in: library)
                    await MainActor.run {
                        video.thumbnailPath = thumbnailPath
                    }
                } catch {
                    print("Failed to generate thumbnail for \(video.fileName ?? "Unknown Video"): \(error)")
                }
            }
            
            // Save context on main thread
            await MainActor.run {
                do {
                    try context.save()
                    print("Successfully saved thumbnails for \(videosWithoutThumbnails.count) videos")
                } catch {
                    print("Failed to save thumbnail paths: \(error)")
                }
            }
            
        } catch {
            print("Failed to fetch videos without thumbnails: \(error)")
        }
    }
    
    nonisolated func rebuildAllThumbnails(for library: Library, context: NSManagedObjectContext) async {
        guard library.url != nil else { return }
        
        let request = Video.fetchRequest()
        request.predicate = NSPredicate(format: "library == %@", library)
        
        do {
            let allVideos = try context.fetch(request)
            print("Rebuilding thumbnails for \(allVideos.count) videos")
            
            for video in allVideos {
                guard let videoURL = video.fileURL else { continue }
                
                do {
                    let thumbnailPath = try await generateThumbnail(for: videoURL, in: library)
                    await MainActor.run {
                        video.thumbnailPath = thumbnailPath
                    }
                } catch {
                    print("Failed to rebuild thumbnail for \(video.fileName ?? "Unknown Video"): \(error)")
                }
            }
            
            // Save context on main thread
            await MainActor.run {
                do {
                    try context.save()
                    print("Successfully rebuilt thumbnails for \(allVideos.count) videos")
                } catch {
                    print("Failed to save rebuilt thumbnail paths: \(error)")
                }
            }
            
        } catch {
            print("Failed to fetch videos for thumbnail rebuild: \(error)")
        }
    }
}

// MARK: - Supporting Types

struct VideoMetadata {
    let duration: TimeInterval
    let fileSize: Int64
    let resolution: String
    let frameRate: Double
}

enum FileSystemError: LocalizedError {
    case invalidLibraryPath
    case unsupportedFileType(String)
    case importFailed(String)
    case fileNotFound
    case insufficientSpace
    case accessDenied
    
    var errorDescription: String? {
        switch self {
        case .invalidLibraryPath:
            return "Invalid library path"
        case .unsupportedFileType(let ext):
            return "Unsupported file type: .\(ext)"
        case .importFailed(let reason):
            return "Import failed: \(reason)"
        case .fileNotFound:
            return "File not found"
        case .insufficientSpace:
            return "Insufficient disk space"
        case .accessDenied:
            return "Access denied to file or folder"
        }
    }
}

================================================================================

File: Assets.xcassets/Contents.json
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}


================================================================================

File: Assets.xcassets/AppIcon.appiconset/Contents.json
{
  "images" : [
    {
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "appearances" : [
        {
          "appearance" : "luminosity",
          "value" : "dark"
        }
      ],
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "appearances" : [
        {
          "appearance" : "luminosity",
          "value" : "tinted"
        }
      ],
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "idiom" : "mac",
      "scale" : "1x",
      "size" : "16x16"
    },
    {
      "idiom" : "mac",
      "scale" : "2x",
      "size" : "16x16"
    },
    {
      "idiom" : "mac",
      "scale" : "1x",
      "size" : "32x32"
    },
    {
      "idiom" : "mac",
      "scale" : "2x",
      "size" : "32x32"
    },
    {
      "idiom" : "mac",
      "scale" : "1x",
      "size" : "128x128"
    },
    {
      "idiom" : "mac",
      "scale" : "2x",
      "size" : "128x128"
    },
    {
      "idiom" : "mac",
      "scale" : "1x",
      "size" : "256x256"
    },
    {
      "idiom" : "mac",
      "scale" : "2x",
      "size" : "256x256"
    },
    {
      "idiom" : "mac",
      "scale" : "1x",
      "size" : "512x512"
    },
    {
      "idiom" : "mac",
      "scale" : "2x",
      "size" : "512x512"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}


================================================================================

File: Assets.xcassets/AccentColor.colorset/Contents.json
{
  "colors" : [
    {
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}


================================================================================

File: Stores/FolderNavigationStore.swift
//
//  FolderNavigationStore.swift
//  Pangolin
//
//  Created by Matt Kevan on 18/08/2025.
//

import SwiftUI
import CoreData
import Combine

@MainActor
class FolderNavigationStore: ObservableObject {
    // MARK: - Core State
    @Published var navigationPath = NavigationPath()
    @Published var currentFolderID: UUID?
    @Published var selectedTopLevelFolder: Folder?
    @Published var selectedVideo: Video?
    
    // Reactive data sources for the UI
    @Published var hierarchicalContent: [HierarchicalContentItem] = []
    @Published var flatContent: [ContentType] = []

    // MARK: - UI State
    @Published var currentSortOption: SortOption = .foldersFirst {
        didSet {
            // Re-apply sorting whenever the option changes
            self.flatContent = applySorting(self.flatContent)
        }
    }
    @Published var isLoading = false
    @Published var errorMessage: String?
    
    // MARK: - Dependencies
    private let libraryManager: LibraryManager
    private var cancellables = Set<AnyCancellable>()
    
    init(libraryManager: LibraryManager) {
        self.libraryManager = libraryManager
        
        // Subscribe to Core Data saves to auto-refresh the UI
        if let context = libraryManager.viewContext {
            NotificationCenter.default
                .publisher(for: .NSManagedObjectContextDidSave, object: context)
                .debounce(for: .milliseconds(50), scheduler: DispatchQueue.main) // Prevent refresh storms
                .sink { [weak self] _ in
                    print("🧠 STORE: Context saved, refreshing content.")
                    self?.refreshContent()
                }
                .store(in: &cancellables)
        }
        
        // Subscribe to internal navigation changes to refresh content
        $currentFolderID
            .dropFirst()
            .receive(on: DispatchQueue.main)
            .sink { [weak self] _ in
                print("🧠 STORE: Current folder changed, refreshing content.")
                self?.refreshContent()
            }
            .store(in: &cancellables)
        
        // Set initial folder and load initial content
        Task {
            guard let context = libraryManager.viewContext,
                  let library = libraryManager.currentLibrary else {
                refreshContent()
                return
            }
            
            let request = Folder.fetchRequest()
            request.predicate = NSPredicate(format: "library == %@ AND isTopLevel == YES AND isSmartFolder == YES AND name == %@", library, "All Videos")
            request.fetchLimit = 1
            
            do {
                if let allVideosFolder = try context.fetch(request).first {
                    selectedTopLevelFolder = allVideosFolder
                    currentFolderID = allVideosFolder.id // This triggers the sink above to load content
                } else {
                    refreshContent()
                }
            } catch {
                print("Error setting initial folder: \(error)")
                refreshContent()
            }
        }
    }
    
    // MARK: - Content Fetching
    private func refreshContent() {
        guard let context = libraryManager.viewContext,
              let library = libraryManager.currentLibrary,
              let folderID = currentFolderID else {
            self.hierarchicalContent = []
            self.flatContent = []
            return
        }
        
        let folderRequest = Folder.fetchRequest()
        folderRequest.predicate = NSPredicate(format: "library == %@ AND id == %@", library, folderID as CVarArg)
        
        var newHierarchicalContent: [HierarchicalContentItem] = []
        var newFlatContent: [ContentType] = []
        
        do {
            if let folder = try context.fetch(folderRequest).first {
                if folder.isSmartFolder {
                    let contentItems = getSmartFolderContent(folder: folder, library: library, context: context)
                    newFlatContent = contentItems
                    newHierarchicalContent = contentItems.compactMap { item in
                        if case .video(let video) = item { return HierarchicalContentItem(video: video) }
                        return nil
                    }
                } else {
                    let childFolders = folder.childFoldersArray
                    let childVideos = folder.videosArray

                    for childFolder in childFolders {
                        newHierarchicalContent.append(HierarchicalContentItem(folder: childFolder))
                        newFlatContent.append(.folder(childFolder))
                    }
                    for video in childVideos {
                        newHierarchicalContent.append(HierarchicalContentItem(video: video))
                        newFlatContent.append(.video(video))
                    }
                }
            }
        } catch {
            errorMessage = "Failed to load content: \(error.localizedDescription)"
        }
        
        // Populate the publishers
        self.hierarchicalContent = newHierarchicalContent
        self.flatContent = applySorting(newFlatContent)
    }
    
    // MARK: - Content Access (for Sidebar)
    func systemFolders() -> [Folder] {
        guard let context = libraryManager.viewContext, let library = libraryManager.currentLibrary else { return [] }
        let request = Folder.fetchRequest()
        request.predicate = NSPredicate(format: "library == %@ AND isTopLevel == YES AND isSmartFolder == YES", library)
        request.sortDescriptors = [NSSortDescriptor(keyPath: \Folder.name, ascending: true)]
        do {
            return try context.fetch(request)
        } catch {
            errorMessage = "Failed to load system folders: \(error.localizedDescription)"
            return []
        }
    }
    
    func userFolders() -> [Folder] {
        guard let context = libraryManager.viewContext, let library = libraryManager.currentLibrary else { return [] }
        let request = Folder.fetchRequest()
        request.predicate = NSPredicate(format: "library == %@ AND isTopLevel == YES AND isSmartFolder == NO", library)
        request.sortDescriptors = [NSSortDescriptor(keyPath: \Folder.name, ascending: true)]
        do {
            return try context.fetch(request)
        } catch {
            errorMessage = "Failed to load user folders: \(error.localizedDescription)"
            return []
        }
    }
    
    // MARK: - Navigation
    func navigateToFolder(_ folderID: UUID) {
        navigationPath.append(folderID)
        currentFolderID = folderID
    }
    
    func navigateBack() {
        guard !navigationPath.isEmpty else { return }
        navigationPath.removeLast()
        
        if navigationPath.isEmpty {
            currentFolderID = selectedTopLevelFolder?.id
        } else {
            // Complex navigation could decode the path here
        }
    }
    
    func navigateToRoot() {
        navigationPath = NavigationPath()
        currentFolderID = selectedTopLevelFolder?.id
    }
    
    func selectVideo(_ video: Video) {
        selectedVideo = video
    }
    
    // MARK: - Folder Management
    func createFolder(name: String, in parentFolderID: UUID? = nil) async {
        guard let context = libraryManager.viewContext,
              let library = libraryManager.currentLibrary,
              let folderEntityDescription = context.persistentStoreCoordinator?.managedObjectModel.entitiesByName["Folder"] else {
            errorMessage = "Could not create folder"
            return
        }
        
        let trimmedName = name.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmedName.isEmpty else { return }
        
        let folder = Folder(entity: folderEntityDescription, insertInto: context)
        folder.id = UUID()
        folder.name = trimmedName
        folder.isTopLevel = (parentFolderID == nil)
        folder.dateCreated = Date()
        folder.dateModified = Date()
        folder.library = library
        
        if let parentFolderID = parentFolderID {
            let parentRequest = Folder.fetchRequest()
            parentRequest.predicate = NSPredicate(format: "library == %@ AND id == %@", library, parentFolderID as CVarArg)
            do {
                if let parentFolder = try context.fetch(parentRequest).first {
                    folder.parentFolder = parentFolder
                    folder.isTopLevel = false
                }
            } catch {
                errorMessage = "Failed to find parent folder: \(error.localizedDescription)"
                context.rollback()
                return
            }
        }
        await libraryManager.save()
    }
    
    func moveItems(_ itemIDs: Set<UUID>, to destinationFolderID: UUID?) async {
        guard let context = libraryManager.viewContext,
              libraryManager.currentLibrary != nil, !itemIDs.isEmpty else { return }
        
        do {
            let destinationFolder: Folder?
            if let destID = destinationFolderID {
                let destRequest = Folder.fetchRequest()
                destRequest.predicate = NSPredicate(format: "id == %@", destID as CVarArg)
                destinationFolder = try context.fetch(destRequest).first
            } else {
                destinationFolder = nil
            }
            
            var itemsToMove: [NSManagedObject] = []
            
            let videoRequest = Video.fetchRequest()
            videoRequest.predicate = NSPredicate(format: "id IN %@", itemIDs)
            itemsToMove.append(contentsOf: try context.fetch(videoRequest))
            
            let folderRequest = Folder.fetchRequest()
            folderRequest.predicate = NSPredicate(format: "id IN %@", itemIDs)
            itemsToMove.append(contentsOf: try context.fetch(folderRequest))

            for item in itemsToMove {
                if let video = item as? Video {
                    video.folder = destinationFolder
                } else if let folder = item as? Folder {
                    folder.parentFolder = destinationFolder
                    folder.isTopLevel = (destinationFolder == nil)
                    folder.dateModified = Date()
                }
            }
            
            if context.hasChanges {
                await libraryManager.save()
            }
        } catch {
            errorMessage = "Failed to move items: \(error.localizedDescription)"
            context.rollback()
        }
    }
    
    // MARK: - Sorting
    private func applySorting(_ items: [ContentType]) -> [ContentType] {
        switch currentSortOption {
        case .nameAscending:
            return items.sorted { $0.name.localizedCompare($1.name) == .orderedAscending }
        case .nameDescending:
            return items.sorted { $0.name.localizedCompare($1.name) == .orderedDescending }
        case .dateCreatedNewest:
            return items.sorted { $0.dateCreated > $1.dateCreated }
        case .dateCreatedOldest:
            return items.sorted { $0.dateCreated < $1.dateCreated }
        case .foldersFirst:
            return items.sorted { lhs, rhs in
                if lhs.isFolder != rhs.isFolder {
                    return lhs.isFolder
                }
                return lhs.name.localizedCompare(rhs.name) == .orderedAscending
            }
        }
    }
    
    // MARK: - Folder Name
    func folderName(for folderID: UUID?) -> String {
        guard let folderID = folderID,
              let context = libraryManager.viewContext,
              let library = libraryManager.currentLibrary else {
            return "Library"
        }
        
        let request = Folder.fetchRequest()
        request.predicate = NSPredicate(format: "library == %@ AND id == %@", library, folderID as CVarArg)
        
        do {
            if let folder = try context.fetch(request).first {
                return folder.name!
            }
        } catch {}
        
        return "Unknown Folder"
    }
    
    // MARK: - Smart Folder Content
    private func getSmartFolderContent(folder: Folder, library: Library, context: NSManagedObjectContext) -> [ContentType] {
        var contentItems: [ContentType] = []
        let videoRequest = Video.fetchRequest()
        
        switch folder.name {
        case "All Videos":
            videoRequest.predicate = NSPredicate(format: "library == %@", library)
            videoRequest.sortDescriptors = [NSSortDescriptor(keyPath: \Video.title, ascending: true)]
        case "Recent":
            let thirtyDaysAgo = Calendar.current.date(byAdding: .day, value: -30, to: Date()) ?? Date()
            videoRequest.predicate = NSPredicate(format: "library == %@ AND dateAdded >= %@", library, thirtyDaysAgo as NSDate)
            videoRequest.sortDescriptors = [NSSortDescriptor(keyPath: \Video.dateAdded, ascending: false)]
            videoRequest.fetchLimit = 50
        case "Favorites":
            videoRequest.predicate = NSPredicate(format: "library == %@ AND isFavorite == YES", library)
            videoRequest.sortDescriptors = [NSSortDescriptor(keyPath: \Video.title, ascending: true)]
            print("🧠 STORE: Fetching Favorites smart folder content")
        default:
            return []
        }
        
        do {
            let videos = try context.fetch(videoRequest)
            if folder.name == "Favorites" {
                print("🧠 STORE: Found \(videos.count) favorite videos")
                for video in videos {
                    print("🧠 STORE: Favorite video: '\(video.title ?? "Unknown")' (isFavorite: \(video.isFavorite))")
                }
            }
            contentItems = videos.map { .video($0) }
        } catch {
            errorMessage = "Failed to load smart folder content: \(error.localizedDescription)"
        }
        
        return contentItems
    }
    
    // MARK: - Renaming
    func renameItem(id: UUID, to newName: String) async {
        guard let context = libraryManager.viewContext else { return }
        
        let trimmedName = newName.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmedName.isEmpty else { return }
        
        do {
            let folderRequest = Folder.fetchRequest()
            folderRequest.predicate = NSPredicate(format: "id == %@", id as CVarArg)
            
            if let folder = try context.fetch(folderRequest).first {
                folder.name = trimmedName
                folder.dateModified = Date()
                await libraryManager.save()
                return
            }
            
            let videoRequest = Video.fetchRequest()
            videoRequest.predicate = NSPredicate(format: "id == %@", id as CVarArg)
            
            if let video = try context.fetch(videoRequest).first {
                video.title = trimmedName
                await libraryManager.save()
                return
            }
        } catch {
            errorMessage = "Failed to find item to rename: \(error.localizedDescription)"
            context.rollback()
        }
    }
    
    // MARK: - Deletion
    func deleteItems(_ itemIDs: Set<UUID>) async -> Bool {
        guard let context = libraryManager.viewContext,
              let library = libraryManager.currentLibrary else {
            errorMessage = "Unable to access library context"
            return false
        }
        
        do {
            // Find all folders to delete
            let folderRequest = Folder.fetchRequest()
            folderRequest.predicate = NSPredicate(format: "id IN %@", itemIDs)
            let foldersToDelete = try context.fetch(folderRequest)
            
            // Find all videos to delete
            let videoRequest = Video.fetchRequest()
            videoRequest.predicate = NSPredicate(format: "id IN %@", itemIDs)
            let videosToDelete = try context.fetch(videoRequest)
            
            // Prevent deletion of system folders
            for folder in foldersToDelete {
                if folder.isSmartFolder {
                    errorMessage = "Cannot delete system folders"
                    return false
                }
            }
            
            // Delete files from file system first
            var allVideosToDelete: [Video] = []
            
            // Collect videos from folders recursively
            for folder in foldersToDelete {
                allVideosToDelete.append(contentsOf: collectAllVideos(from: folder))
            }
            
            // Add directly selected videos
            allVideosToDelete.append(contentsOf: videosToDelete)
            
            // Remove duplicates
            allVideosToDelete = Array(Set(allVideosToDelete))
            
            // Delete files from disk
            await deleteVideoFiles(allVideosToDelete, library: library)
            
            // Delete from Core Data (this will cascade to child folders and videos)
            for folder in foldersToDelete {
                context.delete(folder)
            }
            
            for video in videosToDelete {
                context.delete(video)
            }
            
            // Save changes
            if context.hasChanges {
                try context.save()
                print("🗑️ DELETION: Successfully deleted \(itemIDs.count) items")
                
                // Update selected video if it was deleted
                if let selectedVideo = selectedVideo,
                   itemIDs.contains(selectedVideo.id!) {
                    self.selectedVideo = nil
                }
                
                return true
            }
            
            return true
            
        } catch {
            errorMessage = "Failed to delete items: \(error.localizedDescription)"
            context.rollback()
            return false
        }
    }
    
    private func collectAllVideos(from folder: Folder) -> [Video] {
        var videos: [Video] = []
        
        // Add videos directly in this folder
        videos.append(contentsOf: folder.videosArray)
        
        // Recursively collect from child folders
        for childFolder in folder.childFoldersArray {
            videos.append(contentsOf: collectAllVideos(from: childFolder))
        }
        
        return videos
    }
    
    private func deleteVideoFiles(_ videos: [Video], library: Library) async {
        guard let libraryURL = library.url else { return }
        
        for video in videos {
            // Delete video file
            if let videoURL = video.fileURL {
                do {
                    try FileManager.default.removeItem(at: videoURL)
                    print("🗑️ DELETION: Deleted video file: \(videoURL.lastPathComponent)")
                } catch {
                    print("⚠️ DELETION: Failed to delete video file \(videoURL.lastPathComponent): \(error)")
                }
            }
            
            // Delete thumbnail
            if let thumbnailURL = video.thumbnailURL {
                do {
                    try FileManager.default.removeItem(at: thumbnailURL)
                    print("🗑️ DELETION: Deleted thumbnail: \(thumbnailURL.lastPathComponent)")
                } catch {
                    print("⚠️ DELETION: Failed to delete thumbnail \(thumbnailURL.lastPathComponent): \(error)")
                }
            }
            
            // Delete subtitles
            if let subtitles = video.subtitles as? Set<Subtitle> {
                for subtitle in subtitles {
                    if let subtitleURL = subtitle.fileURL {
                        do {
                            try FileManager.default.removeItem(at: subtitleURL)
                            print("🗑️ DELETION: Deleted subtitle: \(subtitleURL.lastPathComponent)")
                        } catch {
                            print("⚠️ DELETION: Failed to delete subtitle \(subtitleURL.lastPathComponent): \(error)")
                        }
                    }
                }
            }
        }
        
        // Clean up empty directories
        await cleanupEmptyDirectories(in: libraryURL)
    }
    
    private func cleanupEmptyDirectories(in libraryURL: URL) async {
        let directories = [
            libraryURL.appendingPathComponent("Videos"),
            libraryURL.appendingPathComponent("Thumbnails"),
            libraryURL.appendingPathComponent("Subtitles")
        ]
        
        for directory in directories {
            await cleanupEmptyDirectoriesRecursively(at: directory)
        }
    }
    
    private func cleanupEmptyDirectoriesRecursively(at url: URL) async {
        do {
            let contents = try FileManager.default.contentsOfDirectory(at: url, includingPropertiesForKeys: nil)
            
            // First, recursively clean subdirectories
            for item in contents {
                var isDirectory: ObjCBool = false
                if FileManager.default.fileExists(atPath: item.path, isDirectory: &isDirectory), isDirectory.boolValue {
                    await cleanupEmptyDirectoriesRecursively(at: item)
                }
            }
            
            // Check if directory is now empty and remove it
            let updatedContents = try FileManager.default.contentsOfDirectory(at: url, includingPropertiesForKeys: nil)
            if updatedContents.isEmpty {
                try FileManager.default.removeItem(at: url)
                print("🗑️ DELETION: Cleaned up empty directory: \(url.lastPathComponent)")
            }
        } catch {
            // Directory doesn't exist or can't be read - that's fine
        }
    }
}

================================================================================

File: CoreData/CoreDataStack.swift
// CoreData/CoreDataStack.swift
import Foundation
import CoreData
import AVFoundation

class CoreDataStack {
    private let modelName = "Pangolin"
    private let libraryURL: URL
    
    lazy var persistentContainer: NSPersistentContainer = {
        let container = NSPersistentContainer(name: "Pangolin")
        
        // Configure for library-specific storage
        let storeURL = libraryURL.appendingPathComponent("Library.sqlite")
        let storeDescription = NSPersistentStoreDescription(url: storeURL)
        storeDescription.shouldMigrateStoreAutomatically = true
        storeDescription.shouldInferMappingModelAutomatically = true
        
        // Performance optimizations
        storeDescription.setOption(true as NSNumber, forKey: NSPersistentHistoryTrackingKey)
        storeDescription.setOption(true as NSNumber, forKey: NSPersistentStoreRemoteChangeNotificationPostOptionKey)
        
        container.persistentStoreDescriptions = [storeDescription]
        
        container.loadPersistentStores { (storeDescription, error) in
            if let error = error as NSError? {
                // Log error - in production, handle this more gracefully
                print("Core Data error: \(error), \(error.userInfo)")
                fatalError("Unresolved error \(error), \(error.userInfo)")
            }
        }
        
        container.viewContext.automaticallyMergesChangesFromParent = true
        container.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
        
        return container
    }()
    
    
    var viewContext: NSManagedObjectContext {
        return persistentContainer.viewContext
    }
    
    init(libraryURL: URL) throws {
        self.libraryURL = libraryURL
    }
    
    func saveContext() throws {
        let context = persistentContainer.viewContext
        
        if context.hasChanges {
            try context.save()
        }
    }
    
    func performBackgroundTask<T>(_ block: @escaping (NSManagedObjectContext) throws -> T) async throws -> T {
        return try await withCheckedThrowingContinuation { continuation in
            persistentContainer.performBackgroundTask { context in
                do {
                    let result = try block(context)
                    continuation.resume(returning: result)
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }
}


================================================================================

File: Models/FolderTransfer.swift
//
//  FolderTransfer.swift
//  Pangolin
//
//  Created by Matt Kevan on 17/08/2025.
//

import Foundation
import UniformTypeIdentifiers
import CoreTransferable

struct FolderTransfer: Codable, Transferable {
    let id: UUID
    let name: String
    let parentId: UUID?
    
    init(folder: Folder) {
        self.id = folder.id!
        self.name = folder.name!
        self.parentId = folder.parentFolder?.id
    }
    
    static var transferRepresentation: some TransferRepresentation {
        CodableRepresentation(contentType: .data)
    }
}

================================================================================

File: Models/ContentTransfer.swift
//
//  ContentTransfer.swift
//  Pangolin
//
//  Created by Matt Kevan on 18/08/2025.
//

import Foundation
import CoreTransferable

struct ContentTransfer: Codable, Transferable {
    let itemIDs: [UUID]
    
    static var transferRepresentation: some TransferRepresentation {
        CodableRepresentation(contentType: .data)
    }
}

================================================================================

File: Models/VideoModel.swift
//
//  Video.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//


// Models/VideoModel.swift
import Foundation
import CoreData
import AVFoundation

// MARK: - Core Data Extensions
// Base classes are auto-generated by Core Data from .xcdatamodeld

// MARK: - Video Extensions
extension Video {
    // Computed properties
    var fileURL: URL? {
        guard let library = library,
              let libraryPath = library.url else { return nil }
        return libraryPath.appendingPathComponent("Videos").appendingPathComponent(relativePath!)
    }
    
    var formattedDuration: String {
        let formatter = DateComponentsFormatter()
        formatter.allowedUnits = [.hour, .minute, .second]
        formatter.unitsStyle = .positional
        formatter.zeroFormattingBehavior = .pad
        return formatter.string(from: duration) ?? "00:00"
    }
    
    var hasSubtitles: Bool {
        return (subtitles?.count ?? 0) > 0
    }
    
    var thumbnailURL: URL? {
        guard let library = library,
              let libraryPath = library.url,
              let thumbnailPath = thumbnailPath else { return nil }
        return libraryPath.appendingPathComponent("Thumbnails").appendingPathComponent(thumbnailPath)
    }
}

// MARK: - Folder Extensions
extension Folder {
    // Computed properties
    var childFoldersArray: [Folder] {
        guard let children = childFolders else { return [] }
        return children.compactMap { $0 as? Folder }.sorted { 
            ($0.name ?? "").localizedCompare($1.name ?? "") == .orderedAscending 
        }
    }
    
    var videosArray: [Video] {
        guard let videos = videos else { return [] }
        return videos.compactMap { $0 as? Video }.sorted { 
            ($0.title ?? "").localizedCompare($1.title ?? "") == .orderedAscending 
        }
    }
    
    var itemCount: Int {
        return (childFolders?.count ?? 0) + (videos?.count ?? 0)
    }
    
    var totalVideoCount: Int {
        let directVideos = videos?.count ?? 0
        let childVideos = childFolders?.reduce(into: 0) { result, folder in
            if let folder = folder as? Folder {
                result += folder.totalVideoCount
            }
        } ?? 0
        return directVideos + childVideos
    }
}

// MARK: - Subtitle Extensions
extension Subtitle {
    // Computed properties
    var fileURL: URL? {
        guard let video = video,
              let library = video.library,
              let libraryPath = library.url else { return nil }
        return libraryPath.appendingPathComponent("Subtitles").appendingPathComponent(relativePath!)
    }
    
    var displayName: String {
        if let languageName = languageName {
            return languageName
        } else if let language = language {
            return Locale.current.localizedString(forLanguageCode: language) ?? language
        }
        return fileName!
    }
}

// MARK: - Library Extensions
extension Library {
    // Computed properties
    var url: URL? {
        return URL(fileURLWithPath: libraryPath!)
    }
    
    var videoCount: Int {
        return videos?.count ?? 0
    }
    
    var totalSize: Int64 {
        return videos?.reduce(into: 0) { result, video in
            if let video = video as? Video {
                result += video.fileSize
            }
        } ?? 0
    }
    
    var formattedSize: String {
        let formatter = ByteCountFormatter()
        formatter.countStyle = .file
        return formatter.string(fromByteCount: totalSize)
    }
}

// MARK: - Content Types
enum ContentType: Hashable {
    case folder(Folder)
    case video(Video)
    
    var id: UUID {
        switch self {
        case .folder(let folder): return folder.id!
        case .video(let video): return video.id!
        }
    }
    
    var name: String {
        switch self {
        case .folder(let folder): return folder.name ?? ""
        case .video(let video): return video.title ?? ""
        }
    }
    
    var dateCreated: Date {
        switch self {
        case .folder(let folder): return folder.dateCreated ?? Date()
        case .video(let video): return video.dateAdded ?? Date()
        }
    }
    
    var isFolder: Bool {
        if case .folder = self { return true }
        return false
    }
}

// MARK: - Sorting
enum SortOption: String, CaseIterable {
    case nameAscending = "Name A-Z"
    case nameDescending = "Name Z-A"
    case dateCreatedNewest = "Newest First"
    case dateCreatedOldest = "Oldest First"
    case foldersFirst = "Folders First"
}

enum SubtitleFormat: String, CaseIterable {
    case srt = "srt"
    case vtt = "vtt"
    case ssa = "ssa"
    case ass = "ass"
    
    var displayName: String {
        switch self {
        case .srt: return "SubRip (.srt)"
        case .vtt: return "WebVTT (.vtt)"
        case .ssa, .ass: return "SubStation Alpha (.ssa/.ass)"
        }
    }
}

enum VideoFormat: String, CaseIterable {
    case mp4 = "mp4"
    case mov = "mov"
    case m4v = "m4v"
    case mkv = "mkv"
    case avi = "avi"
    case webm = "webm"
    
    static var supportedExtensions: [String] {
        return VideoFormat.allCases.map { $0.rawValue }
    }
}

// MARK: - Library Descriptor (for multiple libraries)
struct LibraryDescriptor: Codable, Identifiable {
    let id: UUID
    let name: String
    let path: URL
    let lastOpenedDate: Date
    let createdDate: Date
    let version: String
    let thumbnailData: Data?
    let videoCount: Int
    let totalSize: Int64
    
    var isAvailable: Bool {
        return FileManager.default.fileExists(atPath: path.path)
    }
    
    var formattedSize: String {
        let formatter = ByteCountFormatter()
        formatter.countStyle = .file
        return formatter.string(fromByteCount: totalSize)
    }
}



================================================================================

File: Models/HierarchicalContent.swift
//
//  HierarchicalContent.swift
//  Pangolin
//
//  Created by Claude on 19/08/2025.
//

import Foundation
import SwiftUI

// MARK: - Hierarchical Content Model for OutlineGroup/hierarchical List

/// Represents content items in a hierarchical structure for use with SwiftUI OutlineGroup
struct HierarchicalContentItem: Identifiable, Hashable {
    let id: UUID
    let name: String
    let contentType: ContentType
    var children: [HierarchicalContentItem]?
    
    /// Initialize from a folder (with potential children)
    init(folder: Folder) {
        self.id = folder.id!
        self.name = folder.name!
        self.contentType = .folder(folder)
        
        // Combine child folders and videos into hierarchical structure
        var childItems: [HierarchicalContentItem] = []
        
        // Add child folders (which can have their own children)
        for childFolder in folder.childFoldersArray {
            childItems.append(HierarchicalContentItem(folder: childFolder))
        }
        
        // Add videos (leaf nodes - no children)
        for video in folder.videosArray {
            childItems.append(HierarchicalContentItem(video: video))
        }
        
        // Set children to nil if empty (indicates leaf node for OutlineGroup)
        self.children = childItems.isEmpty ? nil : childItems
    }
    
    /// Initialize from a video (leaf node)
    init(video: Video) {
        self.id = video.id!
        self.name = video.title!
        self.contentType = .video(video)
        self.children = nil // Videos are always leaf nodes
    }
    
    /// Whether this item has children (for disclosure triangle display)
    var hasChildren: Bool {
        return children != nil
    }
    
    /// Whether this represents a folder
    var isFolder: Bool {
        if case .folder = contentType { return true }
        return false
    }
    
    /// Get the underlying folder (if this is a folder item)
    var folder: Folder? {
        if case .folder(let folder) = contentType { return folder }
        return nil
    }
    
    /// Get the underlying video (if this is a video item)
    var video: Video? {
        if case .video(let video) = contentType { return video }
        return nil
    }
}

// MARK: - Extensions for SwiftUI Integration

extension HierarchicalContentItem {
    /// Static keypath for children (required by hierarchical List)
    static let childrenKeyPath: WritableKeyPath<HierarchicalContentItem, [HierarchicalContentItem]?> = \.children
}

================================================================================

File: Extensions/View+Extensions.swift
//
//  View+Extensions.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//

// Extensions/View+Extensions.swift
import SwiftUI

extension View {
    func pangolinAlert<T: LocalizedError>(error: Binding<T?>) -> some View {
        self.alert(isPresented: .constant(error.wrappedValue != nil)) {
            Alert(
                title: Text("Error"),
                message: Text(error.wrappedValue?.errorDescription ?? "An unknown error occurred"),
                dismissButton: .default(Text("OK")) {
                    error.wrappedValue = nil
                }
            )
        }
    }
}


================================================================================

File: Extensions/URL+Extensions.swift
//
//  URL+Extensions.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//

// Extensions/URL+Extensions.swift

import Foundation

extension URL {
    var isVideo: Bool {
        let videoExtensions = VideoFormat.supportedExtensions
        return videoExtensions.contains(self.pathExtension.lowercased())
    }
    
    var isSubtitle: Bool {
        let subtitleExtensions = ["srt", "vtt", "ssa", "ass", "sub"]
        return subtitleExtensions.contains(self.pathExtension.lowercased())
    }
    
    var parentDirectory: URL {
        return self.deletingLastPathComponent()
    }
}


================================================================================

File: Utilities/PlatformUtilities.swift
//
//  PlatformUtilities.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//


// Utilities/PlatformUtilities.swift
import Foundation
#if os(macOS)
import AppKit
#else
import UIKit
#endif

struct PlatformUtilities {
    static var isRunningOnMac: Bool {
        #if os(macOS)
        return true
        #else
        return false
        #endif
    }
    
    static var deviceType: String {
        #if os(macOS)
        return "Mac"
        #elseif os(iOS)
        if UIDevice.current.userInterfaceIdiom == .pad {
            return "iPad"
        } else {
            return "iPhone"
        }
        #endif
    }
    
    static func openFilePanel(completion: @escaping (URL?) -> Void) {
        #if os(macOS)
        let panel = NSOpenPanel()
        panel.allowsMultipleSelection = false
        panel.canChooseDirectories = true
        panel.canChooseFiles = false
        panel.message = "Choose a location for your video library"
        
        panel.begin { response in
            if response == .OK {
                completion(panel.url)
            } else {
                completion(nil)
            }
        }
        #else
        // iOS would use document picker
        completion(nil)
        #endif
    }
    
    static func selectVideosForImport(completion: @escaping ([URL]) -> Void) {
        #if os(macOS)
        let panel = NSOpenPanel()
        panel.allowsMultipleSelection = true
        panel.canChooseDirectories = true
        panel.canChooseFiles = true
        panel.message = "Select videos or folders to import"
        panel.allowedContentTypes = [.movie, .video]
        
        panel.begin { response in
            if response == .OK {
                completion(panel.urls)
            } else {
                completion([])
            }
        }
        #else
        // iOS document picker implementation
        completion([])
        #endif
    }
}


================================================================================

File: Utilities/NotificationNames.swift
//
//  NotificationNames.swift
//  Pangolin
//
//  Created by Matt Kevan on 18/08/2025.
//

import Foundation

extension Notification.Name {
    /// Notification posted when the content of a folder or library has been updated (e.g., after an import).
    static let contentUpdated = Notification.Name("com.pangolin.contentUpdated")
}


================================================================================

File: Import/VideoImporter.swift
//
//  VideoImporter.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//


// Import/VideoImporter.swift
import Foundation
import Combine
import AVFoundation
import CoreData

class VideoImporter: ObservableObject {
    @Published var isImporting = false
    @Published var currentFile = ""
    @Published var progress: Double = 0
    @Published var totalFiles = 0
    @Published var processedFiles = 0
    @Published var errors: [ImportError] = []
    @Published var importedVideos: [Video] = []
    @Published var skippedFolders: [String] = []
    
    private let fileSystemManager = FileSystemManager.shared
    private let subtitleMatcher = SubtitleMatcher()
    private var cancellables = Set<AnyCancellable>()
    
    struct ImportError: Identifiable {
        let id = UUID()
        let fileName: String
        let error: Error
    }
    
    func importFiles(_ urls: [URL], to library: Library, context: NSManagedObjectContext) async {
        await MainActor.run {
            isImporting = true
            errors = []
            importedVideos = []
            progress = 0
        }
        
        // Analyze import structure to create folders
        let folderStructure = analyzeFolderStructure(from: urls)
        let createdFolders = await createFoldersFromStructure(folderStructure, library: library, context: context)
        
        // Gather all video files
        let videoFiles = gatherVideoFiles(from: urls)
        await MainActor.run {
            totalFiles = videoFiles.count
        }
        
        // Import each file  
        print("🎬 IMPORT: Starting import of \(videoFiles.count) video files")
        print("📚 IMPORT: Library settings - copyFilesOnImport: \(library.copyFilesOnImport), autoMatchSubtitles: \(library.autoMatchSubtitles)")
        for (index, fileURL) in videoFiles.enumerated() {
            await MainActor.run {
                currentFile = fileURL.lastPathComponent
                processedFiles = index
                progress = Double(index) / Double(videoFiles.count)
            }
            
            print("📹 IMPORT: Processing file \(index + 1)/\(videoFiles.count): \(fileURL.lastPathComponent)")
            
            do {
                // Import video
                let video = try await fileSystemManager.importVideo(
                    from: fileURL,
                    to: library,
                    context: context,
                    copyFile: library.copyFilesOnImport
                )
                print("✅ IMPORT: Successfully imported video: \(video.title ?? "Unknown")")
                
                // Add video to appropriate folder based on its original folder path
                assignVideoToFolder(video: video, originalPath: fileURL, createdFolders: createdFolders)
                
                // Find and import matching subtitles
                if library.autoMatchSubtitles {
                    let subtitles = subtitleMatcher.findMatchingSubtitles(
                        for: fileURL,
                        in: fileURL.deletingLastPathComponent()
                    )
                    print("📄 IMPORT: Found \(subtitles.count) subtitle files for \(fileURL.lastPathComponent)")
                    
                    for subtitleURL in subtitles {
                        do {
                            let subtitle = try await importSubtitle(
                                from: subtitleURL,
                                for: video,
                                to: library,
                                context: context
                            )
                            print("✅ IMPORT: Successfully imported subtitle: \(subtitle.fileName ?? "Unknown")")
                        } catch {
                            print("❌ IMPORT: Failed to import subtitle \(subtitleURL.lastPathComponent): \(error)")
                        }
                    }
                }
                
                await MainActor.run {
                    importedVideos.append(video)
                }
                
            } catch {
                print("❌ IMPORT: Failed to import video \(fileURL.lastPathComponent): \(error)")
                await MainActor.run {
                    errors.append(ImportError(
                        fileName: fileURL.lastPathComponent,
                        error: error
                    ))
                }
            }
        }
        
        // Save context
        do {
            try context.save()
        } catch {
            await MainActor.run {
                errors.append(ImportError(
                    fileName: "Core Data",
                    error: error
                ))
            }
        }
        
        await MainActor.run {
            isImporting = false
            progress = 1.0
            processedFiles = totalFiles
        }
    }
    
    func resetImportState() {
        errors.removeAll()
        importedVideos.removeAll()
        skippedFolders.removeAll()
        progress = 0
        totalFiles = 0
        processedFiles = 0
        currentFile = ""
    }
    
    private func gatherVideoFiles(from urls: [URL]) -> [URL] {
        var videoFiles: [URL] = []
        
        for url in urls {
            var isDirectory: ObjCBool = false
            if FileManager.default.fileExists(atPath: url.path, isDirectory: &isDirectory) {
                if isDirectory.boolValue {
                    print("📁 IMPORT: Gathering videos from directory: \(url.lastPathComponent)")
                    // Recursively find video files in directory
                    let foundFiles = findVideoFiles(in: url)
                    print("📹 IMPORT: Found \(foundFiles.count) video files in \(url.lastPathComponent)")
                    videoFiles.append(contentsOf: foundFiles)
                } else if isVideoFile(url) {
                    print("📹 IMPORT: Direct video file: \(url.lastPathComponent)")
                    videoFiles.append(url)
                }
            }
        }
        
        print("📊 IMPORT: Total video files gathered: \(videoFiles.count)")
        return videoFiles
    }
    
    private func findVideoFiles(in directory: URL) -> [URL] {
        var videoFiles: [URL] = []
        
        // Start accessing security-scoped resource
        let accessing = directory.startAccessingSecurityScopedResource()
        defer {
            if accessing {
                directory.stopAccessingSecurityScopedResource()
            }
        }
        
        do {
            let contents = try FileManager.default.contentsOfDirectory(
                at: directory,
                includingPropertiesForKeys: [.isDirectoryKey, .isRegularFileKey],
                options: [.skipsHiddenFiles]
            )
            
            for item in contents {
                var isDirectory: ObjCBool = false
                if FileManager.default.fileExists(atPath: item.path, isDirectory: &isDirectory) {
                    if isDirectory.boolValue {
                        // Recursively search subdirectories
                        videoFiles.append(contentsOf: findVideoFiles(in: item))
                    } else if isVideoFile(item) {
                        videoFiles.append(item)
                    }
                }
            }
        } catch {
            print("⚠️ IMPORT: Could not access directory \(directory.lastPathComponent): \(error)")
        }
        
        return videoFiles
    }
    
    private func isVideoFile(_ url: URL) -> Bool {
        let videoExtensions = VideoFormat.supportedExtensions
        return videoExtensions.contains(url.pathExtension.lowercased())
    }
    
    private func importSubtitle(from url: URL, for video: Video, to library: Library, context: NSManagedObjectContext) async throws -> Subtitle {
        guard let libraryURL = library.url else {
            throw FileSystemError.invalidLibraryPath
        }
        
        // Start accessing security-scoped resources for both source and destination
        let sourceAccessing = url.startAccessingSecurityScopedResource()
        let libraryAccessing = libraryURL.startAccessingSecurityScopedResource()
        defer {
            if sourceAccessing {
                url.stopAccessingSecurityScopedResource()
            }
            if libraryAccessing {
                libraryURL.stopAccessingSecurityScopedResource()
            }
        }
        
        // Create subtitle directory
        let videoDir = URL(fileURLWithPath: video.relativePath!).deletingLastPathComponent().path
        let subtitlesDir = libraryURL.appendingPathComponent("Subtitles")
            .appendingPathComponent(videoDir)
        
        try FileManager.default.createDirectory(
            at: subtitlesDir,
            withIntermediateDirectories: true
        )
        
        // Copy subtitle file
        let destinationURL = subtitlesDir.appendingPathComponent(url.lastPathComponent)
        try FileManager.default.copyItem(at: url, to: destinationURL)
        
        // Create subtitle entity in Core Data context using entity description
        guard let subtitleEntityDescription = context.persistentStoreCoordinator?.managedObjectModel.entitiesByName["Subtitle"] else {
            throw FileSystemError.importFailed("Could not find Subtitle entity description")
        }
        
        let subtitle = Subtitle(entity: subtitleEntityDescription, insertInto: context)
        subtitle.id = UUID()
        subtitle.fileName = url.lastPathComponent
        subtitle.relativePath = destinationURL.path
            .replacingOccurrences(of: libraryURL.path + "/Subtitles/", with: "")
        subtitle.format = url.pathExtension
        subtitle.encoding = "UTF-8"
        subtitle.isDefault = false
        subtitle.isForced = false
        subtitle.video = video
        
        // Detect language from filename
        let languageInfo = subtitleMatcher.detectLanguage(from: url.lastPathComponent)
        subtitle.language = languageInfo.code
        subtitle.languageName = languageInfo.name
        
        return subtitle
    }
    
    // MARK: - Folder Structure Analysis
    
    struct FolderNode {
        let url: URL
        let name: String
        var children: [FolderNode] = []
        var videoFiles: [URL] = []
        let isRoot: Bool
        
        init(url: URL, name: String, isRoot: Bool = false) {
            self.url = url
            self.name = name
            self.isRoot = isRoot
        }
    }
    
    private func analyzeFolderStructure(from urls: [URL]) -> [FolderNode] {
        var rootNodes: [FolderNode] = []
        
        for url in urls {
            var isDirectory: ObjCBool = false
            if FileManager.default.fileExists(atPath: url.path, isDirectory: &isDirectory) {
                if isDirectory.boolValue {
                    // This is a folder import
                    let folderNode = buildFolderTree(from: url)
                    rootNodes.append(folderNode)
                } else if isVideoFile(url) {
                    // Individual file import
                    continue
                }
            }
        }
        
        return rootNodes
    }
    
    private func buildFolderTree(from folderURL: URL) -> FolderNode {
        let folderName = folderURL.lastPathComponent
        var node = FolderNode(url: folderURL, name: folderName, isRoot: true)
        
        // Start accessing security-scoped resource
        let accessing = folderURL.startAccessingSecurityScopedResource()
        defer {
            if accessing {
                folderURL.stopAccessingSecurityScopedResource()
            }
        }
        
        do {
            let contents = try FileManager.default.contentsOfDirectory(
                at: folderURL,
                includingPropertiesForKeys: [.isDirectoryKey, .isRegularFileKey],
                options: [.skipsHiddenFiles]
            )
            
            for item in contents {
                var isDirectory: ObjCBool = false
                if FileManager.default.fileExists(atPath: item.path, isDirectory: &isDirectory) {
                    if isDirectory.boolValue {
                        // Subfolder - recursively build tree with security scope
                        let childAccessing = item.startAccessingSecurityScopedResource()
                        let childNode = buildFolderTree(from: item)
                        if childAccessing {
                            item.stopAccessingSecurityScopedResource()
                        }
                        if !childNode.videoFiles.isEmpty || !childNode.children.isEmpty {
                            node.children.append(childNode)
                        }
                    } else if isVideoFile(item) {
                        // Video file
                        node.videoFiles.append(item)
                    }
                }
            }
        } catch {
            let nsError = error as NSError
            if nsError.domain == NSCocoaErrorDomain && nsError.code == 257 {
                print("⚠️ IMPORT: Permission denied for folder '\(folderName)' - may need individual selection")
                Task { @MainActor in
                    skippedFolders.append(folderName)
                }
            } else {
                print("⚠️ IMPORT: Error reading folder '\(folderName)': \(error)")
            }
        }
        
        return node
    }
    
    private func createFoldersFromStructure(_ folderNodes: [FolderNode], library: Library, context: NSManagedObjectContext) async -> [String: Folder] {
        var createdFolders: [String: Folder] = [:]
        
        for folderNode in folderNodes {
            if let folder = await createFolderFromNode(folderNode, parent: nil, library: library, context: context) {
                createdFolders[folderNode.url.path] = folder
                await addChildFolders(for: folderNode, parentFolder: folder, library: library, context: context, createdFolders: &createdFolders)
            }
        }
        
        return createdFolders
    }
    
    private func createFolderFromNode(_ node: FolderNode, parent: Folder?, library: Library, context: NSManagedObjectContext) async -> Folder? {
        // Only create folder if there are videos in this folder or subfolders
        guard !node.videoFiles.isEmpty || !node.children.isEmpty else { 
            return nil 
        }
        
        guard let folderEntityDescription = context.persistentStoreCoordinator?.managedObjectModel.entitiesByName["Folder"] else {
            print("Could not find Folder entity description")
            return nil
        }
        
        let folder = Folder(entity: folderEntityDescription, insertInto: context)
        folder.id = UUID()
        folder.name = node.name
        folder.dateCreated = Date()
        folder.dateModified = Date()
        folder.library = library
        folder.parentFolder = parent
        folder.isTopLevel = (parent == nil)
        
        return folder
    }
    
    private func addChildFolders(for node: FolderNode, parentFolder: Folder, library: Library, context: NSManagedObjectContext, createdFolders: inout [String: Folder]) async {
        for childNode in node.children {
            if let childFolder = await createFolderFromNode(childNode, parent: parentFolder, library: library, context: context) {
                createdFolders[childNode.url.path] = childFolder
                await addChildFolders(for: childNode, parentFolder: childFolder, library: library, context: context, createdFolders: &createdFolders)
            }
        }
    }
    
    private func assignVideoToFolder(video: Video, originalPath: URL, createdFolders: [String: Folder]) {
        // Find the folder that corresponds to the video's original folder
        let videoDirectory = originalPath.deletingLastPathComponent()
        
        // Look for a folder that matches this directory or any parent directory
        for (folderPath, folder) in createdFolders {
            let folderURL = URL(fileURLWithPath: folderPath)
            
            // Check if the video's directory is the same as or a subdirectory of the folder's directory
            if videoDirectory.path.hasPrefix(folderURL.path) {
                // Assign video to this folder
                video.folder = folder
                break
            }
        }
    }
}

================================================================================

File: Import/VideoDropDelegate.swift
//
//  VideoDropDelegate.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//


// Import/DragDropHandler.swift
import SwiftUI
import UniformTypeIdentifiers

struct VideoDropDelegate: DropDelegate {
    @Binding var isTargeted: Bool
    let library: Library
    let importer: VideoImporter
    @EnvironmentObject var libraryManager: LibraryManager
    
    func validateDrop(info: DropInfo) -> Bool {
        return info.hasItemsConforming(to: [.fileURL])
    }
    
    func dropEntered(info: DropInfo) {
        isTargeted = true
    }
    
    func dropExited(info: DropInfo) {
        isTargeted = false
    }
    
    func performDrop(info: DropInfo) -> Bool {
        isTargeted = false
        
        let providers = info.itemProviders(for: [.fileURL])
        var urls: [URL] = []
        
        let group = DispatchGroup()
        
        for provider in providers {
            group.enter()
            provider.loadItem(forTypeIdentifier: UTType.fileURL.identifier, options: nil) { item, error in
                if let data = item as? Data,
                   let url = URL(dataRepresentation: data, relativeTo: nil) {
                    urls.append(url)
                }
                group.leave()
            }
        }
        
        group.notify(queue: .main) {
            Task {
                if let context = libraryManager.viewContext {
                    await importer.importFiles(urls, to: library, context: context)
                }
            }
        }
        
        return true
    }
}

================================================================================

File: Import/SubtitleMatcher.swift
//
//  SubtitleMatcher.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//


// Import/SubtitleMatcher.swift
import Foundation

class SubtitleMatcher {
    private let languagePatterns: [(pattern: String, code: String, name: String)] = [
        (".en.", "en", "English"),
        (".eng.", "en", "English"),
        ("_en.", "en", "English"),
        ("_eng.", "en", "English"),
        ("[English]", "en", "English"),
        (".fr.", "fr", "French"),
        (".fra.", "fr", "French"),
        ("_fr.", "fr", "French"),
        ("[French]", "fr", "French"),
        (".es.", "es", "Spanish"),
        (".spa.", "es", "Spanish"),
        ("_es.", "es", "Spanish"),
        ("[Spanish]", "es", "Spanish"),
        (".de.", "de", "German"),
        (".deu.", "de", "German"),
        ("_de.", "de", "German"),
        ("[German]", "de", "German"),
        (".it.", "it", "Italian"),
        (".ita.", "it", "Italian"),
        ("_it.", "it", "Italian"),
        ("[Italian]", "it", "Italian"),
        (".ja.", "ja", "Japanese"),
        (".jpn.", "ja", "Japanese"),
        ("_ja.", "ja", "Japanese"),
        ("[Japanese]", "ja", "Japanese"),
        (".zh.", "zh", "Chinese"),
        (".chi.", "zh", "Chinese"),
        ("_zh.", "zh", "Chinese"),
        ("[Chinese]", "zh", "Chinese"),
    ]
    
    func findMatchingSubtitles(for videoURL: URL, in directory: URL) -> [URL] {
        let videoName = videoURL.deletingPathExtension().lastPathComponent
        var subtitles: [URL] = []
        
        do {
            let files = try FileManager.default.contentsOfDirectory(
                at: directory,
                includingPropertiesForKeys: nil
            )
            
            for file in files {
                if isSubtitleFile(file) {
                    let subtitleName = file.deletingPathExtension().lastPathComponent
                    
                    // Check various matching patterns
                    if matchesVideo(subtitleName: subtitleName, videoName: videoName) {
                        subtitles.append(file)
                    }
                }
            }
        } catch {
            print("Error finding subtitles: \(error)")
        }
        
        return subtitles
    }
    
    func detectLanguage(from filename: String) -> (code: String?, name: String?) {
        let lowercased = filename.lowercased()
        
        for (pattern, code, name) in languagePatterns {
            if lowercased.contains(pattern.lowercased()) {
                return (code, name)
            }
        }
        
        // Try to extract ISO 639-1 codes (2 letters)
        let components = filename.components(separatedBy: CharacterSet(charactersIn: "._-[]"))
        for component in components {
            if component.count == 2 {
                if let languageName = Locale.current.localizedString(forLanguageCode: component) {
                    return (component, languageName)
                }
            }
        }
        
        return (nil, nil)
    }
    
    private func isSubtitleFile(_ url: URL) -> Bool {
        let subtitleExtensions = ["srt", "vtt", "ssa", "ass", "sub"]
        return subtitleExtensions.contains(url.pathExtension.lowercased())
    }
    
    private func matchesVideo(subtitleName: String, videoName: String) -> Bool {
        // Exact match
        if subtitleName == videoName {
            return true
        }
        
        // Prefix match (allows for language codes)
        if subtitleName.hasPrefix(videoName) {
            return true
        }
        
        // Fuzzy matching with similarity threshold
        let similarity = calculateSimilarity(subtitleName, videoName)
        if similarity > 0.8 {
            return true
        }
        
        return false
    }
    
    private func calculateSimilarity(_ str1: String, _ str2: String) -> Double {
        // Simple Jaccard similarity
        let set1 = Set(str1.lowercased())
        let set2 = Set(str2.lowercased())
        
        let intersection = set1.intersection(set2).count
        let union = set1.union(set2).count
        
        return union > 0 ? Double(intersection) / Double(union) : 0
    }
}

================================================================================

File: Views/DetailView.swift
//
//  DetailView.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//


import SwiftUI
import AVKit

struct DetailView: View {
    let video: Video?
    @StateObject private var playerViewModel = VideoPlayerViewModel()
    
    // CORRECTED: Use platform-specific color APIs.
    private var controlsBackgroundColor: Color {
        #if os(macOS)
        return Color(NSColor.controlBackgroundColor)
        #else
        return Color(.systemBackground)
        #endif
    }
    
    private var windowBackgroundColor: Color {
        #if os(macOS)
        return Color(NSColor.windowBackgroundColor)
        #else
        return Color(.secondarySystemBackground)
        #endif
    }
    
    var body: some View {
        GeometryReader { geometry in
            if let video = video {
                VStack(spacing: 0) {
                    // Video Player with Poster Frame
                    VideoPlayerWithPosterView(video: video, viewModel: playerViewModel)
                        .frame(height: geometry.size.height * 0.67)
                    
                    // Controls Bar
                    VideoControlsBar(viewModel: playerViewModel)
                        .frame(height: 60)
                        .background(controlsBackgroundColor)
                    
                    // Bottom area with tabs
                    VideoDetailTabView(video: video)
                        .frame(maxHeight: .infinity)
                        .background(windowBackgroundColor)
                }
            } else {
                ContentUnavailableView(
                    "Select a Video",
                    systemImage: "play.rectangle",
                    description: Text("Choose a video from the list to start watching")
                )
            }
        }
    }
}


================================================================================

File: Views/VideoPlayerView.swift
// Views/VideoPlayerView.swift
import SwiftUI
import AVKit

#if os(macOS)
struct VideoPlayerView: NSViewRepresentable {
    @ObservedObject var viewModel: VideoPlayerViewModel
    
    func makeNSView(context: Context) -> AVPlayerView {
        let playerView = AVPlayerView()
        playerView.player = viewModel.player
        playerView.controlsStyle = .none // We'll use custom controls
        playerView.showsFullScreenToggleButton = true
        return playerView
    }
    
    func updateNSView(_ nsView: AVPlayerView, context: Context) {
        nsView.player = viewModel.player
    }
}
#elseif os(iOS)
struct VideoPlayerView: UIViewRepresentable {
    @ObservedObject var viewModel: VideoPlayerViewModel
    
    func makeUIView(context: Context) -> UIView {
        // We need to wrap the AVPlayerViewController to use its view
        let controller = AVPlayerViewController()
        controller.player = viewModel.player
        controller.showsPlaybackControls = false // Custom controls
        
        // This makes sure the view from the controller is returned
        return controller.view
    }
    
    func updateUIView(_ uiView: UIView, context: Context) {
        // This is tricky because we don't have direct access to the controller.
        // For simple player updates, swapping the player on the viewModel should be sufficient.
        // More complex updates might require a Coordinator.
    }
}
#endif


================================================================================

File: Views/SidebarView.swift
//
//  SidebarView.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//

import SwiftUI
import CoreData

struct SidebarView: View {
    @EnvironmentObject private var store: FolderNavigationStore
    @Environment(\.managedObjectContext) private var viewContext
    
    @State private var isShowingCreateFolder = false
    @State private var editingFolder: Folder?
    @State private var renamingFolderID: UUID? = nil
    @FocusState private var focusedField: UUID?
    @State private var showingDeletionConfirmation = false
    @State private var folderToDelete: Folder?
    
    // Use @FetchRequest for automatic Core Data change observation
    @FetchRequest(
        sortDescriptors: [NSSortDescriptor(keyPath: \Folder.name, ascending: true)],
        predicate: NSPredicate(format: "isTopLevel == YES AND isSmartFolder == YES")
    ) private var allSystemFolders: FetchedResults<Folder>
    
    @FetchRequest(
        sortDescriptors: [NSSortDescriptor(keyPath: \Folder.name, ascending: true)],
        predicate: NSPredicate(format: "isTopLevel == YES AND isSmartFolder == NO")
    ) private var allUserFolders: FetchedResults<Folder>
    
    // Filter by current library - these will update automatically when @FetchRequest data changes
    private var systemFolders: [Folder] {
        // Use the store's systemFolders method to get the current library filtering
        // This will trigger when @FetchRequest data changes due to the allSystemFolders dependency
        let _ = allSystemFolders // Create dependency on @FetchRequest
        return store.systemFolders()
    }
    
    private var userFolders: [Folder] {
        // Use the store's userFolders method to get the current library filtering
        // This will trigger when @FetchRequest data changes due to the allUserFolders dependency
        let _ = allUserFolders // Create dependency on @FetchRequest
        return store.userFolders()
    }
    
    var body: some View {
        List(selection: $store.selectedTopLevelFolder) {
            // System folders (smart folders)
            Section("Pangolin") {
                ForEach(systemFolders) { folder in
                    FolderRowView(
                        folder: folder,
                        showContextMenu: false,
                        editingFolder: $editingFolder,
                        renamingFolderID: $renamingFolderID,
                        focusedField: $focusedField,
                        onDelete: {}
                    )
                    .tag(folder)
                }
            }
            
            // User folders
            Section("Library") {
                ForEach(userFolders) { folder in
                    FolderRowView(
                        folder: folder,
                        showContextMenu: true,
                        editingFolder: $editingFolder,
                        renamingFolderID: $renamingFolderID,
                        focusedField: $focusedField,
                        onDelete: { deleteFolder(folder) }
                    )
                    .tag(folder)
                }
            }
        }
        .onChange(of: store.selectedTopLevelFolder) { _, newFolder in
            // Defer the state update to avoid "Publishing changes from within view updates" error
            Task { @MainActor in
                if let newFolder {
                    store.currentFolderID = newFolder.id
                }
            }
        }
        #if os(macOS)
        .listStyle(SidebarListStyle())
        #else
        .listStyle(InsetGroupedListStyle())
        #endif
        .toolbar {
            ToolbarItem(placement: .automatic) {
                Button(action: { isShowingCreateFolder = true }) {
                    Label("Add Folder", systemImage: "plus")
                }
            }
        }
        .sheet(isPresented: $isShowingCreateFolder) {
            CreateFolderView(parentFolderID: nil)
        }
        .sheet(isPresented: $showingDeletionConfirmation) {
            if let folder = folderToDelete {
                DeletionConfirmationView(
                    items: [DeletionItem(folder: folder)],
                    onConfirm: {
                        Task {
                            await confirmDeletion()
                        }
                    },
                    onCancel: {
                        cancelDeletion()
                    }
                )
            }
        }
        .onKeyPress { keyPress in
            if keyPress.key == .return,
               let selected = store.selectedTopLevelFolder,
               !selected.isSmartFolder { // Only allow renaming for user folders
                renamingFolderID = selected.id
                Task { @MainActor in
                    try? await Task.sleep(nanoseconds: 100_000_000) // 0.1s delay
                    focusedField = selected.id
                }
                return .handled
            } else if (keyPress.key == .delete || keyPress.key == .deleteForward),
                      let selected = store.selectedTopLevelFolder,
                      !selected.isSmartFolder { // Only allow deletion for user folders
                deleteFolder(selected)
                return .handled
            }
            return .ignored
        }
    }
    
    private func deleteFolder(_ folder: Folder) {
        folderToDelete = folder
        showingDeletionConfirmation = true
    }
    
    private func confirmDeletion() async {
        guard let folder = folderToDelete else { return }
        
        let success = await store.deleteItems([folder.id!])
        
        await MainActor.run {
            if success {
                // Clear selection if the deleted folder was selected
                if store.selectedTopLevelFolder?.id == folder.id {
                    // Select "All Videos" folder as fallback
                    let systemFolders = store.systemFolders()
                    if let allVideosFolder = systemFolders.first(where: { $0.name == "All Videos" }) {
                        store.selectedTopLevelFolder = allVideosFolder
                        store.currentFolderID = allVideosFolder.id
                    }
                }
            }
            
            cancelDeletion()
        }
    }
    
    private func cancelDeletion() {
        folderToDelete = nil
        showingDeletionConfirmation = false
    }
}

// MARK: - Folder Row View
private struct FolderRowView: View {
    @EnvironmentObject private var store: FolderNavigationStore
    let folder: Folder
    let showContextMenu: Bool
    @Binding var editingFolder: Folder?
    @Binding var renamingFolderID: UUID?
    @FocusState.Binding var focusedField: UUID?
    let onDelete: () -> Void
    
    @State private var isDropTargeted = false
    @State private var editedName: String = ""
    @State private var shouldCommitOnDisappear = false

    var body: some View {
        Label {
            nameEditorView
        } icon: {
            Image(systemName: folder.isSmartFolder ? getSmartFolderIcon(folder.name!) : "folder")
                .foregroundColor(folder.isSmartFolder ? .blue : .orange)
        }
        .onTapGesture {
            handleSlowClickRename()
        }
        .contextMenu {
            if showContextMenu {
                Button("Rename") {
                    renamingFolderID = folder.id
                    Task { @MainActor in
                        try? await Task.sleep(nanoseconds: 100_000_000) // 0.1s delay
                        focusedField = folder.id
                    }
                }
                Button("Delete", role: .destructive) {
                    onDelete()
                }
            }
        }
        .onDrop(of: [.data], isTargeted: $isDropTargeted) { providers in
            guard !folder.isSmartFolder else { return false }
            
            if let provider = providers.first {
                let _ = provider.loadDataRepresentation(for: .data) { data, _ in
                    if let data = data,
                       let transfer = try? JSONDecoder().decode(ContentTransfer.self, from: data) {
                        Task { @MainActor in
                            await store.moveItems(Set(transfer.itemIDs), to: folder.id)
                        }
                    }
                }
                return true
            }
            return false
        }
        .overlay {
            // Provide visual feedback when a drop is targeted
            if isDropTargeted && !folder.isSmartFolder {
                RoundedRectangle(cornerRadius: 6)
                    .stroke(Color.accentColor, lineWidth: 2)
                    #if os(macOS)
                    .padding(-4)
                    #endif
            }
        }
    }
    
    /// A view that conditionally shows a `Text` label or a `TextField` for renaming.
    @ViewBuilder
    private var nameEditorView: some View {
        if renamingFolderID == folder.id {
            TextField("Name", text: $editedName)
                .textFieldStyle(.plain)
                .focused($focusedField, equals: folder.id)
                .onAppear {
                    editedName = folder.name!
                    shouldCommitOnDisappear = true
                }
                .onSubmit {
                    shouldCommitOnDisappear = false
                    // ✅ Call async function from a Task
                    Task { await commitRename() }
                }
                .onKeyPress { keyPress in
                    if keyPress.key == .escape {
                        shouldCommitOnDisappear = false
                        cancelRename()
                        return .handled
                    }
                    return .ignored
                }
                .onChange(of: focusedField) { oldValue, newValue in
                    if oldValue == folder.id && newValue != folder.id && shouldCommitOnDisappear {
                        // ✅ Call async function from a Task
                        Task { await commitRename() }
                    }
                }
        } else {
            Text(folder.name!)
        }
    }
    
    /// Commits the new name to the data store.
    // ✅ Make the function async
    private func commitRename() async {
        shouldCommitOnDisappear = false
        
        let trimmedName = editedName.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmedName.isEmpty && trimmedName != folder.name! else {
            // Cancel if no change
            await MainActor.run { cancelRename() }
            return
        }
        
        // ✅ Await the store operation before updating local state
        await store.renameItem(id: folder.id!, to: trimmedName)
        
        // ✅ Now update local state after the save is complete
        await MainActor.run {
            renamingFolderID = nil
            focusedField = nil
        }
    }

    /// Cancels the renaming process.
    private func cancelRename() {
        editedName = folder.name!
        shouldCommitOnDisappear = false
        renamingFolderID = nil
        focusedField = nil
    }
    
    /// Handles slow-click rename for user folders only
    private func handleSlowClickRename() {
        guard !folder.isSmartFolder,
              showContextMenu,
              store.selectedTopLevelFolder?.id == folder.id,
              renamingFolderID == nil else {
            return
        }
        
        editedName = folder.name!
        renamingFolderID = folder.id
        Task { @MainActor in
            try? await Task.sleep(nanoseconds: 100_000_000)
            focusedField = folder.id
        }
    }
    
    private func getSmartFolderIcon(_ name: String) -> String {
        switch name {
        case "All Videos": return "video.fill"
        case "Recent": return "clock.fill"
        case "Favorites": return "heart.fill"
        default: return "folder"
        }
    }
}

================================================================================

File: Views/ImportProgressView.swift
//
//  ImportProgressView.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//


// Views/ImportProgressView.swift
import SwiftUI

struct ImportProgressView: View {
    @ObservedObject var importer: VideoImporter
    @Environment(\.dismiss) var dismiss
    
    var body: some View {
        VStack(spacing: 20) {
            Text("Importing Videos")
                .font(.headline)
            
            if importer.totalFiles > 0 {
                Text("\(importer.processedFiles) of \(importer.totalFiles) files")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
            
            if !importer.currentFile.isEmpty {
                Text(importer.currentFile)
                    .font(.caption)
                    .lineLimit(1)
                    .truncationMode(.middle)
            }
            
            ProgressView(value: importer.progress)
                .progressViewStyle(.linear)
                .frame(width: 300)
            
            if !importer.errors.isEmpty || !importer.skippedFolders.isEmpty {
                VStack(alignment: .leading, spacing: 8) {
                    if !importer.errors.isEmpty {
                        VStack(alignment: .leading) {
                            Text("Errors:")
                                .font(.caption)
                                .fontWeight(.semibold)
                            
                            ScrollView {
                                VStack(alignment: .leading) {
                                    ForEach(importer.errors) { error in
                                        Text("• \(error.fileName): \(error.error.localizedDescription)")
                                            .font(.caption)
                                            .foregroundColor(.red)
                                    }
                                }
                            }
                            .frame(maxHeight: 80)
                        }
                    }
                    
                    if !importer.skippedFolders.isEmpty {
                        VStack(alignment: .leading) {
                            Text("Skipped folders (permission denied):")
                                .font(.caption)
                                .fontWeight(.semibold)
                            
                            ScrollView {
                                VStack(alignment: .leading) {
                                    ForEach(importer.skippedFolders, id: \.self) { folder in
                                        Text("• \(folder)")
                                            .font(.caption)
                                            .foregroundColor(.orange)
                                    }
                                }
                            }
                            .frame(maxHeight: 80)
                            
                            VStack(alignment: .leading, spacing: 4) {
                                Text("💡 To access these folders:")
                                    .font(.caption2)
                                    .fontWeight(.medium)
                                
                                Text("1. Use 'Import Videos' again")
                                Text("2. Navigate to and select the specific folder")
                                Text("3. This grants the app permission to access it")
                            }
                            .font(.caption2)
                            .foregroundColor(.secondary)
                        }
                    }
                }
            }
            
            if !importer.isImporting {
                HStack {
                    if !importer.errors.isEmpty {
                        Text("\(importer.importedVideos.count) videos imported successfully")
                            .font(.caption)
                            .foregroundColor(.green)
                    }
                    
                    Spacer()
                    
                    Button("Done") {
                        dismiss()
                    }
                    .keyboardShortcut(.defaultAction)
                }
            }
        }
        .padding()
        .frame(width: 400)
        .frame(minHeight: 200)
    }
}

================================================================================

File: Views/HierarchicalContentView.swift
//
//  HierarchicalContentView.swift  
//  Pangolin
//
//  Created by Claude on 19/08/2025.
//

import SwiftUI
import CoreData

/// A Finder-like hierarchical content view using SwiftUI's native OutlineGroup/hierarchical List
struct HierarchicalContentView: View {
    @EnvironmentObject private var store: FolderNavigationStore
    @EnvironmentObject var libraryManager: LibraryManager
    let searchText: String
    
    @State private var selectedItems: Set<UUID> = []
    @State private var showingImportPicker = false
    @State private var showingImportProgress = false
    @State private var showingCreateFolder = false
    @State private var isGeneratingThumbnails = false
    @StateObject private var videoImporter = VideoImporter()
    @State private var showingDeletionConfirmation = false
    @State private var itemsToDelete: [DeletionItem] = []
    
    // Renaming state
    @State private var renamingItemID: UUID? = nil
    @FocusState private var focusedField: UUID?
    @State private var editedName: String = ""
    
    // This new property filters the store's reactive data source
    private var filteredContent: [HierarchicalContentItem] {
        let sourceContent = store.hierarchicalContent
        
        if searchText.isEmpty {
            return sourceContent
        } else {
            // Filter hierarchical content by search text
            return filterHierarchicalContent(sourceContent, searchText: searchText)
        }
    }
    
    var body: some View {
        contentView
        .toolbar {
            toolbarContent
        }
        .fileImporter(isPresented: $showingImportPicker, allowedContentTypes: [.movie, .video, .folder], allowsMultipleSelection: true) { result in
            switch result {
            case .success(let urls):
                if let library = libraryManager.currentLibrary, let context = libraryManager.viewContext {
                    videoImporter.resetImportState()
                    showingImportProgress = true
                    Task {
                        await videoImporter.importFiles(urls, to: library, context: context)
                    }
                }
            case .failure(let error):
                print("Error importing files: \(error)")
            }
        }
        .sheet(isPresented: $showingImportProgress) {
            ImportProgressView(importer: videoImporter)
        }
        .sheet(isPresented: $showingCreateFolder) {
            CreateFolderView(parentFolderID: store.currentFolderID)
        }
        .sheet(isPresented: $showingDeletionConfirmation) {
            DeletionConfirmationView(
                items: itemsToDelete,
                onConfirm: {
                    Task {
                        await confirmDeletion()
                    }
                },
                onCancel: {
                    cancelDeletion()
                }
            )
        }
        .onKeyPress { keyPress in
            // Return key triggers rename on single selected item
            if keyPress.key == .return, selectedItems.count == 1,
               let selectedID = selectedItems.first,
               let selectedItem = findItem(withID: selectedID, in: filteredContent),
               renamingItemID == nil {
                startRenaming(selectedItem)
                return .handled
            }
            // Delete key triggers deletion of selected items
            else if (keyPress.key == .delete || keyPress.key == .deleteForward), !selectedItems.isEmpty {
                deleteSelectedItems()
                return .handled
            }
            
            return .ignored
        }
    }
    
    @ViewBuilder
    private var contentView: some View {
        VStack(spacing: 0) {
            FolderNavigationHeader {
                showingCreateFolder = true
            }
            
            if filteredContent.isEmpty {
                ContentUnavailableView(
                    "No Content", 
                    systemImage: "folder.badge.questionmark", 
                    description: Text(store.currentFolderID == nil ? "Import videos to get started" : "This folder is empty")
                )
            } else {
                hierarchicalListView
            }
        }
    }
    
    @ViewBuilder 
    private var hierarchicalListView: some View {
        List(filteredContent, id: \.id, children: \.children, selection: $selectedItems) { item in
            HierarchicalContentRowView(
                item: item,
                renamingItemID: $renamingItemID,
                focusedField: $focusedField,
                editedName: $editedName,
                selectedItems: $selectedItems
            )
            .contentShape(Rectangle()) // Ensure full row is clickable
        }
        .onChange(of: selectedItems) { _, newSelection in
            handleSelectionChange(newSelection)
        }
    }
    
    @ToolbarContentBuilder
    private var toolbarContent: some ToolbarContent {
        #if os(macOS)
        ToolbarItemGroup {
            macOSToolbarButtons
        }
        
        // Show selection count when items are selected
        ToolbarItem(placement: .status) {
            if !selectedItems.isEmpty {
                Text("\(selectedItems.count) selected")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
        #else
        ToolbarItemGroup(placement: .navigationBarTrailing) {
            iOSMenu
        }
        #endif
    }
    
    @ViewBuilder
    private var macOSToolbarButtons: some View {
        Button("Import Videos") { showingImportPicker = true }
            .disabled(libraryManager.currentLibrary == nil)
        
        if !videosWithoutThumbnails.isEmpty {
            Button(isGeneratingThumbnails ? "Generating..." : "Generate Thumbnails") {
                generateThumbnailsForVideos()
            }
            .disabled(isGeneratingThumbnails)
        }
        
        Menu {
            ForEach(SortOption.allCases, id: \.self) { option in
                Button(option.rawValue) { store.currentSortOption = option }
            }
        } label: {
            Label("Sort", systemImage: "arrow.up.arrow.down")
        }
    }
    
    @ViewBuilder
    private var iOSMenu: some View {
        Menu {
            Button { showingImportPicker = true } label: { 
                Label("Import Videos", systemImage: "square.and.arrow.down") 
            }
            .disabled(libraryManager.currentLibrary == nil)
        } label: {
            Image(systemName: "ellipsis.circle")
        }
    }
    
    // MARK: - Helper Functions
    
    private var videosWithoutThumbnails: [Video] {
        return getAllVideos(from: store.hierarchicalContent).filter { $0.thumbnailPath == nil }
    }
    
    private func getAllVideos(from items: [HierarchicalContentItem]) -> [Video] {
        var videos: [Video] = []
        for item in items {
            if let video = item.video {
                videos.append(video)
            }
            if let children = item.children {
                videos.append(contentsOf: getAllVideos(from: children))
            }
        }
        return videos
    }
    
    private func findItem(withID id: UUID, in items: [HierarchicalContentItem]) -> HierarchicalContentItem? {
        for item in items {
            if item.id == id {
                return item
            }
            if let children = item.children,
               let found = findItem(withID: id, in: children) {
                return found
            }
        }
        return nil
    }
    
    private func filterHierarchicalContent(_ items: [HierarchicalContentItem], searchText: String) -> [HierarchicalContentItem] {
        return items.compactMap { item in
            let nameMatches = item.name.localizedCaseInsensitiveContains(searchText)
            
            // Recursively filter children
            let filteredChildren = item.children.flatMap { filterHierarchicalContent($0, searchText: searchText) }
            
            // An item should be included if its name matches OR if it has children that match
            if nameMatches || (filteredChildren?.isEmpty == false) {
                var filteredItem = item
                // Assign the filtered children back to the item
                filteredItem.children = filteredChildren
                return filteredItem
            }
            
            return nil
        }
    }
    
    private func handleSelectionChange(_ newSelection: Set<UUID>) {
        // Defer the state update to avoid "Publishing changes from within view updates" error
        Task { @MainActor in
            // When a single video is selected, set it for detail view
            if newSelection.count == 1, let selectedID = newSelection.first {
                if let selectedItem = findItem(withID: selectedID, in: filteredContent),
                   let video = selectedItem.video {
                    store.selectVideo(video)
                }
            } else {
                store.selectedVideo = nil
            }
        }
    }
    
    private func startRenaming(_ item: HierarchicalContentItem) {
        editedName = item.name
        renamingItemID = item.id
        Task { @MainActor in
            try? await Task.sleep(nanoseconds: 100_000_000) // 0.1s delay
            focusedField = item.id
        }
    }
    
    private func generateThumbnailsForVideos() {
        guard let library = libraryManager.currentLibrary, let context = libraryManager.viewContext else { return }
        isGeneratingThumbnails = true
        Task {
            await FileSystemManager.shared.generateMissingThumbnails(for: library, context: context)
            await MainActor.run {
                isGeneratingThumbnails = false
            }
        }
    }
    
    // MARK: - Deletion Methods
    
    private func deleteSelectedItems() {
        guard let context = libraryManager.viewContext else { return }
        
        var deletionItems: [DeletionItem] = []
        
        for itemID in selectedItems {
            if let item = findItem(withID: itemID, in: filteredContent) {
                switch item.contentType {
                case .folder(let folder):
                    deletionItems.append(DeletionItem(folder: folder))
                case .video(let video):
                    deletionItems.append(DeletionItem(video: video))
                }
            }
        }
        
        // Check if any system folders are selected
        let hasSystemFolder = deletionItems.contains { item in
            if item.isFolder {
                // Find the folder in Core Data and check if it's a system folder
                let request = Folder.fetchRequest()
                request.predicate = NSPredicate(format: "id == %@", item.id as CVarArg)
                if let folder = try? context.fetch(request).first {
                    return folder.isSmartFolder
                }
            }
            return false
        }
        
        if hasSystemFolder {
            // Show error - cannot delete system folders
            store.errorMessage = "Cannot delete system folders"
            return
        }
        
        itemsToDelete = deletionItems
        showingDeletionConfirmation = true
    }
    
    private func confirmDeletion() async {
        let itemIDs = Set(itemsToDelete.map { $0.id })
        let success = await store.deleteItems(itemIDs)
        
        await MainActor.run {
            if success {
                // Clear selection
                selectedItems.removeAll()
            }
            cancelDeletion()
        }
    }
    
    private func cancelDeletion() {
        itemsToDelete.removeAll()
        showingDeletionConfirmation = false
    }
}

================================================================================

File: Views/MainView.swift
// Views/MainView.swift

import SwiftUI

struct MainView: View {
    @EnvironmentObject var libraryManager: LibraryManager
    @StateObject private var folderStore: FolderNavigationStore
    @State private var searchText = ""
    @State private var columnVisibility = NavigationSplitViewVisibility.all
    
    // REFACTORED: The initializer now requires the active LibraryManager.
    // This is the standard SwiftUI pattern for initializing a @StateObject
    // that has dependencies, ensuring it's created only once with the correct state.
    init(libraryManager: LibraryManager) {
        self._folderStore = StateObject(wrappedValue: FolderNavigationStore(libraryManager: libraryManager))
    }
    
    var body: some View {
        NavigationSplitView(columnVisibility: $columnVisibility) {
            // Sidebar
            SidebarView()
                .navigationSplitViewColumnWidth(min: 200, ideal: 250, max: 350)
                .environmentObject(folderStore)
                .environment(\.managedObjectContext, libraryManager.viewContext!)
        } content: {
            // Hierarchical Content View - shows content of selected top-level sidebar item
            HierarchicalContentView(searchText: searchText)
                .navigationTitle(folderStore.folderName(for: folderStore.currentFolderID))
                .navigationSplitViewColumnWidth(min: 300, ideal: 400, max: 600)
                .searchable(text: $searchText, prompt: "Search videos")
                .environmentObject(folderStore)
                .environment(\.managedObjectContext, libraryManager.viewContext!)
        } detail: {
            // Detail View
            DetailView(video: folderStore.selectedVideo)
                .navigationSplitViewColumnWidth(min: 500, ideal: 700)
        }
        .navigationTitle(libraryManager.currentLibrary?.name ?? "Pangolin")
        .pangolinAlert(error: $libraryManager.error)
    }
}


================================================================================

File: Views/Sidebar/CreateFolderView.swift
// Views/Sidebar/CreateFolderView.swift
import SwiftUI
import CoreData

struct CreateFolderView: View {
    @Environment(\.dismiss) var dismiss
    @EnvironmentObject private var store: FolderNavigationStore
    @State private var folderName = ""
    
    let parentFolderID: UUID?
    
    var body: some View {
        VStack {
            Text("Create New Folder")
                .font(.headline)
            
            TextField("Folder Name", text: $folderName)
                .textFieldStyle(.roundedBorder)
                .frame(width: 300)
            
            HStack {
                Button("Cancel") {
                    dismiss()
                }
                .keyboardShortcut(.cancelAction)
                
                Button("Create") {
                    Task {
                        await createFolder()
                    }
                }
                .keyboardShortcut(.defaultAction)
                .disabled(folderName.isEmpty)
            }
        }
        .padding()
        .frame(width: 400, height: 150)
    }
    
    private func createFolder() async {
        let trimmedName = folderName.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmedName.isEmpty else { return }
        
        await store.createFolder(name: trimmedName, in: parentFolderID)
        dismiss()
    }
}


================================================================================

File: Views/Components/SummaryView.swift
import SwiftUI
import NaturalLanguage

struct SummaryView: View {
    @ObservedObject var video: Video
    @StateObject private var summaryService = SummaryService()
    @EnvironmentObject var libraryManager: LibraryManager
    
    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 16) {
                HStack {
                    Text("Summary")
                        .font(.title2)
                        .fontWeight(.bold)
                    
                    Spacer()
                    
                    if summaryService.isGenerating {
                        ProgressView()
                            .scaleEffect(0.8)
                    } else if video.transcriptSummary == nil {
                        Button("Generate Summary") {
                            Task {
                                await summaryService.generateSummary(for: video, libraryManager: libraryManager)
                            }
                        }
                        .buttonStyle(.borderedProminent)
                        .disabled(video.transcriptText == nil)
                    } else {
                        Button("Regenerate") {
                            Task {
                                await summaryService.generateSummary(for: video, libraryManager: libraryManager)
                            }
                        }
                        .buttonStyle(.bordered)
                    }
                }
                
                if video.transcriptText == nil {
                    ContentUnavailableView(
                        "Transcript Required",
                        systemImage: "doc.text.below.ecg",
                        description: Text("A transcript is required to generate a summary. Go to the Transcript tab and generate one first.")
                    )
                } else if summaryService.isGenerating {
                    VStack(alignment: .leading, spacing: 8) {
                        HStack {
                            Image(systemName: "brain.head.profile")
                                .foregroundColor(.purple)
                            Text("Analyzing transcript...")
                                .font(.headline)
                        }
                        
                        ProgressView()
                            .progressViewStyle(LinearProgressViewStyle())
                        
                        Text("Extracting key points and themes")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                    .padding()
                    .background(Color(NSColor.controlBackgroundColor))
                    .cornerRadius(8)
                } else if let errorMessage = summaryService.errorMessage {
                    VStack(alignment: .leading, spacing: 8) {
                        HStack {
                            Image(systemName: "exclamationmark.triangle")
                                .foregroundColor(.orange)
                            Text("Summary Error")
                                .font(.headline)
                        }
                        
                        Text(errorMessage)
                            .font(.body)
                            .foregroundColor(.secondary)
                    }
                    .padding()
                    .background(Color.orange.opacity(0.1))
                    .cornerRadius(8)
                } else if let summary = video.transcriptSummary {
                    VStack(alignment: .leading, spacing: 12) {
                        Divider()
                        
                        ScrollView {
                            Text(summary)
                                .font(.body)
                                .textSelection(.enabled)
                                .frame(maxWidth: .infinity, alignment: .leading)
                        }
                        .frame(maxHeight: 400)
                        .padding()
                        .background(Color(NSColor.textBackgroundColor))
                        .cornerRadius(8)
                        .overlay(
                            RoundedRectangle(cornerRadius: 8)
                                .stroke(Color.secondary.opacity(0.3), lineWidth: 1)
                        )
                    }
                } else {
                    ContentUnavailableView(
                        "No Summary Available",
                        systemImage: "doc.text.below.ecg",
                        description: Text("Tap 'Generate Summary' to create a summary of this video's transcript.")
                    )
                }
                
                Spacer()
            }
            .padding()
        }
    }
}

================================================================================

File: Views/Components/VideoControlsBar.swift
//
//  VideoControlsBar.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//


// Views/Components/VideoControlsBar.swift
import SwiftUI

struct VideoControlsBar: View {
    @ObservedObject var viewModel: VideoPlayerViewModel
    
    var body: some View {
        HStack(spacing: 20) {
            // Play/Pause button
            Button(action: { viewModel.togglePlayPause() }) {
                Image(systemName: viewModel.isPlaying ? "pause.fill" : "play.fill")
                    .font(.title2)
            }
            .buttonStyle(.plain)
            
            // Skip backward
            Button(action: { viewModel.skipBackward() }) {
                Image(systemName: "gobackward.10")
            }
            .buttonStyle(.plain)
            
            // Skip forward
            Button(action: { viewModel.skipForward() }) {
                Image(systemName: "goforward.10")
            }
            .buttonStyle(.plain)
            
            // Time display
            Text(formatTime(viewModel.currentTime))
                .monospacedDigit()
            
            // Progress slider
            Slider(value: Binding(
                get: { viewModel.currentTime },
                set: { viewModel.seek(to: $0) }
            ), in: 0...max(viewModel.duration, 1))
            
            // Duration display
            Text(formatTime(viewModel.duration))
                .monospacedDigit()
            
            // Volume control
            Image(systemName: "speaker.fill")
            Slider(value: $viewModel.volume, in: 0...1)
                .frame(width: 100)
            
            // Playback speed
            Menu {
                ForEach([0.5, 0.75, 1.0, 1.25, 1.5, 2.0], id: \.self) { rate in
                    Button(String(format: "%.2fx", rate)) {
                        viewModel.setPlaybackRate(Float(rate))
                    }
                }
            } label: {
                Text(String(format: "%.2fx", viewModel.playbackRate))
            }
            .frame(width: 60)
            
            // Subtitle menu
            if !viewModel.availableSubtitles.isEmpty {
                Menu {
                    Button("Off") {
                        viewModel.selectSubtitle(nil)
                    }
                    Divider()
                    ForEach(viewModel.availableSubtitles, id: \.id) { subtitle in
                        Button(subtitle.displayName) {
                            viewModel.selectSubtitle(subtitle)
                        }
                    }
                } label: {
                    Image(systemName: "captions.bubble")
                }
            }
        }
        .padding(.horizontal)
    }
    
    func formatTime(_ time: TimeInterval) -> String {
        let formatter = DateComponentsFormatter()
        formatter.allowedUnits = [.hour, .minute, .second]
        formatter.unitsStyle = .positional
        formatter.zeroFormattingBehavior = .pad
        return formatter.string(from: time) ?? "00:00"
    }
}

================================================================================

File: Views/Components/VideoDetailTabView.swift
import SwiftUI

struct VideoDetailTabView: View {
    @ObservedObject var video: Video
    @EnvironmentObject var libraryManager: LibraryManager
    
    var body: some View {
        TabView {
            VideoInfoView(video: video)
                .tabItem {
                    Label("Info", systemImage: "info.circle")
                }
            
            TranscriptionView(video: video)
                .tabItem {
                    Label("Transcript", systemImage: "doc.text")
                }
            
            SummaryView(video: video)
                .tabItem {
                    Label("Summary", systemImage: "doc.text.below.ecg")
                }
        }
    }
}

================================================================================

File: Views/Components/FolderNavigationHeader.swift
//
//  FolderNavigationHeader.swift
//  Pangolin
//
//  Created by Matt Kevan on 18/08/2025.
//

import SwiftUI

struct FolderNavigationHeader: View {
    @EnvironmentObject private var store: FolderNavigationStore
    let onCreateSubfolder: () -> Void
    
    private var canGoBack: Bool {
        !store.navigationPath.isEmpty
    }
    
    private var folderName: String {
        store.folderName(for: store.currentFolderID)
    }
    
    var body: some View {
        HStack {
            // Back button
            if canGoBack {
                Button {
                    store.navigateBack()
                } label: {
                    HStack(spacing: 4) {
                        Image(systemName: "chevron.left")
                            .font(.system(size: 12, weight: .medium))
                        Text("Back")
                            .font(.system(size: 14))
                    }
                }
                .buttonStyle(.plain)
                .foregroundColor(.primary)
            }
            
            Spacer()
            
            // Folder name
            Text(folderName)
                .font(.headline)
                .lineLimit(1)
                .truncationMode(.middle)
            
            Spacer()
            
            // Create subfolder button
            Button {
                onCreateSubfolder()
            } label: {
                HStack(spacing: 4) {
                    Image(systemName: "folder.badge.plus")
                        .font(.system(size: 14))
                    Text("New Folder")
                        .font(.system(size: 14))
                }
            }
            .buttonStyle(.plain)
            .foregroundColor(.primary)
            .help("Create New Subfolder")
        }
        .padding(.horizontal, 16)
        .padding(.vertical, 12)
        .background(backgroundMaterial)
        .overlay(
            Rectangle()
                .fill(separatorColor)
                .frame(height: 0.5),
            alignment: .bottom
        )
    }
    
    private var backgroundMaterial: some View {
        #if os(macOS)
        Color(NSColor.controlBackgroundColor)
        #else
        Color(.secondarySystemGroupedBackground)
        #endif
    }
    
    private var separatorColor: Color {
        #if os(macOS)
        Color(NSColor.separatorColor)
        #else
        Color(.separator)
        #endif
    }
}

#Preview {
    FolderNavigationHeader {
        // Preview action
    }
    .environmentObject(FolderNavigationStore(libraryManager: LibraryManager.shared))
}

================================================================================

File: Views/Components/DeletionConfirmationView.swift
//
//  DeletionConfirmationView.swift
//  Pangolin
//
//  Created by Claude on 21/08/2025.
//

import SwiftUI

struct DeletionConfirmationView: View {
    let items: [DeletionItem]
    let onConfirm: () -> Void
    let onCancel: () -> Void
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            // Header
            HStack {
                Image(systemName: "trash")
                    .foregroundColor(.red)
                    .font(.title2)
                
                Text(title)
                    .font(.headline)
                    .fontWeight(.semibold)
            }
            
            // Warning message
            Text(message)
                .font(.body)
                .foregroundColor(.secondary)
            
            // Items list (if more than 1 item or if we want to show names)
            if items.count > 1 || items.count == 1 {
                VStack(alignment: .leading, spacing: 4) {
                    Text("Items to delete:")
                        .font(.caption)
                        .fontWeight(.medium)
                        .foregroundColor(.secondary)
                    
                    ScrollView {
                        LazyVStack(alignment: .leading, spacing: 2) {
                            ForEach(items.prefix(10), id: \.id) { item in
                                HStack(spacing: 8) {
                                    Image(systemName: item.isFolder ? "folder" : "play.rectangle")
                                        .foregroundColor(item.isFolder ? .orange : .primary)
                                        .font(.caption)
                                    
                                    Text(item.name)
                                        .font(.caption)
                                        .lineLimit(1)
                                }
                            }
                            
                            if items.count > 10 {
                                Text("and \(items.count - 10) more...")
                                    .font(.caption2)
                                    .foregroundColor(.secondary)
                                    .italic()
                            }
                        }
                    }
                    .frame(maxHeight: 150)
                }
                .padding(12)
                .background(Color(NSColor.controlBackgroundColor))
                .cornerRadius(8)
            }
            
            // Buttons
            HStack {
                Spacer()
                
                Button("Cancel") {
                    onCancel()
                }
                .keyboardShortcut(.escape)
                
                Button("Delete", role: .destructive) {
                    onConfirm()
                }
                .keyboardShortcut(.return)
            }
        }
        .padding(20)
        .frame(width: 400)
        .background(Color(NSColor.windowBackgroundColor))
        .cornerRadius(12)
    }
    
    private var title: String {
        if items.count == 1 {
            return items.first!.isFolder ? "Delete Folder" : "Delete Video"
        } else {
            let folderCount = items.filter { $0.isFolder }.count
            let videoCount = items.count - folderCount
            
            if folderCount > 0 && videoCount > 0 {
                return "Delete \(items.count) Items"
            } else if folderCount > 0 {
                return "Delete \(folderCount) Folder\(folderCount == 1 ? "" : "s")"
            } else {
                return "Delete \(videoCount) Video\(videoCount == 1 ? "" : "s")"
            }
        }
    }
    
    private var message: String {
        let hasFolder = items.contains { $0.isFolder }
        let hasVideo = items.contains { !$0.isFolder }
        
        if items.count == 1 {
            if items.first!.isFolder {
                return "This folder and all its contents will be permanently deleted from your library and removed from disk. This action cannot be undone."
            } else {
                return "This video will be permanently deleted from your library and removed from disk. This action cannot be undone."
            }
        } else {
            var message = "These items will be permanently deleted from your library"
            if hasFolder && hasVideo {
                message += ". Folders and their contents will be removed from disk"
            } else if hasFolder {
                message += ". All folders and their contents will be removed from disk"
            } else {
                message += " and removed from disk"
            }
            message += ". This action cannot be undone."
            return message
        }
    }
}

struct DeletionItem {
    let id: UUID
    let name: String
    let isFolder: Bool
    
    init(folder: Folder) {
        self.id = folder.id!
        self.name = folder.name!
        self.isFolder = true
    }
    
    init(video: Video) {
        self.id = video.id!
        self.name = video.title!
        self.isFolder = false
    }
    
    init(id: UUID, name: String, isFolder: Bool) {
        self.id = id
        self.name = name
        self.isFolder = isFolder
    }
}

#Preview {
    DeletionConfirmationView(
        items: [
            DeletionItem(id: UUID(), name: "Sample Folder", isFolder: true),
            DeletionItem(id: UUID(), name: "Sample Video.mp4", isFolder: false)
        ],
        onConfirm: {},
        onCancel: {}
    )
}

================================================================================

File: Views/Components/TranscriptionView.swift
import SwiftUI
import Speech

struct TranscriptionView: View {
    @ObservedObject var video: Video
    @StateObject private var transcriptionService = SpeechTranscriptionService()
    @EnvironmentObject var libraryManager: LibraryManager
    
    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 16) {
                HStack {
                    Text("Transcript")
                        .font(.title2)
                        .fontWeight(.bold)
                    
                    Spacer()
                    
                    if transcriptionService.isTranscribing {
                        ProgressView()
                            .scaleEffect(0.8)
                    } else if video.transcriptText == nil {
                        Button("Generate Transcript") {
                            Task {
                                await transcriptionService.transcribeVideo(video, libraryManager: libraryManager)
                            }
                        }
                        .buttonStyle(.borderedProminent)
                    } else {
                        Button("Regenerate") {
                            Task {
                                await transcriptionService.transcribeVideo(video, libraryManager: libraryManager)
                            }
                        }
                        .buttonStyle(.bordered)
                    }
                }
            
                if transcriptionService.isTranscribing {
                    VStack(alignment: .leading, spacing: 8) {
                        HStack {
                            Image(systemName: "waveform")
                                .foregroundColor(.blue)
                            Text("Transcribing audio...")
                                .font(.headline)
                        }
                        
                        ProgressView(value: transcriptionService.progress)
                            .progressViewStyle(LinearProgressViewStyle())
                        
                        Text(transcriptionService.statusMessage)
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                    .padding()
                    .background(Color(NSColor.controlBackgroundColor))
                    .cornerRadius(8)
                }
                
                if let errorMessage = transcriptionService.errorMessage {
                    VStack(alignment: .leading, spacing: 12) {
                        HStack {
                            Image(systemName: "exclamationmark.triangle")
                                .foregroundColor(.orange)
                            Text("Transcription Error")
                                .font(.headline)
                        }
                        
                        Text(errorMessage)
                            .font(.body)
                            .foregroundColor(.primary)
                        
                        // Show recovery suggestion if available
                        if let error = parseTranscriptionError(from: errorMessage),
                           let suggestion = error.recoverySuggestion {
                            Divider()
                            
                            VStack(alignment: .leading, spacing: 4) {
                                Text("💡 Suggestion:")
                                    .font(.caption)
                                    .fontWeight(.medium)
                                    .foregroundColor(.blue)
                                
                                Text(suggestion)
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                        }
                        
                        HStack {
                            Spacer()
                            Button("Try Again") {
                                Task {
                                    await transcriptionService.transcribeVideo(video, libraryManager: libraryManager)
                                }
                            }
                            .buttonStyle(.borderedProminent)
                            .controlSize(.small)
                        }
                    }
                    .padding()
                    .background(Color.orange.opacity(0.1))
                    .cornerRadius(8)
                }
            
                if let transcriptText = video.transcriptText {
                    VStack(alignment: .leading, spacing: 12) {
                        HStack {
                            if let language = video.transcriptLanguage {
                                Label(language, systemImage: "globe")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                            
                            Spacer()
                            
                            if let dateGenerated = video.transcriptDateGenerated {
                                Text("Generated \(dateGenerated, formatter: DateFormatter.shortDate)")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                        }
                        
                        Divider()
                        
                        ScrollView {
                            Text(transcriptText)
                                .font(.body)
                                .textSelection(.enabled)
                                .frame(maxWidth: .infinity, alignment: .leading)
                        }
                        .frame(maxHeight: 400)
                        .padding()
                        .background(Color(NSColor.textBackgroundColor))
                        .cornerRadius(8)
                        .overlay(
                            RoundedRectangle(cornerRadius: 8)
                                .stroke(Color.secondary.opacity(0.3), lineWidth: 1)
                        )
                    }
                } else if !transcriptionService.isTranscribing && transcriptionService.errorMessage == nil {
                    ContentUnavailableView(
                        "No Transcript Available",
                        systemImage: "doc.text",
                        description: Text("Tap 'Generate Transcript' to create a transcript of this video's audio.")
                    )
                }
                
                Spacer()
            }
            .padding()
        }
    }
    
    private func parseTranscriptionError(from message: String) -> TranscriptionError? {
        // Simple parsing to extract error type from message
        // In a real implementation, you might want to pass the actual error object
        if message.contains("permission") {
            return .permissionDenied
        } else if message.contains("language") && message.contains("not supported") {
            return .languageNotSupported(Locale.current)
        } else if message.contains("SpeechTranscriber") && message.contains("not available") {
            return .speechTranscriberNotAvailable
        } else if message.contains("extract audio") {
            return .audioExtractionFailed
        } else if message.contains("locate the video file") {
            return .videoFileNotFound
        } else if message.contains("No speech was detected") {
            return .noSpeechDetected
        } else if message.contains("download") && message.contains("assets") {
            return .assetInstallationFailed
        }
        return nil
    }
}

extension DateFormatter {
    static let shortDate: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateStyle = .short
        formatter.timeStyle = .short
        return formatter
    }()
}

================================================================================

File: Views/Components/VideoPlayerWithPosterView.swift
//
//  VideoPlayerWithPosterView.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//

import SwiftUI
import AVKit

struct VideoPlayerWithPosterView: View {
    let video: Video?
    @ObservedObject var viewModel: VideoPlayerViewModel
    @State private var showPlayer = false
    @State private var hasStartedPlaying = false
    
    var body: some View {
        ZStack {
            // Background color
            Color.black
            
            if let video = video {
                if !showPlayer && !hasStartedPlaying {
                    // Show poster frame (thumbnail)
                    posterFrameView(for: video)
                } else {
                    // Show video player
                    VideoPlayerView(viewModel: viewModel)
                        .onAppear {
                            if !hasStartedPlaying {
                                hasStartedPlaying = true
                            }
                        }
                }
            } else {
                // No video selected state
                ContentUnavailableView(
                    "No Video Selected",
                    systemImage: "video.slash",
                    description: Text("Select a video from the library to start playing")
                )
                .foregroundColor(.white)
            }
        }
        .onChange(of: video?.id) { oldValue, newValue in
            // Reset state when video changes
            showPlayer = false
            hasStartedPlaying = false
        }
        .onChange(of: viewModel.isPlaying) { oldValue, newValue in
            if newValue {
                showPlayer = true
                hasStartedPlaying = true
            }
        }
    }
    
    @ViewBuilder
    private func posterFrameView(for video: Video) -> some View {
        ZStack {
            // Thumbnail background
            if let thumbnailURL = video.thumbnailURL,
               FileManager.default.fileExists(atPath: thumbnailURL.path) {
                AsyncImage(url: thumbnailURL) { image in
                    image
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                } placeholder: {
                    Rectangle()
                        .fill(Color.gray.opacity(0.3))
                        .overlay(
                            ProgressView()
                                .tint(.white)
                        )
                }
            } else {
                // Fallback when no thumbnail
                Rectangle()
                    .fill(Color.gray.opacity(0.3))
                    .overlay(
                        VStack(spacing: 12) {
                            Image(systemName: "video")
                                .font(.system(size: 48))
                                .foregroundColor(.white.opacity(0.7))
                            
                            Text(video.title!)
                                .font(.title2)
                                .foregroundColor(.white)
                                .multilineTextAlignment(.center)
                                .lineLimit(2)
                        }
                        .padding()
                    )
            }
            
            // Play button overlay
            playButtonOverlay
            
            // Video info overlay
            videoInfoOverlay(for: video)
        }
        .onTapGesture {
            startPlayback()
        }
    }
    
    @ViewBuilder
    private var playButtonOverlay: some View {
        Button(action: startPlayback) {
            ZStack {
                Circle()
                    .fill(Color.black.opacity(0.6))
                    .frame(width: 80, height: 80)
                
                Image(systemName: "play.fill")
                    .font(.system(size: 32))
                    .foregroundColor(.white)
                    .offset(x: 3) // Slight offset to center the play triangle visually
            }
        }
        .buttonStyle(PlainButtonStyle())
        .scaleEffect(1.0)
        .animation(.easeInOut(duration: 0.1), value: showPlayer)
    }
    
    @ViewBuilder
    private func videoInfoOverlay(for video: Video) -> some View {
        VStack {
            Spacer()
            
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text(video.title!)
                        .font(.title3)
                        .fontWeight(.semibold)
                        .foregroundColor(.white)
                        .shadow(color: .black.opacity(0.7), radius: 2)
                    
                    HStack(spacing: 12) {
                        Text(video.formattedDuration)
                        
                        if let resolution = video.resolution, !resolution.isEmpty {
                            Text(resolution)
                        }
                        
                        if video.playbackPosition > 0 {
                            Text("Resume from \(formatTime(video.playbackPosition))")
                                .foregroundColor(.accentColor)
                        }
                    }
                    .font(.caption)
                    .foregroundColor(.white.opacity(0.9))
                    .shadow(color: .black.opacity(0.7), radius: 1)
                }
                
                Spacer()
            }
            .padding()
            .background(
                LinearGradient(
                    colors: [.clear, .black.opacity(0.7)],
                    startPoint: .top,
                    endPoint: .bottom
                )
            )
        }
    }
    
    private func startPlayback() {
        guard let video = video else { return }
        
        // Load video if not already loaded
        if viewModel.player == nil || video != getCurrentVideo() {
            viewModel.loadVideo(video)
        }
        
        // Start playing
        viewModel.play()
        showPlayer = true
        hasStartedPlaying = true
    }
    
    private func getCurrentVideo() -> Video? {
        return viewModel.currentVideo
    }
    
    private func formatTime(_ seconds: TimeInterval) -> String {
        let formatter = DateComponentsFormatter()
        formatter.allowedUnits = [.hour, .minute, .second]
        formatter.unitsStyle = .positional
        formatter.zeroFormattingBehavior = .pad
        return formatter.string(from: seconds) ?? "00:00"
    }
}

#Preview {
    // Preview with mock data
    VideoPlayerWithPosterView(
        video: nil,
        viewModel: VideoPlayerViewModel()
    )
    .frame(height: 400)
    .background(Color.black)
}

================================================================================

File: Views/Components/HierarchicalContentRowView.swift
//
//  HierarchicalContentRowView.swift
//  Pangolin
//
//  Created by Claude on 19/08/2025.
//

import SwiftUI
import CoreData

/// Row view for hierarchical content items in the native SwiftUI List
struct HierarchicalContentRowView: View {
    let item: HierarchicalContentItem
    @Binding var renamingItemID: UUID?
    @FocusState.Binding var focusedField: UUID?
    @Binding var editedName: String
    @Binding var selectedItems: Set<UUID>
    
    @EnvironmentObject private var store: FolderNavigationStore
    @Environment(\.managedObjectContext) private var viewContext
    
    // Add state to prevent double-commits on focus loss
    @State private var shouldCommitOnDisappear = false
    @State private var showingDeletionConfirmation = false
    
    var body: some View {
        HStack(spacing: 12) {
            // Icon or Thumbnail
            Group {
                if case .video(let video) = item.contentType {
                    VideoThumbnailView(video: video, size: CGSize(width: 32, height: 18))
                        .frame(width: 32, height: 18)
                        .clipShape(RoundedRectangle(cornerRadius: 3))
                        .overlay(
                            RoundedRectangle(cornerRadius: 3)
                                .stroke(Color.primary.opacity(0.1), lineWidth: 0.5)
                        )
                } else {
                    Image(systemName: iconName)
                        .foregroundColor(iconColor)
                        .frame(width: 16, height: 16)
                }
            }
            
            // Name (editable if renaming)
            if renamingItemID == item.id {
                TextField("Name", text: $editedName)
                    .textFieldStyle(.plain)
                    .focused($focusedField, equals: item.id)
                    .onAppear {
                        editedName = item.name
                        shouldCommitOnDisappear = true
                    }
                    .onSubmit {
                        shouldCommitOnDisappear = false
                        // Use a Task to call the new async function
                        Task { await commitRename() }
                    }
                    .onKeyPress(.escape) {
                        shouldCommitOnDisappear = false
                        cancelRename()
                        return .handled
                    }
                    .onChange(of: focusedField) { oldValue, newValue in
                        if oldValue == item.id && newValue != item.id && shouldCommitOnDisappear {
                            // Use a Task here as well
                            Task { await commitRename() }
                        }
                    }
            } else {
                Text(item.name)
                    .lineLimit(1)
                    .font(.system(.body, design: .default, weight: .regular))
            }
            
            Spacer()
            
            // Additional info for videos
            if case .video(let video) = item.contentType {
                Text(video.formattedDuration)
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
        .contextMenu {
            contextMenuContent
        }
        .draggable(dragPayload)
        .dropDestination(for: ContentTransfer.self) { items, location in
            handleDrop(items)
        } isTargeted: { isTargeted in
            // Could add visual feedback for drop targeting
        }
    }
    
    // MARK: - Computed Properties
    
    private var iconName: String {
        switch item.contentType {
        case .folder:
            return item.hasChildren ? "folder" : "folder"
        case .video:
            return "play.rectangle"
        }
    }
    
    private var iconColor: Color {
        switch item.contentType {
        case .folder:
            return .accentColor
        case .video:
            return .primary
        }
    }
    
    private var dragPayload: ContentTransfer {
        // If the dragged item is part of a larger selection, drag all selected items.
        // Otherwise, just drag the single item.
        if selectedItems.contains(item.id) {
            return ContentTransfer(itemIDs: Array(selectedItems))
        } else {
            return ContentTransfer(itemIDs: [item.id])
        }
    }
    
    @ViewBuilder
    private var contextMenuContent: some View {
        Button("Rename") {
            startRenaming()
        }
        
        if case .folder = item.contentType {
            Divider()
            Button("Create Subfolder") {
                // TODO: Implement subfolder creation
            }
        }
        
        Divider()
        Button("Delete", role: .destructive) {
            // TODO: Implement deletion
        }
    }
    
    // MARK: - Actions
    
    private func startRenaming() {
        editedName = item.name
        renamingItemID = item.id
        Task { @MainActor in
            try? await Task.sleep(nanoseconds: 100_000_000) // 0.1s delay
            focusedField = item.id
        }
    }
    
    private func commitRename() async {
        shouldCommitOnDisappear = false

        guard let renamingID = renamingItemID,
              renamingID == item.id else {
            await MainActor.run { cancelRename() }
            return
        }
        
        let trimmedName = editedName.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmedName.isEmpty && trimmedName != item.name else {
            await MainActor.run { cancelRename() }
            return
        }
        
        // ❗ KEY CHANGE: Await the save operation BEFORE updating the local UI state.
        await store.renameItem(id: item.id, to: trimmedName)
        
        // This now runs only AFTER the save is complete.
        await MainActor.run {
            renamingItemID = nil
            focusedField = nil
        }
    }
    
    private func cancelRename() {
        shouldCommitOnDisappear = false
        renamingItemID = nil
        focusedField = nil
        editedName = ""
    }
    
    private func handleDrop(_ items: [ContentTransfer]) -> Bool {
        guard case .folder(let folder) = item.contentType else { return false }
        
        // Extract all item IDs from transfers
        let itemIDs = Set(items.flatMap { $0.itemIDs })
        
        // Don't allow dropping an item onto itself
        guard !itemIDs.contains(item.id) else { return false }
        
        Task {
            await store.moveItems(itemIDs, to: folder.id)
        }
        
        return true
    }
}

================================================================================

File: Views/Components/ContentRowView.swift
//
//  ContentRowView.swift
//  Pangolin
//
//  Created by Matt Kevan on 18/08/2025.
//

import SwiftUI

struct ContentRowView: View {
    let content: ContentType
    let isSelected: Bool
    let showCheckbox: Bool
    let viewMode: ViewMode
    @Binding var selectedItems: Set<UUID>
    @Binding var renamingItemID: UUID?
    @FocusState.Binding var focusedField: UUID?
    @Binding var editedName: String

    @EnvironmentObject private var store: FolderNavigationStore
    @State private var isDropTargeted = false
    @State private var shouldCommitOnDisappear = false

    enum ViewMode {
        case grid
        case list
    }

    private var dragPayload: ContentTransfer {
        if selectedItems.contains(content.id) {
            return ContentTransfer(itemIDs: Array(selectedItems))
        } else {
            return ContentTransfer(itemIDs: [content.id])
        }
    }

    var body: some View {
        Group {
            switch viewMode {
            case .grid:
                gridContent
            case .list:
                listContent
            }
        }
        .contextMenu {
            Button("Rename") { startRenaming() }
            Button("Delete", role: .destructive) { /* TODO: Implement deletion */ }
        }
        .draggable(dragPayload)
        .onDrop(of: [.data], isTargeted: $isDropTargeted) { providers in
            guard case .folder(let folder) = content else { return false }
            
            if let provider = providers.first {
                let _ = provider.loadDataRepresentation(for: .data) { data, _ in
                    if let data = data,
                       let transfer = try? JSONDecoder().decode(ContentTransfer.self, from: data),
                       !transfer.itemIDs.contains(folder.id!) {
                        Task { @MainActor in
                            await store.moveItems(Set(transfer.itemIDs), to: folder.id)
                        }
                    }
                }
                return true
            }
            return false
        }
    }

    // MARK: - View Builders
    
    @ViewBuilder
    private var gridContent: some View {
        VStack {
            ZStack {
                RoundedRectangle(cornerRadius: 8)
                    .fill(content.isFolder ? Color.blue.opacity(0.1) : Color.gray.opacity(0.1))
                    .frame(height: 120)
                
                contentIcon
                    .font(.system(size: 40))
                    .foregroundColor(content.isFolder ? .blue : .primary)
                
                if showCheckbox {
                    VStack {
                        HStack {
                            Spacer()
                            Image(systemName: isSelected ? "checkmark.circle.fill" : "circle")
                                .foregroundColor(isSelected ? .blue : .gray)
                                .background(Color.white)
                                .clipShape(Circle())
                        }
                        Spacer()
                    }
                    .padding(8)
                }
            }
            
            VStack(alignment: .center, spacing: 4) {
                nameEditorView
                    .font(.caption)
                    .lineLimit(2)
                    .multilineTextAlignment(.center)
                
                if case .folder(let folder) = content {
                    Text("\(folder.itemCount) items")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                } else if case .video(let video) = content {
                    Text(video.formattedDuration)
                        .font(.caption2)
                        .foregroundColor(.secondary)
                }
            }
            .frame(maxWidth: .infinity)
        }
        .background(isSelected && !showCheckbox ? Color.accentColor.opacity(0.2) : Color.clear)
        .cornerRadius(8)
        .overlay(
            RoundedRectangle(cornerRadius: 8)
                .stroke(isDropTargeted ? Color.accentColor : Color.clear, lineWidth: 2)
        )
    }

    @ViewBuilder
    private var listContent: some View {
        HStack {
            if showCheckbox {
                Image(systemName: isSelected ? "checkmark.circle.fill" : "circle")
                    .foregroundColor(isSelected ? .blue : .gray)
            }
            
            contentIcon
                .font(.system(size: 20))
                .foregroundColor(content.isFolder ? .blue : .primary)
                .frame(width: 24)
            
            VStack(alignment: .leading, spacing: 2) {
                nameEditorView
                    .lineLimit(1)
                
                HStack {
                    if case .folder(let folder) = content {
                        Text("\(folder.itemCount) items")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    } else if case .video(let video) = content {
                        Text(video.formattedDuration)
                            .font(.caption)
                            .foregroundColor(.secondary)
                        
                        Spacer()
                        
                        Text(ByteCountFormatter().string(fromByteCount: video.fileSize))
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
            }
            Spacer()
        }
        .padding(.vertical, 4)
        .background(isSelected && !showCheckbox ? Color.accentColor.opacity(0.1) : Color.clear)
        .cornerRadius(4)
        .overlay(
             RoundedRectangle(cornerRadius: 4)
                .stroke(isDropTargeted ? Color.accentColor : Color.clear, lineWidth: 2)
        )
    }
    
    @ViewBuilder
    private var nameEditorView: some View {
        if renamingItemID == content.id {
            TextField("Name", text: $editedName)
                .focused($focusedField, equals: content.id)
                .onAppear {
                    editedName = content.name
                    shouldCommitOnDisappear = true
                }
                .onSubmit {
                    shouldCommitOnDisappear = false
                    // ✅ Call async function from a Task
                    Task { await commitRename() }
                }
                .onKeyPress { keyPress in
                    if keyPress.key == .escape {
                        shouldCommitOnDisappear = false
                        cancelRename()
                        return .handled
                    }
                    return .ignored
                }
                .onChange(of: focusedField) { oldValue, newValue in
                    if oldValue == content.id && newValue != content.id && shouldCommitOnDisappear {
                        // ✅ Call async function from a Task
                        Task { await commitRename() }
                    }
                }
        } else {
            Text(content.name)
        }
    }
    
    @ViewBuilder
    private var contentIcon: some View {
        switch content {
        case .folder:
            Image(systemName: "folder.fill")
        case .video(let video):
            if let thumbnailURL = video.thumbnailURL,
               FileManager.default.fileExists(atPath: thumbnailURL.path) {
                AsyncImage(url: thumbnailURL) { image in
                    image
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                } placeholder: {
                    Image(systemName: "video.fill")
                        .foregroundColor(.gray)
                }
                .frame(width: viewMode == .grid ? 80 : 20, height: viewMode == .grid ? 45 : 15)
                .clipShape(RoundedRectangle(cornerRadius: 4))
            } else {
                Image(systemName: "video.fill")
            }
        }
    }

    // MARK: - Renaming Logic

    private func startRenaming() {
        editedName = content.name
        renamingItemID = content.id
        Task { @MainActor in
            try? await Task.sleep(nanoseconds: 100_000_000)
            focusedField = content.id
        }
    }
    
    // ✅ Make the function async
    private func commitRename() async {
        shouldCommitOnDisappear = false
        
        guard let itemID = renamingItemID, itemID == content.id else {
            await MainActor.run { cancelRename() }
            return
        }
        
        let trimmedName = editedName.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmedName.isEmpty && trimmedName != content.name else {
            await MainActor.run { cancelRename() }
            return
        }
        
        // ✅ Await the store operation before updating local state
        await store.renameItem(id: itemID, to: trimmedName)
        
        // ✅ Now update local state after the save is complete
        await MainActor.run {
            renamingItemID = nil
            focusedField = nil
        }
    }
    
    private func cancelRename() {
        editedName = content.name
        shouldCommitOnDisappear = false
        renamingItemID = nil
        focusedField = nil
    }
}

================================================================================

File: Views/Components/VideoInfoView.swift
//
//  VideoInfoView.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//

import SwiftUI

struct VideoInfoView: View {
    // Use @ObservedObject for a managed object to ensure the view updates on change
    @ObservedObject var video: Video
    @EnvironmentObject var libraryManager: LibraryManager
    
    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 16) {
                // Title and metadata
                VStack(alignment: .leading, spacing: 8) {
                    Text(video.title!)
                        .font(.title2)
                        .fontWeight(.bold)
                    
                    HStack {
                        Text(video.formattedDuration)
                        Text("•")
                        Text(video.resolution ?? "Unknown")
                        Text("•")
                        Text(ByteCountFormatter.string(fromByteCount: video.fileSize, countStyle: .file))
                    }
                    .font(.caption)
                    .foregroundColor(.secondary)
                }
                
                // Favorite Button
                Button(action: toggleFavorite) {
                    Label(video.isFavorite ? "Remove from Favorites" : "Add to Favorites",
                          systemImage: video.isFavorite ? "heart.fill" : "heart")
                }
                .buttonStyle(.bordered)
                .tint(video.isFavorite ? .red : .secondary)

                Divider()
                
                // File info
                VStack(alignment: .leading, spacing: 8) {
                    Text("File Information")
                        .font(.headline)
                    
                    InfoRow(label: "Filename", value: video.fileName!)
                    InfoRow(label: "Format", value: video.videoFormat ?? "Unknown")
                    InfoRow(label: "Frame Rate", value: String(format: "%.1f fps", video.frameRate))
                    InfoRow(label: "Date Added", value: DateFormatter.localizedString(from: video.dateAdded!, dateStyle: .medium, timeStyle: .short))
                    
                    if let lastPlayed = video.lastPlayed {
                        InfoRow(label: "Last Played", value: DateFormatter.localizedString(from: lastPlayed, dateStyle: .medium, timeStyle: .short))
                    }
                    
                    InfoRow(label: "Play Count", value: String(video.playCount))
                }
                
                if video.hasSubtitles {
                    Divider()
                    
                    VStack(alignment: .leading, spacing: 8) {
                        Text("Subtitles")
                            .font(.headline)
                        
                        if let subtitles = video.subtitles {
                            ForEach(Array(subtitles as! Set<Subtitle>), id: \.id) { subtitle in
                                HStack {
                                    Text(subtitle.displayName)
                                    Spacer()
                                    Text(subtitle.format!.uppercased())
                                        .font(.caption2)
                                        .padding(.horizontal, 6)
                                        .padding(.vertical, 2)
                                        .background(Color.secondary.opacity(0.2))
                                        .cornerRadius(4)
                                }
                            }
                        }
                    }
                }
                
                Spacer()
            }
            .padding()
        }
    }

    private func toggleFavorite() {
        print("🧠 VIDEO: Toggling favorite status for '\(video.title ?? "Unknown")' to \(!video.isFavorite)")
        video.isFavorite.toggle()
        print("🧠 VIDEO: isFavorite is now \(video.isFavorite)")
        
        Task {
            await libraryManager.save()
            print("🧠 VIDEO: Save completed for favorite toggle")
        }
    }
}

struct InfoRow: View {
    let label: String
    let value: String
    
    var body: some View {
        HStack {
            Text(label)
                .foregroundColor(.secondary)
            Spacer()
            Text(value)
                .fontWeight(.medium)
        }
        .font(.caption)
    }
}


================================================================================

File: Views/Components/VideoThumbnailView.swift
//
//  VideoThumbnailView.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//

import SwiftUI

struct VideoThumbnailView: View {
    let video: Video
    let size: CGSize
    
    init(video: Video, size: CGSize = CGSize(width: 160, height: 90)) {
        self.video = video
        self.size = size
    }
    
    var body: some View {
        Group {
            if let thumbnailURL = video.thumbnailURL,
               FileManager.default.fileExists(atPath: thumbnailURL.path) {
                AsyncImage(url: thumbnailURL) { image in
                    image
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                } placeholder: {
                    Rectangle()
                        .fill(Color.gray.opacity(0.2))
                        .overlay(
                            ProgressView()
                                .scaleEffect(0.7)
                        )
                }
            } else {
                // Fallback placeholder
                Rectangle()
                    .fill(Color.gray.opacity(0.2))
                    .overlay(
                        VStack(spacing: 4) {
                            Image(systemName: "play.rectangle.fill")
                                .font(.title2)
                                .foregroundColor(.gray.opacity(0.6))
                            
                            Text("No Preview")
                                .font(.caption2)
                                .foregroundColor(.secondary)
                        }
                    )
            }
        }
        .frame(width: size.width, height: size.height)
        .clipShape(RoundedRectangle(cornerRadius: 8))
        .overlay(
            // Duration overlay
            HStack {
                Spacer()
                VStack {
                    Spacer()
                    Text(video.formattedDuration)
                        .font(.caption2)
                        .foregroundColor(.white)
                        .padding(.horizontal, 6)
                        .padding(.vertical, 2)
                        .background(Color.black.opacity(0.7))
                        .clipShape(RoundedRectangle(cornerRadius: 4))
                        .padding(6)
                }
            }
        )
    }
}

#Preview {
    // Preview placeholder since we need actual video data
    Rectangle()
        .fill(Color.gray.opacity(0.2))
        .frame(width: 160, height: 90)
        .clipShape(RoundedRectangle(cornerRadius: 8))
        .overlay(
            VStack {
                Image(systemName: "play.rectangle.fill")
                    .font(.title2)
                Text("Thumbnail Preview")
                    .font(.caption)
            }
            .foregroundColor(.gray)
        )
}

================================================================================

File: Views/Main/LibraryWelcomeView.swift
//
//  LibraryWelcomeView.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//

import SwiftUI

struct LibraryWelcomeView: View {
    @Binding var showLibrarySelector: Bool
    @Binding var showCreateLibrary: Bool
    @EnvironmentObject var libraryManager: LibraryManager
    
    var body: some View {
        VStack(spacing: 40) {
            Image(systemName: "play.square.stack")
                .font(.system(size: 80))
                .foregroundColor(.accentColor)
            
            Text("Welcome to Pangolin")
                .font(.largeTitle)
                .fontWeight(.bold)
            
            Text("Your personal video library manager")
                .font(.title3)
                .foregroundColor(.secondary)
            
            VStack(spacing: 16) {
                Button(action: { showCreateLibrary = true }) {
                    Label("Create New Library", systemImage: "plus.square")
                        .frame(width: 200)
                }
                .controlSize(.large)
                .buttonStyle(.borderedProminent)
                
                Button(action: { showLibrarySelector = true }) {
                    Label("Open Existing Library", systemImage: "folder")
                        .frame(width: 200)
                }
                .controlSize(.large)
                .buttonStyle(.bordered)
                
                if !libraryManager.recentLibraries.isEmpty {
                    Divider()
                        .frame(width: 200)
                    
                    VStack(alignment: .leading) {
                        Text("Recent Libraries")
                            .font(.headline)
                        
                        ForEach(libraryManager.recentLibraries.prefix(3)) { library in
                            Button(action: {
                                Task { @MainActor in
                                    try? await libraryManager.openLibrary(at: library.path)
                                }
                            }) {
                                HStack {
                                    Image(systemName: "clock.arrow.circlepath")
                                    VStack(alignment: .leading) {
                                        Text(library.name)
                                            .font(.body)
                                        Text(library.path.path)
                                            .font(.caption)
                                            .foregroundColor(.secondary)
                                    }
                                }
                            }
                            .buttonStyle(.plain)
                            .disabled(!library.isAvailable)
                        }
                    }
                }
            }
        }
        .padding(50)
        .frame(minWidth: 600, minHeight: 500)
    }
}


================================================================================

File: Services/SpeechTranscriptionService.swift
import Foundation
import Speech
import AVFoundation
import NaturalLanguage

@MainActor
class SpeechTranscriptionService: ObservableObject {
    @Published var isTranscribing = false
    @Published var progress: Double = 0.0
    @Published var statusMessage = ""
    @Published var errorMessage: String?
    
    // iOS 26.0+ properties
    private var _currentAnalyzer: Any?
    
    func transcribeVideo(_ video: Video, libraryManager: LibraryManager) async {
        guard !isTranscribing else { return }
        
        isTranscribing = true
        errorMessage = nil
        progress = 0.0
        statusMessage = "Preparing transcription..."
        
        do {
            // Step 1: Check permissions
            statusMessage = "Checking speech recognition permissions..."
            try await requestSpeechRecognitionPermission()
            progress = 0.1
            
            // Step 2: Extract audio from video
            statusMessage = "Extracting audio from video..."
            let audioFile = try await extractAudioFromVideo(video)
            progress = 0.2
            
            // Step 3: Detect language 
            statusMessage = "Detecting language..."
            let detectedLocale = await detectLanguage(from: audioFile, video: video)
            progress = 0.3
            
            // Step 4: Perform transcription using available API
            statusMessage = "Transcribing audio..."
            let transcriptText: String
            
            transcriptText = try await performModernTranscription(audioFile: audioFile, locale: detectedLocale)
            
            progress = 0.9
            
            // Step 7: Save results
            statusMessage = "Saving transcript..."
            await saveTranscriptionResults(
                video: video,
                transcriptText: transcriptText,
                language: detectedLocale.identifier,
                libraryManager: libraryManager
            )
            progress = 1.0
            statusMessage = "Transcription completed!"
            
            // Clean up temporary audio file
            try? FileManager.default.removeItem(at: audioFile)
            
        } catch {
            errorMessage = "Transcription failed: \(error.localizedDescription)"
            print("🚨 Transcription error: \(error)")
        }
        
        isTranscribing = false
    }
    
    private func requestSpeechRecognitionPermission() async throws {
        let authorizationStatus = SFSpeechRecognizer.authorizationStatus()
        
        switch authorizationStatus {
        case .authorized:
            return
        case .notDetermined:
            return try await withCheckedThrowingContinuation { continuation in
                SFSpeechRecognizer.requestAuthorization { status in
                    switch status {
                    case .authorized:
                        continuation.resume()
                    case .denied, .restricted, .notDetermined:
                        continuation.resume(throwing: TranscriptionError.permissionDenied)
                    @unknown default:
                        continuation.resume(throwing: TranscriptionError.permissionDenied)
                    }
                }
            }
        case .denied, .restricted:
            throw TranscriptionError.permissionDenied
        @unknown default:
            throw TranscriptionError.permissionDenied
        }
    }
    
    private func extractAudioFromVideo(_ video: Video) async throws -> URL {
        let videoURL = try video.getFileURL()
        let tempAudioURL = FileManager.default.temporaryDirectory
            .appendingPathComponent(video.id!.uuidString)
            .appendingPathExtension("m4a")
        
        let asset = AVURLAsset(url: videoURL)
        
        guard let exportSession = AVAssetExportSession(asset: asset, presetName: AVAssetExportPresetAppleM4A) else {
            throw TranscriptionError.audioExtractionFailed
        }
        
        exportSession.outputURL = tempAudioURL
        exportSession.outputFileType = .m4a
        
        return try await withCheckedThrowingContinuation { [weak exportSession] continuation in
            guard let session = exportSession else {
                continuation.resume(throwing: TranscriptionError.audioExtractionFailed)
                return
            }
            
            // Use export session
            session.exportAsynchronously {
                switch session.status {
                case .completed:
                    continuation.resume(returning: tempAudioURL)
                case .failed, .cancelled:
                    continuation.resume(throwing: TranscriptionError.audioExtractionFailed)
                default:
                    continuation.resume(throwing: TranscriptionError.audioExtractionFailed)
                }
            }
        }
    }
    
    private func detectLanguage(from audioURL: URL, video: Video) async -> Locale {
        // First, try to detect language from existing subtitles
        if let subtitles = video.subtitles as? Set<Subtitle>,
           let firstSubtitle = subtitles.first,
           let language = firstSubtitle.language {
            return Locale(identifier: language)
        }
        
        // Try audio-based language detection using Speech Recognition
        do {
            let detectedLocale = try await detectLanguageFromAudio(audioURL)
            if detectedLocale != nil {
                return detectedLocale!
            }
        } catch {
            print("🚨 Language detection failed: \(error)")
        }
        
        // Fallback to system locale
        return Locale.current
    }
    
    private func detectLanguageFromAudio(_ audioURL: URL) async throws -> Locale? {
        // Extract a small sample from the beginning for language detection
        let sampleURL = try await extractAudioSample(from: audioURL, duration: 10.0)
        defer { try? FileManager.default.removeItem(at: sampleURL) }
        
        // Get list of supported locales for speech recognition
        let supportedLocales = SpeechRecognizer.supportedLocales()
        
        // Try detection with the most common languages first
        let commonLanguages = ["en-US", "es-ES", "fr-FR", "de-DE", "it-IT", "pt-BR", "ja-JP", "ko-KR", "zh-CN"]
        
        for languageCode in commonLanguages {
            if let locale = supportedLocales.first(where: { $0.identifier.hasPrefix(languageCode.prefix(2)) }) {
                if let confidence = try await testLanguageConfidence(audioURL: sampleURL, locale: locale) {
                    if confidence > 0.6 { // High confidence threshold
                        print("🎯 Detected language: \(locale.identifier) with confidence: \(confidence)")
                        return locale
                    }
                }
            }
        }
        
        return nil
    }
    
    private func extractAudioSample(from audioURL: URL, duration: TimeInterval) async throws -> URL {
        let asset = AVURLAsset(url: audioURL)
        let tempSampleURL = FileManager.default.temporaryDirectory
            .appendingPathComponent(UUID().uuidString)
            .appendingPathExtension("m4a")
        
        guard let exportSession = AVAssetExportSession(asset: asset, presetName: AVAssetExportPresetAppleM4A) else {
            throw TranscriptionError.audioExtractionFailed
        }
        
        exportSession.outputURL = tempSampleURL
        exportSession.outputFileType = .m4a
        exportSession.timeRange = CMTimeRange(start: .zero, duration: CMTime(seconds: duration, preferredTimescale: 600))
        
        return try await withCheckedThrowingContinuation { continuation in
            exportSession.exportAsynchronously {
                switch exportSession.status {
                case .completed:
                    continuation.resume(returning: tempSampleURL)
                case .failed:
                    continuation.resume(throwing: exportSession.error ?? TranscriptionError.audioExtractionFailed)
                case .cancelled:
                    continuation.resume(throwing: TranscriptionError.cancelled)
                default:
                    continuation.resume(throwing: TranscriptionError.audioExtractionFailed)
                }
            }
        }
    }
    
    private func testLanguageConfidence(audioURL: URL, locale: Locale) async throws -> Double? {
        guard SpeechRecognizer.authorizationStatus() == .authorized else { return nil }
        
        let recognizer = SpeechRecognizer(locale: locale)
        guard recognizer.isAvailable else { return nil }
        
        let request = SFSpeechURLRecognitionRequest(url: audioURL)
        request.shouldReportPartialResults = false
        request.taskHint = .dictation
        
        return try await withCheckedThrowingContinuation { continuation in
            recognizer.recognitionTask(with: request) { result, error in
                if let error = error {
                    continuation.resume(throwing: error)
                    return
                }
                
                if let result = result, result.isFinal {
                    let confidence = result.bestTranscription.segments.isEmpty ? 0.0 : 
                        result.bestTranscription.segments.map { $0.confidence }.reduce(0, +) / Double(result.bestTranscription.segments.count)
                    continuation.resume(returning: confidence)
                }
            }
        }
    }
    
    // MARK: - iOS 26.0+ Modern Implementation
    private func performModernTranscription(audioFile: URL, locale: Locale) async throws -> String {
        // iOS 26.0 beta implementation using modern SpeechTranscriber APIs
        
        statusMessage = "Setting up modern speech transcriber..."
        
        // Step 1: Create transcriber with enhanced configuration for better quality
        let transcriber = SpeechTranscriber(locale: locale,
                                           transcriptionOptions: [.enablePunctuation, .enableCapitalization],
                                           reportingOptions: [.includeWordConfidences, .includeTimestamps],
                                           attributeOptions: [.includePartialResults])
        progress = 0.3
        
        // Step 2: Ensure model is available
        statusMessage = "Ensuring speech model availability..."
        try await ensureModel(transcriber: transcriber, locale: locale)
        progress = 0.4
        
        // Step 3: Get the best available audio format
        guard let audioFormat = await SpeechAnalyzer.bestAvailableAudioFormat(compatibleWith: [transcriber]) else {
            throw TranscriptionError.audioExtractionFailed
        }
        
        // Step 4: Create the analyzer
        let analyzer = SpeechAnalyzer(modules: [transcriber])
        _currentAnalyzer = analyzer
        progress = 0.5
        
        // Step 5: Set up input stream
        let (inputSequence, inputBuilder) = AsyncStream<AnalyzerInput>.makeStream()
        
        // Step 6: Collect results
        var transcriptParts: [String] = []
        let resultsTask = Task {
            do {
                for try await result in transcriber.results {
                    let text = String(result.text.characters)
                    if result.isFinal && !text.isEmpty {
                        transcriptParts.append(text)
                        await MainActor.run {
                            self.progress = min(0.9, 0.5 + Double(transcriptParts.count) * 0.05)
                        }
                    }
                }
            } catch {
                throw error
            }
        }
        
        // Step 7: Start analysis
        try await analyzer.start(inputSequence: inputSequence)
        statusMessage = "Transcribing audio..."
        
        // Step 8: Process audio file
        do {
            let audioFile = try AVAudioFile(forReading: audioFile)
            
            // Convert and stream audio data
            let bufferSize: AVAudioFrameCount = 4096
            guard let buffer = AVAudioPCMBuffer(pcmFormat: audioFile.processingFormat, frameCapacity: bufferSize) else {
                throw TranscriptionError.audioExtractionFailed
            }
            
            while audioFile.framePosition < audioFile.length {
                try audioFile.read(into: buffer)
                
                if buffer.frameLength > 0 {
                    // Convert buffer to analyzer format if needed
                    let convertedBuffer: AVAudioPCMBuffer
                    if buffer.format == audioFormat {
                        convertedBuffer = buffer
                    } else {
                        // Create converter if formats don't match
                        guard let converter = AVAudioConverter(from: buffer.format, to: audioFormat) else {
                            throw TranscriptionError.audioExtractionFailed
                        }
                        
                        guard let outputBuffer = AVAudioPCMBuffer(pcmFormat: audioFormat, frameCapacity: bufferSize) else {
                            throw TranscriptionError.audioExtractionFailed
                        }
                        
                        var error: NSError?
                        let status = converter.convert(to: outputBuffer, error: &error) { _, outStatus in
                            outStatus.pointee = AVAudioConverterInputStatus.haveData
                            return buffer
                        }
                        
                        if status == .error {
                            throw TranscriptionError.audioExtractionFailed
                        }
                        
                        convertedBuffer = outputBuffer
                    }
                    
                    let input = AnalyzerInput(buffer: convertedBuffer)
                    inputBuilder.yield(input)
                }
            }
            
            // Step 9: Finish processing
            inputBuilder.finish()
            try await analyzer.finalizeAndFinishThroughEndOfInput()
            
            // Wait for results
            try await resultsTask.value
            
            _currentAnalyzer = nil
            
            let rawTranscript = transcriptParts.joined(separator: " ").trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)
            
            if rawTranscript.isEmpty {
                throw TranscriptionError.noSpeechDetected
            }
            
            // Post-process and validate transcript quality
            let fullTranscript = try cleanupTranscript(rawTranscript)
            
            if !isTranscriptQualityAcceptable(fullTranscript) {
                throw TranscriptionError.poorQualityTranscription
            }
            
            print("📊 Modern transcription completed successfully with \(transcriptParts.count) parts")
            return fullTranscript
            
        } catch {
            resultsTask.cancel()
            _currentAnalyzer = nil
            throw error
        }
    }
    
    // MARK: - Model Management
    private func ensureModel(transcriber: SpeechTranscriber, locale: Locale) async throws {
        guard await supported(locale: locale) else {
            throw TranscriptionError.languageNotSupported(locale)
        }
        
        if await installed(locale: locale) {
            return
        } else {
            try await downloadIfNeeded(for: transcriber)
        }
    }
    
    private func supported(locale: Locale) async -> Bool {
        let supported = await SpeechTranscriber.supportedLocales
        return supported.map { $0.identifier(.bcp47) }.contains(locale.identifier(.bcp47))
    }

    private func installed(locale: Locale) async -> Bool {
        let installed = await Set(SpeechTranscriber.installedLocales)
        return installed.map { $0.identifier(.bcp47) }.contains(locale.identifier(.bcp47))
    }

    private func downloadIfNeeded(for module: SpeechTranscriber) async throws {
        statusMessage = "Downloading speech models..."
        if let downloader = try await AssetInventory.assetInstallationRequest(supporting: [module]) {
            try await downloader.downloadAndInstall()
        }
    }
    
    
    private func saveTranscriptionResults(
        video: Video,
        transcriptText: String,
        language: String,
        libraryManager: LibraryManager
    ) async {
        video.transcriptText = transcriptText
        video.transcriptLanguage = language
        video.transcriptStatus = "completed"
        video.transcriptDateGenerated = Date()
        
        await libraryManager.save()
    }
    
    func cancelTranscription() {
        if let analyzer = _currentAnalyzer as? SpeechAnalyzer {
            Task {
                await analyzer.cancelAndFinishNow()
            }
        }
        _currentAnalyzer = nil
        
        isTranscribing = false
        statusMessage = "Transcription cancelled"
    }
}

// MARK: - Video Extension
extension Video {
    func getFileURL() throws -> URL {
        guard let fileURL = fileURL else {
            throw TranscriptionError.videoFileNotFound
        }
        
        guard FileManager.default.fileExists(atPath: fileURL.path) else {
            throw TranscriptionError.videoFileNotFound
        }
        
        return fileURL
    }
}

// MARK: - Error Types
enum TranscriptionError: LocalizedError {
    case permissionDenied
    case languageNotSupported(Locale)
    case speechTranscriberNotAvailable
    case audioExtractionFailed
    case videoFileNotFound
    case noSpeechDetected
    case assetInstallationFailed
    case analysisSessionFailed
    
    var errorDescription: String? {
        switch self {
        case .permissionDenied:
            return "Speech recognition permission is required to transcribe videos."
        case .languageNotSupported(let locale):
            return "The detected language (\(locale.localizedString(forIdentifier: locale.identifier) ?? "Unknown")) is not supported for transcription."
        case .speechTranscriberNotAvailable:
            return "SpeechTranscriber is not available on this device. This feature requires iOS 26.0+ with compatible hardware."
        case .audioExtractionFailed:
            return "Failed to extract audio from the video file. Please ensure the video format is supported."
        case .videoFileNotFound:
            return "Could not locate the video file for transcription. The file may have been moved or deleted."
        case .noSpeechDetected:
            return "No speech was detected in the audio. The video may contain only music, ambient sounds, or very quiet speech."
        case .assetInstallationFailed:
            return "Failed to download required speech recognition assets. Please check your internet connection and try again."
        case .analysisSessionFailed:
            return "Speech analysis session failed unexpectedly. Please try again."
        }
    }
    
    var recoverySuggestion: String? {
        switch self {
        case .permissionDenied:
            return "Go to Settings > Privacy & Security > Speech Recognition and enable access for Pangolin."
        case .languageNotSupported:
            return "Try changing your device language to a supported language, or manually select a different language for transcription."
        case .speechTranscriberNotAvailable:
            return "Update to iOS 26.0+ and ensure your device supports advanced speech recognition features."
        case .audioExtractionFailed:
            return "Try converting your video to a supported format (MP4, MOV, M4V) and try again."
        case .videoFileNotFound:
            return "Re-import the video file to your library and try transcription again."
        case .noSpeechDetected:
            return "Ensure the video contains clear speech and increase the device volume to maximum."
        case .assetInstallationFailed:
            return "Check your internet connection and ensure you have sufficient storage space for language assets."
        case .analysisSessionFailed:
            return "Close other apps to free up memory and try the transcription again."
        }
    }
}

================================================================================

File: Services/SummaryService.swift
import Foundation
import NaturalLanguage

@MainActor
class SummaryService: ObservableObject {
    @Published var isGenerating = false
    @Published var errorMessage: String?
    
    func generateSummary(for video: Video, libraryManager: LibraryManager) async {
        guard !isGenerating else { return }
        guard let transcriptText = video.transcriptText, !transcriptText.isEmpty else {
            errorMessage = "No transcript available to summarize"
            return
        }
        
        isGenerating = true
        errorMessage = nil
        
        do {
            let summary = await generateTextSummary(from: transcriptText)
            
            // Save the summary
            video.transcriptSummary = summary
            await libraryManager.save()
            
        } catch {
            errorMessage = "Failed to generate summary: \(error.localizedDescription)"
            print("🚨 Summary generation error: \(error)")
        }
        
        isGenerating = false
    }
    
    private func generateTextSummary(from text: String) async -> String {
        // Split text into sentences
        let sentences = extractSentences(from: text)
        
        guard !sentences.isEmpty else {
            return "No content available to summarize."
        }
        
        // If the text is short, return it as-is with basic formatting
        if sentences.count <= 5 {
            return formatShortSummary(sentences)
        }
        
        // For longer texts, extract key sentences
        let keyPoints = extractKeyPoints(from: sentences)
        let summary = formatSummary(keyPoints)
        
        return summary
    }
    
    private func extractSentences(from text: String) -> [String] {
        let tokenizer = NLTokenizer(unit: .sentence)
        tokenizer.string = text
        
        var sentences: [String] = []
        tokenizer.enumerateTokens(in: text.startIndex..<text.endIndex) { tokenRange, _ in
            let sentence = String(text[tokenRange]).trimmingCharacters(in: .whitespacesAndNewlines)
            if !sentence.isEmpty && sentence.count > 10 { // Filter out very short fragments
                sentences.append(sentence)
            }
            return true
        }
        
        return sentences
    }
    
    private func extractKeyPoints(from sentences: [String]) -> [String] {
        // Simple extraction algorithm:
        // 1. Score sentences based on word frequency and position
        // 2. Select top sentences up to a reasonable limit
        
        let wordFrequency = calculateWordFrequency(from: sentences)
        let scoredSentences = sentences.enumerated().map { (index, sentence) in
            let score = scoreSentence(sentence, wordFrequency: wordFrequency, position: index, totalSentences: sentences.count)
            return (sentence: sentence, score: score)
        }
        
        // Sort by score and take top sentences (up to 30% of original, minimum 3, maximum 10)
        let targetCount = max(3, min(10, sentences.count / 3))
        let topSentences = scoredSentences
            .sorted { $0.score > $1.score }
            .prefix(targetCount)
            .sorted { sentences.firstIndex(of: $0.sentence) ?? 0 < sentences.firstIndex(of: $1.sentence) ?? 0 }
            .map { $0.sentence }
        
        return topSentences
    }
    
    private func calculateWordFrequency(from sentences: [String]) -> [String: Int] {
        var frequency: [String: Int] = [:]
        let text = sentences.joined(separator: " ")
        
        let tokenizer = NLTokenizer(unit: .word)
        tokenizer.string = text
        
        // Common stop words to filter out
        let stopWords = Set(["the", "a", "an", "and", "or", "but", "in", "on", "at", "to", "for", "of", "with", "by", "is", "are", "was", "were", "be", "been", "have", "has", "had", "do", "does", "did", "will", "would", "could", "should", "may", "might", "can", "this", "that", "these", "those", "i", "you", "he", "she", "it", "we", "they", "me", "him", "her", "us", "them"])
        
        tokenizer.enumerateTokens(in: text.startIndex..<text.endIndex) { tokenRange, _ in
            let word = String(text[tokenRange]).lowercased()
            if word.count > 2 && !stopWords.contains(word) && word.rangeOfCharacter(from: CharacterSet.letters.inverted) == nil {
                frequency[word, default: 0] += 1
            }
            return true
        }
        
        return frequency
    }
    
    private func scoreSentence(_ sentence: String, wordFrequency: [String: Int], position: Int, totalSentences: Int) -> Double {
        let tokenizer = NLTokenizer(unit: .word)
        tokenizer.string = sentence
        
        var totalScore = 0.0
        var wordCount = 0
        
        tokenizer.enumerateTokens(in: sentence.startIndex..<sentence.endIndex) { tokenRange, _ in
            let word = String(sentence[tokenRange]).lowercased()
            if let freq = wordFrequency[word] {
                totalScore += Double(freq)
                wordCount += 1
            }
            return true
        }
        
        let averageScore = wordCount > 0 ? totalScore / Double(wordCount) : 0
        
        // Boost score for sentences at the beginning (introduction) and end (conclusion)
        let positionBoost: Double
        let relativePosition = Double(position) / Double(totalSentences)
        if relativePosition < 0.2 || relativePosition > 0.8 {
            positionBoost = 1.2
        } else {
            positionBoost = 1.0
        }
        
        // Boost score for sentences of moderate length (not too short or too long)
        let lengthBoost: Double
        let sentenceLength = sentence.count
        if sentenceLength > 50 && sentenceLength < 200 {
            lengthBoost = 1.1
        } else {
            lengthBoost = 0.9
        }
        
        return averageScore * positionBoost * lengthBoost
    }
    
    private func formatShortSummary(_ sentences: [String]) -> String {
        let summary = sentences.joined(separator: " ")
        return "**Key Points:**\n\n" + summary
    }
    
    private func formatSummary(_ keyPoints: [String]) -> String {
        var formatted = "**Summary:**\n\n"
        
        for (index, point) in keyPoints.enumerated() {
            formatted += "• \(point)\n"
            if index < keyPoints.count - 1 {
                formatted += "\n"
            }
        }
        
        return formatted
    }
}

================================================================================

