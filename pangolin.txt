FILE CONCATENATION REPORT
Root Directory: Pangolin/
Excluded Directories: ios, public, node_modules
File Extensions: *.swift, *.plist, *.entitlements, *.jsx, *.css, *.html, *.json, *.hbs, *.mdx
================================================================================

File: PangolinApp.swift
// PangolinApp.swift

import SwiftUI

@main
struct PangolinApp: App {
    @StateObject private var libraryManager = LibraryManager.shared
    @State private var showLibrarySelector = false
    @State private var showCreateLibrary = false
    
    var body: some Scene {
        WindowGroup {
            Group {
                if libraryManager.isLibraryOpen {
                    // REFACTORED: Pass the configured libraryManager into MainView's initializer.
                    // This ensures the entire view hierarchy, including the FolderNavigationStore,
                    // uses the correct, active Core Data context.
                    MainView(libraryManager: libraryManager)
                        .environmentObject(libraryManager)
                } else {
                    LibraryWelcomeView(
                        showLibrarySelector: $showLibrarySelector,
                        showCreateLibrary: $showCreateLibrary
                    )
                    .environmentObject(libraryManager)
                }
            }
            .fileImporter(
                isPresented: $showLibrarySelector,
                allowedContentTypes: [.folder],
                allowsMultipleSelection: false
            ) { result in
                switch result {
                case .success(let urls):
                    if let url = urls.first {
                        Task {
                            do {
                                let _ = try await libraryManager.openLibrary(at: url)
                            } catch {
                                print("Failed to open library: \(error)")
                                // In a real app, show an error alert to the user
                            }
                        }
                    }
                case .failure(let error):
                    print("Error selecting library: \(error)")
                }
            }
            .fileImporter(
                isPresented: $showCreateLibrary,
                allowedContentTypes: [.folder],
                allowsMultipleSelection: false
            ) { result in
                switch result {
                case .success(let urls):
                    if let url = urls.first {
                        Task {
                            do {
                                let _ = try await libraryManager.createLibrary(at: url, name: "My Library")
                            } catch {
                                print("Failed to create library: \(error)")
                                // In a real app, show an error alert to the user
                            }
                        }
                    }
                case .failure(let error):
                    print("Error creating library: \(error)")
                }
            }
        }
        #if os(macOS)
        .commands {
            CommandGroup(replacing: .newItem) {
                Button("New Library...") {
                    showCreateLibrary = true
                }
                .keyboardShortcut("N", modifiers: [.command, .shift])
                
                Button("Open Library...") {
                    showLibrarySelector = true
                }
                .keyboardShortcut("O", modifiers: .command)
                
                Divider()
                
                Menu("Recent Libraries") {
                    ForEach(libraryManager.recentLibraries) { library in
                        Button(library.name) {
                            Task {
                                try? await libraryManager.openLibrary(at: library.path)
                            }
                        }
                        .disabled(!library.isAvailable)
                    }
                }
            }
        }
        #endif
    }
}


================================================================================

File: Info.plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>NSServices</key>
	<array>
		<dict/>
	</array>
</dict>
</plist>


================================================================================

File: Pangolin.entitlements
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.app-sandbox</key>
	<true/>
	<key>com.apple.security.assets.movies.read-write</key>
	<true/>
	<key>com.apple.security.files.downloads.read-write</key>
	<true/>
	<key>com.apple.security.files.user-selected.read-write</key>
	<true/>
</dict>
</plist>


================================================================================

File: ViewModels/VideoPlayerViewModel.swift
//
//  VideoPlayerViewModel.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//


// ViewModels/VideoPlayerViewModel.swift
import Foundation
import AVFoundation
import Combine

class VideoPlayerViewModel: ObservableObject {
    @Published var player: AVPlayer?
    @Published var isPlaying = false
    @Published var currentTime: TimeInterval = 0
    @Published var duration: TimeInterval = 0
    @Published var isLoading = false
    @Published var volume: Float = 1.0
    @Published var playbackRate: Float = 1.0
    @Published var availableSubtitles: [Subtitle] = []
    @Published var selectedSubtitle: Subtitle?
    @Published var currentVideo: Video?
    
    private var timeObserver: Any?
    private var cancellables = Set<AnyCancellable>()
    
    func loadVideo(_ video: Video) {
        currentVideo = video
        
        guard let url = video.fileURL else { return }
        
        isLoading = true
        let playerItem = AVPlayerItem(url: url)
        
        // Load subtitles
        if let subtitles = video.subtitles {
            availableSubtitles = Array(subtitles as! Set<Subtitle>)
            // Load subtitle tracks into player item
        }
        
        player = AVPlayer(playerItem: playerItem)
        
        // Restore playback position
        if video.playbackPosition > 0 {
            player?.seek(to: CMTime(seconds: video.playbackPosition, preferredTimescale: 1))
        }
        
        setupTimeObserver()
        setupNotifications()
        
        isLoading = false
    }
    
    func play() {
        player?.play()
        isPlaying = true
    }
    
    func pause() {
        player?.pause()
        isPlaying = false
    }
    
    func togglePlayPause() {
        if isPlaying {
            pause()
        } else {
            play()
        }
    }
    
    func seek(to time: TimeInterval) {
        player?.seek(to: CMTime(seconds: time, preferredTimescale: 1))
    }
    
    func skipForward(_ seconds: TimeInterval = 10) {
        let newTime = currentTime + seconds
        seek(to: min(newTime, duration))
    }
    
    func skipBackward(_ seconds: TimeInterval = 10) {
        let newTime = currentTime - seconds
        seek(to: max(newTime, 0))
    }
    
    func setPlaybackRate(_ rate: Float) {
        playbackRate = rate
        player?.rate = isPlaying ? rate : 0
    }
    
    func selectSubtitle(_ subtitle: Subtitle?) {
        selectedSubtitle = subtitle
        // Apply subtitle to player
    }
    
    private func setupTimeObserver() {
        let interval = CMTime(seconds: 0.5, preferredTimescale: CMTimeScale(NSEC_PER_SEC))
        timeObserver = player?.addPeriodicTimeObserver(forInterval: interval, queue: .main) { [weak self] time in
            self?.currentTime = CMTimeGetSeconds(time)
            
            if let duration = self?.player?.currentItem?.duration {
                self?.duration = CMTimeGetSeconds(duration)
            }
            
            // Save playback position periodically
            self?.savePlaybackPosition()
        }
    }
    
    private func setupNotifications() {
        NotificationCenter.default.publisher(for: .AVPlayerItemDidPlayToEndTime)
            .sink { [weak self] _ in
                self?.handlePlaybackEnded()
            }
            .store(in: &cancellables)
    }
    
    private func savePlaybackPosition() {
        // Save to Core Data
        currentVideo?.playbackPosition = currentTime
    }
    
    private func handlePlaybackEnded() {
        isPlaying = false
        // Update play count
        if let video = currentVideo {
            video.playCount += 1
            video.lastPlayed = Date()
        }
    }
    
    deinit {
        if let observer = timeObserver {
            player?.removeTimeObserver(observer)
        }
    }
}

================================================================================

File: Managers/LibraryManager.swift
//
//  LibraryManager.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//

import Foundation
import CoreData
import Combine

// MARK: - Library Manager
@MainActor
class LibraryManager: ObservableObject {
    static let shared = LibraryManager()
    
    // MARK: - Published Properties
    @Published var currentLibrary: Library?
    @Published var isLibraryOpen = false
    @Published var recentLibraries: [LibraryDescriptor] = []
    @Published var isLoading = false
    @Published var loadingProgress: Double = 0
    @Published var error: LibraryError?
    
    // MARK: - Private Properties
    private let userDefaults = UserDefaults.standard
    private let fileManager = FileManager.default
    private var coreDataStack: CoreDataStack?
    private var cancellables = Set<AnyCancellable>()
    
    // MARK: - Constants
    private let libraryExtension = "pangolin"
    private let currentVersion = "1.0.0"
    private let recentLibrariesKey = "RecentLibraries"
    private let lastOpenedLibraryKey = "LastOpenedLibrary"
    
    // MARK: - Initialization
    private init() {
        loadRecentLibraries()
    }
    
    // MARK: - Public Properties
    
    /// Access to the current Core Data context
    var viewContext: NSManagedObjectContext? {
        return coreDataStack?.viewContext
    }
    
    // MARK: - Public Methods
    
    /// Saves the current library's data context if there are changes.
    func save() async {
        print("ðŸ’½ LIBRARY: save() called")
        
        guard let context = self.viewContext else {
            print("âŒ LIBRARY: No viewContext available")
            return
        }
        
        print("ðŸ“Š LIBRARY: Context hasChanges: \(context.hasChanges)")
        print("ðŸ“Š LIBRARY: Context insertedObjects count: \(context.insertedObjects.count)")
        print("ðŸ“Š LIBRARY: Context updatedObjects count: \(context.updatedObjects.count)")
        print("ðŸ“Š LIBRARY: Context deletedObjects count: \(context.deletedObjects.count)")
        
        // Log details about updated objects
        for obj in context.updatedObjects {
            print("ðŸ“ LIBRARY: Updated object: \(obj)")
            if let folder = obj as? Folder {
                print("ðŸ“ LIBRARY: Updated folder: '\(folder.name ?? "nil")' (ID: \(folder.id?.uuidString ?? "nil"))")
            } else if let video = obj as? Video {
                print("ðŸŽ¥ LIBRARY: Updated video: '\(video.title ?? "nil")' (ID: \(video.id?.uuidString ?? "nil"))")
            }
        }
        
        guard context.hasChanges else {
            print("â„¹ï¸ LIBRARY: No changes to save")
            return
        }
        
        do {
            print("ðŸ’¾ LIBRARY: Attempting context.save()...")
            try context.save()
            print("âœ… LIBRARY: Save successful!")
            
            // Verify that changes were actually saved by re-fetching
            print("ðŸ”„ LIBRARY: Verifying save by checking context state...")
            print("ðŸ“Š LIBRARY: After save - hasChanges: \(context.hasChanges)")
            print("ðŸ“Š LIBRARY: After save - updatedObjects count: \(context.updatedObjects.count)")
            
        } catch {
            print("ðŸ’¥ LIBRARY: Save failed: \(error.localizedDescription)")
            self.error = .saveFailed(error)
            context.rollback()
            print("ðŸ”„ LIBRARY: Context rolled back")
        }
    }
    
    /// Create a new library at the specified URL
    func createLibrary(at url: URL, name: String) async throws -> Library {
        isLoading = true
        loadingProgress = 0
        
        defer {
            isLoading = false
            loadingProgress = 0
        }
        
        // Create library package directory
        let libraryURL = url.appendingPathComponent("\(name).\(libraryExtension)")
        
        // Check if already exists
        if fileManager.fileExists(atPath: libraryURL.path) {
            throw LibraryError.libraryAlreadyExists(libraryURL)
        }
        
        // Create directory structure
        try createLibraryStructure(at: libraryURL)
        loadingProgress = 0.3
        
        // Initialize Core Data stack
        let stack = try CoreDataStack(libraryURL: libraryURL)
        self.coreDataStack = stack
        loadingProgress = 0.6
        
        // Create library entity using NSEntityDescription
        let context = stack.viewContext
        
        // Debug: Check if the managed object model is loaded correctly
        guard let model = context.persistentStoreCoordinator?.managedObjectModel else {
            print("ERROR: No managed object model found")
            throw LibraryError.corruptedDatabase
        }
        
        print("Available entities: \(model.entitiesByName.keys)")
        
        guard let entityDescription = model.entitiesByName["Library"] else {
            print("ERROR: Library entity not found in model")
            throw LibraryError.corruptedDatabase
        }
        
        print("Creating library entity with description: \(entityDescription)")
        let library = Library(entity: entityDescription, insertInto: context)
        
        // Verify library was created successfully
        guard library.entity == entityDescription else {
            print("ERROR: Library entity creation failed")
            throw LibraryError.corruptedDatabase
        }
        
        print("Library entity created successfully, setting properties...")
        
        library.id = UUID()
        library.name = name
        library.libraryPath = libraryURL.path
        library.createdDate = Date()
        library.lastOpenedDate = Date()
        library.version = currentVersion
        
        print("Basic properties set, setting default settings...")
        
        // Set default settings
        library.copyFilesOnImport = true
        library.organizeByDate = true
        library.autoMatchSubtitles = true
        library.defaultPlaybackSpeed = 1.0
        library.rememberPlaybackPosition = true
        
        print("All properties set successfully")
        
        // Create default smart folders
        createDefaultSmartFolders(for: library, in: context)
        loadingProgress = 0.8
        
        // Save context
        try context.save()
        
        // Update current library
        self.currentLibrary = library
        self.isLibraryOpen = true
        
        print("Library created successfully: \(library.name)")
        print("Library open state: \(self.isLibraryOpen)")
        
        // Add to recent libraries
        addToRecentLibraries(library)
        
        // Save as last opened
        saveLastOpenedLibrary(libraryURL)
        
        loadingProgress = 1.0
        
        return library
    }
    
    /// Open an existing library
    func openLibrary(at url: URL) async throws -> Library {
        isLoading = true
        loadingProgress = 0
        
        defer {
            isLoading = false
            loadingProgress = 0
        }
        
        // Validate library
        let validation = try validateLibrary(at: url)
        guard validation.isValid else {
            throw LibraryError.invalidLibrary(validation.errors)
        }
        loadingProgress = 0.2
        
        // Close current library if open
        if currentLibrary != nil {
            await closeCurrentLibrary()
        }
        loadingProgress = 0.3
        
        // Initialize Core Data stack
        let stack = try CoreDataStack(libraryURL: url)
        self.coreDataStack = stack
        loadingProgress = 0.5
        
        // Fetch library entity
        let context = stack.viewContext
        let request = Library.fetchRequest()
        request.fetchLimit = 1
        
        guard let library = try context.fetch(request).first else {
            throw LibraryError.libraryNotFound
        }
        loadingProgress = 0.7
        
        // Check for migration needs
        if library.version! != currentVersion {
            try await migrateLibrary(library, from: library.version!, to: currentVersion)
        }
        loadingProgress = 0.8
        
        // Ensure smart folders exist
        await ensureSmartFoldersExist(for: library, in: context)
        
        // Update library
        library.lastOpenedDate = Date()
        try context.save()
        
        // Set as current
        self.currentLibrary = library
        self.isLibraryOpen = true
        
        // Update recent libraries
        addToRecentLibraries(library)
        saveLastOpenedLibrary(url)
        
        loadingProgress = 1.0
        
        // Generate thumbnails for videos that don't have them (async in background)
        Task {
            await FileSystemManager.shared.generateMissingThumbnails(for: library, context: context)
        }
        
        return library
    }
    
    /// Close the current library
    func closeCurrentLibrary() async {
        guard currentLibrary != nil else { return }
        
        // Save any pending changes
        await save()
        
        // Clean up
        coreDataStack = nil
        currentLibrary = nil
        isLibraryOpen = false
    }
    
    /// Switch to a different library
    func switchToLibrary(_ descriptor: LibraryDescriptor) async throws {
        _ = try await openLibrary(at: descriptor.path)
    }
    
    /// Open the last used library
    func openLastLibrary() async throws {
        guard let lastLibraryPath = userDefaults.url(forKey: lastOpenedLibraryKey) else {
            throw LibraryError.noLastLibrary
        }
        
        _ = try await openLibrary(at: lastLibraryPath)
    }
    
    // MARK: - Library Validation
    
    struct LibraryValidation {
        let isValid: Bool
        let errors: [String]
        let isRepairable: Bool
    }
    
    func validateLibrary(at url: URL) throws -> LibraryValidation {
        var errors: [String] = []
        
        // Check if directory exists
        guard fileManager.fileExists(atPath: url.path) else {
            return LibraryValidation(isValid: false,
                                    errors: ["Library does not exist"],
                                    isRepairable: false)
        }
        
        // Check for required subdirectories
        let requiredDirs = ["Videos", "Subtitles", "Thumbnails", "Backups"]
        for dir in requiredDirs {
            let dirPath = url.appendingPathComponent(dir)
            if !fileManager.fileExists(atPath: dirPath.path) {
                errors.append("Missing directory: \(dir)")
            }
        }
        
        // Check for database
        let dbPath = url.appendingPathComponent("Library.sqlite")
        if !fileManager.fileExists(atPath: dbPath.path) {
            errors.append("Database file not found")
        }
        
        // Check Info.plist
        let infoPlistPath = url.appendingPathComponent("Info.plist")
        if !fileManager.fileExists(atPath: infoPlistPath.path) {
            errors.append("Info.plist not found")
        }
        
        let isValid = errors.isEmpty
        let isRepairable = !errors.contains("Database file not found")
        
        return LibraryValidation(isValid: isValid,
                                errors: errors,
                                isRepairable: isRepairable)
    }
    
    // MARK: - Private Methods
    
    private func createLibraryStructure(at url: URL) throws {
        // Create main directory
        try fileManager.createDirectory(at: url,
                                       withIntermediateDirectories: true)
        
        // Create subdirectories
        let subdirectories = ["Videos", "Subtitles", "Thumbnails", "Backups"]
        for dir in subdirectories {
            let dirURL = url.appendingPathComponent(dir)
            try fileManager.createDirectory(at: dirURL,
                                          withIntermediateDirectories: true)
        }
        
        // Create Info.plist
        let info: [String: Any] = [
            "Version": currentVersion,
            "CreatedDate": Date(),
            "BundleIdentifier": "com.pangolin.library",
            "LibraryType": "VideoLibrary"
        ]
        
        let infoPlistURL = url.appendingPathComponent("Info.plist")
        let plistData = try PropertyListSerialization.data(fromPropertyList: info,
                                                          format: .xml,
                                                          options: 0)
        try plistData.write(to: infoPlistURL)
    }
    
    
    private func loadRecentLibraries() {
        if let data = userDefaults.data(forKey: recentLibrariesKey),
           let libraries = try? JSONDecoder().decode([LibraryDescriptor].self, from: data) {
            self.recentLibraries = libraries
        }
    }
    
    private func addToRecentLibraries(_ library: Library) {
        guard let url = library.url else { return }
        
        let descriptor = LibraryDescriptor(
            id: library.id!,
            name: library.name!,
            path: url,
            lastOpenedDate: library.lastOpenedDate!,
            createdDate: library.createdDate!,
            version: library.version!,
            thumbnailData: nil,
            videoCount: library.videoCount,
            totalSize: library.totalSize
        )
        
        // Remove if already exists
        recentLibraries.removeAll { $0.id == descriptor.id }
        
        // Add to front
        recentLibraries.insert(descriptor, at: 0)
        
        // Keep only last 10
        if recentLibraries.count > 10 {
            recentLibraries = Array(recentLibraries.prefix(10))
        }
        
        // Save
        if let data = try? JSONEncoder().encode(recentLibraries) {
            userDefaults.set(data, forKey: recentLibrariesKey)
        }
    }
    
    private func saveLastOpenedLibrary(_ url: URL) {
        userDefaults.set(url, forKey: lastOpenedLibraryKey)
    }
    
    private func migrateLibrary(_ library: Library, from oldVersion: String, to newVersion: String) async throws {
        // Implement migration logic here
        library.version = newVersion
    }
    
    private func createDefaultSmartFolders(for library: Library, in context: NSManagedObjectContext) {
        guard let folderEntityDescription = context.persistentStoreCoordinator?.managedObjectModel.entitiesByName["Folder"] else {
            print("Could not find Folder entity description")
            return
        }
        
        let smartFolders = [
            ("All Videos", "video.fill"),
            ("Recent", "clock.fill"),
            ("Favorites", "heart.fill")
        ]
        
        // CORRECTED: The unused 'index' variable is replaced with '_'
        for (_, folderInfo) in smartFolders.enumerated() {
            let folder = Folder(entity: folderEntityDescription, insertInto: context)
            folder.id = UUID()
            folder.name = folderInfo.0
            folder.isTopLevel = true
            folder.isSmartFolder = true
            folder.dateCreated = Date()
            folder.dateModified = Date()
            folder.library = library
        }
    }
    
    private func ensureSmartFoldersExist(for library: Library, in context: NSManagedObjectContext) async {
        // Check if smart folders already exist
        let request = Folder.fetchRequest()
        request.predicate = NSPredicate(format: "library == %@ AND isSmartFolder == YES", library)
        
        do {
            let existingSmartFolders = try context.fetch(request)
            let existingNames = Set(existingSmartFolders.map { $0.name })
            
            let requiredSmartFolders = ["All Videos", "Recent", "Favorites"]
            
            // Create any missing smart folders
            for folderName in requiredSmartFolders {
                if !existingNames.contains(folderName) {
                    guard let folderEntityDescription = context.persistentStoreCoordinator?.managedObjectModel.entitiesByName["Folder"] else {
                        continue
                    }
                    
                    let folder = Folder(entity: folderEntityDescription, insertInto: context)
                    folder.id = UUID()
                    folder.name = folderName
                    folder.isTopLevel = true
                    folder.isSmartFolder = true
                    folder.dateCreated = Date()
                    folder.dateModified = Date()
                    folder.library = library
                }
            }
            
            try context.save()
        } catch {
            print("Failed to ensure smart folders exist: \(error)")
        }
    }
}

// MARK: - Library Errors
enum LibraryError: LocalizedError {
    case libraryAlreadyExists(URL)
    case libraryNotFound
    case invalidLibrary([String])
    case migrationFailed(String)
    case noLastLibrary
    case corruptedDatabase
    case insufficientPermissions
    case diskSpaceInsufficient
    case saveFailed(Error)
    
    var errorDescription: String? {
        switch self {
        case .libraryAlreadyExists(let url):
            return "A library already exists at \(url.lastPathComponent)"
        case .libraryNotFound:
            return "Library not found"
        case .invalidLibrary(let errors):
            return "Invalid library: \(errors.joined(separator: ", "))"
        case .migrationFailed(let reason):
            return "Migration failed: \(reason)"
        case .noLastLibrary:
            return "No previously opened library found"
        case .corruptedDatabase:
            return "The library database is corrupted"
        case .insufficientPermissions:
            return "Insufficient permissions to access library"
        case .diskSpaceInsufficient:
            return "Not enough disk space available"
        case .saveFailed(let error):
            return "Failed to save the library. \(error.localizedDescription)"
        }
    }
    
    var recoverySuggestion: String? {
        switch self {
        case .libraryAlreadyExists:
            return "Choose a different location or name for your library"
        case .libraryNotFound, .noLastLibrary:
            return "Create a new library or open an existing one"
        case .invalidLibrary:
            return "Try repairing the library or create a new one"
        case .migrationFailed, .saveFailed:
            return "Please try the operation again. If the problem persists, restart the application."
        case .corruptedDatabase:
            return "Restore from a backup or rebuild the library"
        case .insufficientPermissions:
            return "Check file permissions and try again"
        case .diskSpaceInsufficient:
            return "Free up disk space and try again"
        }
    }
}


================================================================================

File: Managers/FileSystemManager.swift
//
//  FileSystemManager.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//

import Foundation
import CoreData
import AVFoundation
#if os(macOS)
import AppKit
#else
import UIKit
#endif

class FileSystemManager {
    static let shared = FileSystemManager()
    
    private let fileManager = FileManager.default
    private let dateFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd"
        return formatter
    }()
    
    private init() {}
    
    // MARK: - Video File Operations
    
    func importVideo(from sourceURL: URL, to library: Library, context: NSManagedObjectContext, copyFile: Bool = true) async throws -> Video {
        guard let libraryURL = library.url else {
            throw FileSystemError.invalidLibraryPath
        }
        
        // Validate video file
        guard isVideoFile(sourceURL) else {
            throw FileSystemError.unsupportedFileType(sourceURL.pathExtension)
        }
        
        // Create date-based subdirectory
        let importDate = Date()
        let dateString = dateFormatter.string(from: importDate)
        let videosDir = libraryURL.appendingPathComponent("Videos").appendingPathComponent(dateString)
        
        // Ensure directory exists
        try fileManager.createDirectory(at: videosDir, withIntermediateDirectories: true)
        
        // Determine destination URL
        let fileName = sourceURL.lastPathComponent
        var destinationURL = videosDir.appendingPathComponent(fileName)
        
        // Handle duplicates
        destinationURL = try uniqueURL(for: destinationURL)
        
        // Copy or move file
        if copyFile {
            try fileManager.copyItem(at: sourceURL, to: destinationURL)
        } else {
            try fileManager.moveItem(at: sourceURL, to: destinationURL)
        }
        
        // Get relative path
        let relativePath = destinationURL.path.replacingOccurrences(of: libraryURL.path + "/Videos/", with: "")
        
        // Get video metadata
        let metadata = try await getVideoMetadata(from: destinationURL)
        
        // Generate thumbnail
        let thumbnailPath = try await generateThumbnail(for: destinationURL, in: library)
        
        // Create video entity in Core Data context using entity description
        guard let videoEntityDescription = context.persistentStoreCoordinator?.managedObjectModel.entitiesByName["Video"] else {
            throw FileSystemError.importFailed("Could not find Video entity description")
        }
        
        let video = Video(entity: videoEntityDescription, insertInto: context)
        video.id = UUID()
        video.title = sourceURL.deletingPathExtension().lastPathComponent
        video.fileName = fileName
        video.relativePath = relativePath
        video.duration = metadata.duration
        video.fileSize = metadata.fileSize
        video.dateAdded = importDate
        video.videoFormat = sourceURL.pathExtension
        video.resolution = metadata.resolution
        video.frameRate = metadata.frameRate
        video.playbackPosition = 0
        video.playCount = 0
        video.thumbnailPath = thumbnailPath
        video.library = library
        
        return video
    }
    
    func importFolder(at folderURL: URL, to library: Library, context: NSManagedObjectContext) async throws -> [Video] {
        var importedVideos: [Video] = []
        
        let enumerator = fileManager.enumerator(at: folderURL,
                                               includingPropertiesForKeys: [.isRegularFileKey],
                                               options: [.skipsHiddenFiles])
        
        while let fileURL = enumerator?.nextObject() as? URL {
            if isVideoFile(fileURL) {
                do {
                    let video = try await importVideo(from: fileURL, to: library, context: context)
                    importedVideos.append(video)
                } catch {
                    // Log error but continue importing other files
                    print("Failed to import \(fileURL): \(error)")
                }
            }
        }
        
        return importedVideos
    }
    
    // MARK: - Subtitle Operations
    
    func findMatchingSubtitles(for videoURL: URL) -> [URL] {
        let videoName = videoURL.deletingPathExtension().lastPathComponent
        let directory = videoURL.deletingLastPathComponent()
        
        var subtitles: [URL] = []
        
        do {
            let files = try fileManager.contentsOfDirectory(at: directory,
                                                           includingPropertiesForKeys: nil)
            
            for file in files {
                if isSubtitleFile(file) {
                    let subtitleName = file.deletingPathExtension().lastPathComponent
                    
                    // Check various matching patterns
                    if subtitleName == videoName ||
                       subtitleName.hasPrefix(videoName + ".") ||
                       subtitleName.hasPrefix(videoName + "_") {
                        subtitles.append(file)
                    }
                }
            }
        } catch {
            print("Error finding subtitles: \(error)")
        }
        
        return subtitles
    }
    
    // MARK: - Helper Methods
    
    private func isVideoFile(_ url: URL) -> Bool {
        let videoExtensions = VideoFormat.supportedExtensions
        return videoExtensions.contains(url.pathExtension.lowercased())
    }
    
    private func isSubtitleFile(_ url: URL) -> Bool {
        let subtitleExtensions = ["srt", "vtt", "ssa", "ass", "sub"]
        return subtitleExtensions.contains(url.pathExtension.lowercased())
    }
    
    private func uniqueURL(for url: URL) throws -> URL {
        var uniqueURL = url
        var counter = 1
        
        while fileManager.fileExists(atPath: uniqueURL.path) {
            let name = url.deletingPathExtension().lastPathComponent
            let ext = url.pathExtension
            uniqueURL = url.deletingLastPathComponent()
                .appendingPathComponent("\(name)_\(counter)")
                .appendingPathExtension(ext)
            counter += 1
        }
        
        return uniqueURL
    }
    
    private func getVideoMetadata(from url: URL) async throws -> VideoMetadata {
        let asset = AVURLAsset(url: url)
        
        // Get duration
        let duration = try await asset.load(.duration)
        let durationSeconds = CMTimeGetSeconds(duration)
        
        // Get file size
        let attributes = try fileManager.attributesOfItem(atPath: url.path)
        let fileSize = attributes[.size] as? Int64 ?? 0
        
        // Get video track for resolution and frame rate
        let tracks = try await asset.loadTracks(withMediaType: .video)
        var resolution = ""
        var frameRate = 0.0
        
        if let videoTrack = tracks.first {
            let size = try await videoTrack.load(.naturalSize)
            resolution = "\(Int(size.width))x\(Int(size.height))"
            
            let rate = try await videoTrack.load(.nominalFrameRate)
            frameRate = Double(rate)
        }
        
        return VideoMetadata(
            duration: durationSeconds,
            fileSize: fileSize,
            resolution: resolution,
            frameRate: frameRate
        )
    }
    
    // MARK: - Thumbnail Generation
    
    private func generateThumbnail(for videoURL: URL, in library: Library) async throws -> String? {
        guard let libraryURL = library.url else {
            throw FileSystemError.invalidLibraryPath
        }
        
        let asset = AVURLAsset(url: videoURL)
        let imageGenerator = AVAssetImageGenerator(asset: asset)
        imageGenerator.appliesPreferredTrackTransform = true
        imageGenerator.maximumSize = CGSize(width: 320, height: 180) // 16:9 aspect ratio
        
        // Generate thumbnail at 10% of video duration, or 5 seconds, whichever is smaller
        let duration = try await asset.load(.duration)
        let durationSeconds = CMTimeGetSeconds(duration)
        let thumbnailTime = CMTime(seconds: min(durationSeconds * 0.1, 5.0), preferredTimescale: 600)
        
        do {
            let cgImage = try await imageGenerator.image(at: thumbnailTime).image
            
            // Create thumbnail directory structure
            let videoRelativePath = videoURL.path.replacingOccurrences(of: libraryURL.path + "/Videos/", with: "")
            let thumbnailDir = libraryURL.appendingPathComponent("Thumbnails")
                .appendingPathComponent(URL(fileURLWithPath: videoRelativePath).deletingLastPathComponent().path)
            
            try fileManager.createDirectory(at: thumbnailDir, withIntermediateDirectories: true)
            
            // Save thumbnail as JPEG
            let thumbnailFileName = URL(fileURLWithPath: videoRelativePath).deletingPathExtension().lastPathComponent + ".jpg"
            let thumbnailURL = thumbnailDir.appendingPathComponent(thumbnailFileName)
            
            #if os(macOS)
            let nsImage = NSImage(cgImage: cgImage, size: NSSize(width: cgImage.width, height: cgImage.height))
            if let tiffData = nsImage.tiffRepresentation,
               let bitmapRep = NSBitmapImageRep(data: tiffData),
               let jpegData = bitmapRep.representation(using: .jpeg, properties: [.compressionFactor: 0.8]) {
                try jpegData.write(to: thumbnailURL)
            }
            #else
            let uiImage = UIImage(cgImage: cgImage)
            if let jpegData = uiImage.jpegData(compressionQuality: 0.8) {
                try jpegData.write(to: thumbnailURL)
            }
            #endif
            
            // Return relative path for thumbnail
            return thumbnailURL.path.replacingOccurrences(of: libraryURL.path + "/Thumbnails/", with: "")
            
        } catch {
            print("Failed to generate thumbnail for \(videoURL.lastPathComponent): \(error)")
            return nil
        }
    }
    
    // MARK: - Thumbnail Generation for Existing Videos
    
    func generateMissingThumbnails(for library: Library, context: NSManagedObjectContext) async {
        guard library.url != nil else { return }
        
        let request = Video.fetchRequest()
        request.predicate = NSPredicate(format: "library == %@ AND thumbnailPath == nil", library)
        
        do {
            let videosWithoutThumbnails = try context.fetch(request)
            print("Found \(videosWithoutThumbnails.count) videos without thumbnails")
            
            for video in videosWithoutThumbnails {
                guard let videoURL = video.fileURL else { continue }
                
                do {
                    let thumbnailPath = try await generateThumbnail(for: videoURL, in: library)
                    await MainActor.run {
                        video.thumbnailPath = thumbnailPath
                    }
                } catch {
                    print("Failed to generate thumbnail for \(video.fileName): \(error)")
                }
            }
            
            // Save context on main thread
            await MainActor.run {
                do {
                    try context.save()
                    print("Successfully saved thumbnails for \(videosWithoutThumbnails.count) videos")
                } catch {
                    print("Failed to save thumbnail paths: \(error)")
                }
            }
            
        } catch {
            print("Failed to fetch videos without thumbnails: \(error)")
        }
    }
}

// MARK: - Supporting Types

struct VideoMetadata {
    let duration: TimeInterval
    let fileSize: Int64
    let resolution: String
    let frameRate: Double
}

enum FileSystemError: LocalizedError {
    case invalidLibraryPath
    case unsupportedFileType(String)
    case importFailed(String)
    case fileNotFound
    case insufficientSpace
    case accessDenied
    
    var errorDescription: String? {
        switch self {
        case .invalidLibraryPath:
            return "Invalid library path"
        case .unsupportedFileType(let ext):
            return "Unsupported file type: .\(ext)"
        case .importFailed(let reason):
            return "Import failed: \(reason)"
        case .fileNotFound:
            return "File not found"
        case .insufficientSpace:
            return "Insufficient disk space"
        case .accessDenied:
            return "Access denied to file or folder"
        }
    }
}

================================================================================

File: Assets.xcassets/Contents.json
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}


================================================================================

File: Assets.xcassets/AppIcon.appiconset/Contents.json
{
  "images" : [
    {
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "appearances" : [
        {
          "appearance" : "luminosity",
          "value" : "dark"
        }
      ],
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "appearances" : [
        {
          "appearance" : "luminosity",
          "value" : "tinted"
        }
      ],
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "idiom" : "mac",
      "scale" : "1x",
      "size" : "16x16"
    },
    {
      "idiom" : "mac",
      "scale" : "2x",
      "size" : "16x16"
    },
    {
      "idiom" : "mac",
      "scale" : "1x",
      "size" : "32x32"
    },
    {
      "idiom" : "mac",
      "scale" : "2x",
      "size" : "32x32"
    },
    {
      "idiom" : "mac",
      "scale" : "1x",
      "size" : "128x128"
    },
    {
      "idiom" : "mac",
      "scale" : "2x",
      "size" : "128x128"
    },
    {
      "idiom" : "mac",
      "scale" : "1x",
      "size" : "256x256"
    },
    {
      "idiom" : "mac",
      "scale" : "2x",
      "size" : "256x256"
    },
    {
      "idiom" : "mac",
      "scale" : "1x",
      "size" : "512x512"
    },
    {
      "idiom" : "mac",
      "scale" : "2x",
      "size" : "512x512"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}


================================================================================

File: Assets.xcassets/AccentColor.colorset/Contents.json
{
  "colors" : [
    {
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}


================================================================================

File: Stores/FolderNavigationStore.swift
//
//  FolderNavigationStore.swift
//  Pangolin
//
//  Created by Matt Kevan on 18/08/2025.
//

import SwiftUI
import CoreData

class FolderNavigationStore: ObservableObject {
    // MARK: - Core State
    @Published var navigationPath = NavigationPath()
    @Published var currentFolderID: UUID?
    @Published var selectedTopLevelFolder: Folder?
    @Published var selectedVideo: Video?
    
    // MARK: - UI State
    @Published var currentSortOption: SortOption = .foldersFirst
    @Published var isLoading = false
    @Published var errorMessage: String?
    
    // MARK: - Dependencies
    private let libraryManager: LibraryManager
    
    init(libraryManager: LibraryManager) {
        self.libraryManager = libraryManager
        // Set initial folder to "All Videos" if available
        Task { @MainActor in
            guard let context = libraryManager.viewContext,
                  let library = libraryManager.currentLibrary else { return }
            
            let request = Folder.fetchRequest()
            request.predicate = NSPredicate(format: "library == %@ AND isTopLevel == YES AND isSmartFolder == YES AND name == %@", library, "All Videos")
            request.fetchLimit = 1
            
            do {
                if let allVideosFolder = try context.fetch(request).first {
                    selectedTopLevelFolder = allVideosFolder
                    currentFolderID = allVideosFolder.id
                }
            } catch {
                print("Error setting initial folder: \(error)")
            }
        }
    }
    
    // MARK: - Content Access
    @MainActor func systemFolders() -> [Folder] {
        print("ðŸ” FETCH: systemFolders() called")
        guard let context = libraryManager.viewContext,
              let library = libraryManager.currentLibrary else { 
            print("âŒ FETCH: No context or library for systemFolders")
            return [] 
        }
        
        let request = Folder.fetchRequest()
        request.predicate = NSPredicate(format: "library == %@ AND isTopLevel == YES AND isSmartFolder == YES", library)
        request.sortDescriptors = [NSSortDescriptor(keyPath: \Folder.name, ascending: true)]
        
        do {
            let folders = try context.fetch(request)
            print("ðŸ“ FETCH: systemFolders returned \(folders.count) folders: \(folders.map { $0.name ?? "nil" })")
            return folders
        } catch {
            print("ðŸ’¥ FETCH: systemFolders error: \(error.localizedDescription)")
            errorMessage = "Failed to load system folders: \(error.localizedDescription)"
            return []
        }
    }
    
    @MainActor func userFolders() -> [Folder] {
        print("ðŸ” FETCH: userFolders() called")
        guard let context = libraryManager.viewContext,
              let library = libraryManager.currentLibrary else { 
            print("âŒ FETCH: No context or library for userFolders")
            return [] 
        }
        
        let request = Folder.fetchRequest()
        request.predicate = NSPredicate(format: "library == %@ AND isTopLevel == YES AND isSmartFolder == NO", library)
        request.sortDescriptors = [NSSortDescriptor(keyPath: \Folder.name, ascending: true)]
        
        do {
            let folders = try context.fetch(request)
            print("ðŸ“ FETCH: userFolders returned \(folders.count) folders: \(folders.map { $0.name ?? "nil" })")
            return folders
        } catch {
            print("ðŸ’¥ FETCH: userFolders error: \(error.localizedDescription)")
            errorMessage = "Failed to load user folders: \(error.localizedDescription)"
            return []
        }
    }
    
    @MainActor func content(for folderID: UUID?) -> [ContentType] {
        guard let context = libraryManager.viewContext,
              let library = libraryManager.currentLibrary else { return [] }
        
        var contentItems: [ContentType] = []
        
        if let folderID = folderID {
            // Load content of specific folder
            let folderRequest = Folder.fetchRequest()
            folderRequest.predicate = NSPredicate(format: "library == %@ AND id == %@", library, folderID as CVarArg)
            
            do {
                if let folder = try context.fetch(folderRequest).first {
                    if folder.isSmartFolder {
                        // Handle smart folders - show videos based on the folder type
                        contentItems = getSmartFolderContent(folder: folder, library: library, context: context)
                    } else {
                        // Regular folder - show child folders and videos
                        for childFolder in folder.childFoldersArray {
                            contentItems.append(.folder(childFolder))
                        }
                        
                        for video in folder.videosArray {
                            contentItems.append(.video(video))
                        }
                    }
                }
            } catch {
                errorMessage = "Failed to load folder content: \(error.localizedDescription)"
            }
        } else {
            // Load top-level content (if any videos are not in folders)
            let videoRequest = Video.fetchRequest()
            videoRequest.predicate = NSPredicate(format: "library == %@ AND folder == NULL", library)
            
            do {
                let videos = try context.fetch(videoRequest)
                for video in videos {
                    contentItems.append(.video(video))
                }
            } catch {
                errorMessage = "Failed to load videos: \(error.localizedDescription)"
            }
        }
        
        return applySorting(contentItems)
    }
    
    // MARK: - Hierarchical Content
    
    /// Get hierarchical content for the selected top-level folder
    @MainActor func hierarchicalContent(for folderID: UUID?) -> [HierarchicalContentItem] {
        guard let context = libraryManager.viewContext,
              let library = libraryManager.currentLibrary,
              let folderID = folderID else { return [] }
        
        let folderRequest = Folder.fetchRequest()
        folderRequest.predicate = NSPredicate(format: "library == %@ AND id == %@", library, folderID as CVarArg)
        
        do {
            if let folder = try context.fetch(folderRequest).first {
                if folder.isSmartFolder {
                    // Smart folders show flat list of videos as hierarchical items
                    let contentItems = getSmartFolderContent(folder: folder, library: library, context: context)
                    return contentItems.compactMap { item in
                        if case .video(let video) = item {
                            return HierarchicalContentItem(video: video)
                        }
                        return nil
                    }
                } else {
                    // Regular folder - create hierarchical structure
                    var hierarchicalItems: [HierarchicalContentItem] = []
                    
                    // Add child folders (with their own hierarchical content)
                    for childFolder in folder.childFoldersArray {
                        hierarchicalItems.append(HierarchicalContentItem(folder: childFolder))
                    }
                    
                    // Add videos as leaf nodes
                    for video in folder.videosArray {
                        hierarchicalItems.append(HierarchicalContentItem(video: video))
                    }
                    
                    return hierarchicalItems
                }
            }
        } catch {
            errorMessage = "Failed to load hierarchical content: \(error.localizedDescription)"
        }
        
        return []
    }
    
    // MARK: - Navigation
    func navigateToFolder(_ folderID: UUID) {
        navigationPath.append(folderID)
    }
    
    func navigateBack() {
        guard !navigationPath.isEmpty else { return }
        navigationPath.removeLast()
        
        // Update currentFolderID based on remaining path
        if navigationPath.isEmpty {
            currentFolderID = selectedTopLevelFolder?.id
        } else {
            // For proper navigation, we need to track the parent folder
            // This is a limitation of NavigationPath - we'll handle it in the destination
        }
    }
    
    func navigateToRoot() {
        navigationPath = NavigationPath()
        currentFolderID = selectedTopLevelFolder?.id
    }
    
    func selectVideo(_ video: Video) {
        selectedVideo = video
    }
    
    // MARK: - Folder Management
    @MainActor
    func createFolder(name: String, in parentFolderID: UUID? = nil) async {
        guard let context = libraryManager.viewContext,
              let library = libraryManager.currentLibrary,
              let folderEntityDescription = context.persistentStoreCoordinator?.managedObjectModel.entitiesByName["Folder"] else {
            errorMessage = "Could not create folder"
            return
        }
        
        let trimmedName = name.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmedName.isEmpty else { return }
        
        let folder = Folder(entity: folderEntityDescription, insertInto: context)
        folder.id = UUID()
        folder.name = trimmedName
        folder.isTopLevel = (parentFolderID == nil)
        folder.dateCreated = Date()
        folder.dateModified = Date()
        folder.library = library
        
        if let parentFolderID = parentFolderID {
            let parentRequest = Folder.fetchRequest()
            parentRequest.predicate = NSPredicate(format: "library == %@ AND id == %@", library, parentFolderID as CVarArg)
            do {
                if let parentFolder = try context.fetch(parentRequest).first {
                    folder.parentFolder = parentFolder
                    folder.isTopLevel = false
                }
            } catch {
                errorMessage = "Failed to find parent folder: \(error.localizedDescription)"
                context.rollback()
                return
            }
        }
        await libraryManager.save()
        // Notify UI to refresh after successful folder creation
        NotificationCenter.default.post(name: .contentUpdated, object: nil)
    }
    
    @MainActor
    func moveItems(_ itemIDs: Set<UUID>, to destinationFolderID: UUID?) async {
        guard let context = libraryManager.viewContext,
              libraryManager.currentLibrary != nil, !itemIDs.isEmpty else { return }
        
        do {
            let destinationFolder: Folder?
            if let destID = destinationFolderID {
                let destRequest = Folder.fetchRequest()
                destRequest.predicate = NSPredicate(format: "id == %@", destID as CVarArg)
                destinationFolder = try context.fetch(destRequest).first
            } else {
                destinationFolder = nil
            }
            
            var itemsToMove: [NSManagedObject] = []
            
            let videoRequest = Video.fetchRequest()
            videoRequest.predicate = NSPredicate(format: "id IN %@", itemIDs)
            itemsToMove.append(contentsOf: try context.fetch(videoRequest))
            
            let folderRequest = Folder.fetchRequest()
            folderRequest.predicate = NSPredicate(format: "id IN %@", itemIDs)
            itemsToMove.append(contentsOf: try context.fetch(folderRequest))

            for item in itemsToMove {
                if let video = item as? Video {
                    video.folder = destinationFolder
                } else if let folder = item as? Folder {
                    folder.parentFolder = destinationFolder
                    folder.isTopLevel = (destinationFolder == nil)
                    folder.dateModified = Date()
                }
            }
            
            if context.hasChanges {
                await libraryManager.save()
                // Notify UI to refresh after successful move
                NotificationCenter.default.post(name: .contentUpdated, object: nil)
            }
            
        } catch {
            errorMessage = "Failed to move items: \(error.localizedDescription)"
            context.rollback()
        }
    }
    
    // MARK: - Sorting
    private func applySorting(_ items: [ContentType]) -> [ContentType] {
        switch currentSortOption {
        case .nameAscending:
            return items.sorted { $0.name.localizedCompare($1.name) == .orderedAscending }
        case .nameDescending:
            return items.sorted { $0.name.localizedCompare($1.name) == .orderedDescending }
        case .dateCreatedNewest:
            return items.sorted { $0.dateCreated > $1.dateCreated }
        case .dateCreatedOldest:
            return items.sorted { $0.dateCreated < $1.dateCreated }
        case .foldersFirst:
            return items.sorted { lhs, rhs in
                if lhs.isFolder != rhs.isFolder {
                    return lhs.isFolder
                }
                return lhs.name.localizedCompare(rhs.name) == .orderedAscending
            }
        }
    }
    
    // MARK: - Folder Name
    @MainActor func folderName(for folderID: UUID?) -> String {
        guard let folderID = folderID,
              let context = libraryManager.viewContext,
              let library = libraryManager.currentLibrary else {
            return "Library"
        }
        
        let request = Folder.fetchRequest()
        request.predicate = NSPredicate(format: "library == %@ AND id == %@", library, folderID as CVarArg)
        
        do {
            if let folder = try context.fetch(request).first {
                return folder.name!
            }
        } catch {}
        
        return "Unknown Folder"
    }
    
    // MARK: - Smart Folder Content
    @MainActor private func getSmartFolderContent(folder: Folder, library: Library, context: NSManagedObjectContext) -> [ContentType] {
        var contentItems: [ContentType] = []
        
        let videoRequest = Video.fetchRequest()
        videoRequest.predicate = NSPredicate(format: "library == %@", library)
        
        switch folder.name {
        case "All Videos":
            videoRequest.sortDescriptors = [NSSortDescriptor(keyPath: \Video.title, ascending: true)]
        case "Recent":
            let thirtyDaysAgo = Calendar.current.date(byAdding: .day, value: -30, to: Date()) ?? Date()
            videoRequest.predicate = NSPredicate(format: "library == %@ AND dateAdded >= %@", library, thirtyDaysAgo as NSDate)
            videoRequest.sortDescriptors = [NSSortDescriptor(keyPath: \Video.dateAdded, ascending: false)]
            videoRequest.fetchLimit = 50
        case "Favorites":
            videoRequest.predicate = NSPredicate(format: "library == %@ AND lastPlayed != NULL", library)
            videoRequest.sortDescriptors = [NSSortDescriptor(keyPath: \Video.lastPlayed, ascending: false)]
            videoRequest.fetchLimit = 50
        default:
            return []
        }
        
        do {
            let videos = try context.fetch(videoRequest)
            for video in videos {
                contentItems.append(.video(video))
            }
        } catch {
            errorMessage = "Failed to load smart folder content: \(error.localizedDescription)"
        }
        
        return contentItems
    }
    
    // MARK: - Renaming
    @MainActor
    func renameItem(id: UUID, to newName: String) async {
        print("ðŸ”„ RENAME: Starting rename of \(id) to '\(newName)'")
        
        guard let context = libraryManager.viewContext,
              let library = libraryManager.currentLibrary else {
            print("âŒ RENAME: No context or library available")
            return
        }
        
        print("ðŸ“‹ RENAME: Context: \(context), Library: \(library.name ?? "Unknown")")
        
        let trimmedName = newName.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmedName.isEmpty else {
            print("âŒ RENAME: Empty name after trimming")
            return
        }
        
        print("ðŸ“ RENAME: Trimmed name: '\(trimmedName)'")
        
        // This is a single transaction, so we can wrap the logic in a do-catch
        do {
            // Try to find a folder with the given ID
            print("ðŸ” RENAME: Searching for folder with ID \(id)")
            let folderRequest = Folder.fetchRequest()
            folderRequest.predicate = NSPredicate(format: "id == %@", id as CVarArg)
            
            if let folder = try context.fetch(folderRequest).first {
                print("ðŸ“ RENAME: Found folder '\(folder.name ?? "nil")' -> '\(trimmedName)'")
                let oldName = folder.name
                folder.name = trimmedName
                folder.dateModified = Date()
                print("ðŸ’¾ RENAME: Set folder.name = '\(folder.name ?? "nil")' (was '\(oldName ?? "nil")')")
                print("ðŸ“Š RENAME: Context hasChanges: \(context.hasChanges)")
                
                // We've made our change, now we must save it through the manager
                print("ðŸ’½ RENAME: Calling libraryManager.save()...")
                await libraryManager.save()
                
                // Verify the change persisted
                print("âœ… RENAME: Save completed. Folder name is now: '\(folder.name ?? "nil")'")
                
                // Force a refresh to see if context is up to date
                context.refresh(folder, mergeChanges: true)
                print("ðŸ”„ RENAME: After refresh, folder name is: '\(folder.name ?? "nil")'")
                
                return // Exit after successful operation
            }
            
            // If no folder was found, try to find a video
            print("ðŸ” RENAME: No folder found, searching for video with ID \(id)")
            let videoRequest = Video.fetchRequest()
            videoRequest.predicate = NSPredicate(format: "id == %@", id as CVarArg)
            
            if let video = try context.fetch(videoRequest).first {
                print("ðŸŽ¥ RENAME: Found video '\(video.title ?? "nil")' -> '\(trimmedName)'")
                let oldTitle = video.title
                video.title = trimmedName
                print("ðŸ’¾ RENAME: Set video.title = '\(video.title ?? "nil")' (was '\(oldTitle ?? "nil")')")
                print("ðŸ“Š RENAME: Context hasChanges: \(context.hasChanges)")
                
                // We've made our change, now we must save it through the manager
                print("ðŸ’½ RENAME: Calling libraryManager.save()...")
                await libraryManager.save()
                
                // Verify the change persisted
                print("âœ… RENAME: Save completed. Video title is now: '\(video.title ?? "nil")'")
                
                return // Exit after successful operation
            }
            
            print("âŒ RENAME: No folder or video found with ID \(id)")
            
        } catch {
            // If any part of the fetch fails, we can handle it here
            print("ðŸ’¥ RENAME: Fetch error: \(error.localizedDescription)")
            errorMessage = "Failed to find item to rename: \(error.localizedDescription)"
            context.rollback() // Rollback any potential bad state
        }
    }
}


================================================================================

File: CoreData/CoreDataStack.swift
// CoreData/CoreDataStack.swift
import Foundation
import CoreData
import AVFoundation

class CoreDataStack {
    private let modelName = "Pangolin"
    private let libraryURL: URL
    
    lazy var persistentContainer: NSPersistentContainer = {
        let container = NSPersistentContainer(name: "Pangolin")
        
        // Configure for library-specific storage
        let storeURL = libraryURL.appendingPathComponent("Library.sqlite")
        let storeDescription = NSPersistentStoreDescription(url: storeURL)
        storeDescription.shouldMigrateStoreAutomatically = true
        storeDescription.shouldInferMappingModelAutomatically = true
        
        // Performance optimizations
        storeDescription.setOption(true as NSNumber, forKey: NSPersistentHistoryTrackingKey)
        storeDescription.setOption(true as NSNumber, forKey: NSPersistentStoreRemoteChangeNotificationPostOptionKey)
        
        container.persistentStoreDescriptions = [storeDescription]
        
        container.loadPersistentStores { (storeDescription, error) in
            if let error = error as NSError? {
                // Log error - in production, handle this more gracefully
                print("Core Data error: \(error), \(error.userInfo)")
                fatalError("Unresolved error \(error), \(error.userInfo)")
            }
        }
        
        container.viewContext.automaticallyMergesChangesFromParent = true
        container.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
        
        return container
    }()
    
    
    var viewContext: NSManagedObjectContext {
        return persistentContainer.viewContext
    }
    
    init(libraryURL: URL) throws {
        self.libraryURL = libraryURL
    }
    
    func saveContext() throws {
        let context = persistentContainer.viewContext
        
        if context.hasChanges {
            try context.save()
        }
    }
    
    func performBackgroundTask<T>(_ block: @escaping (NSManagedObjectContext) throws -> T) async throws -> T {
        return try await withCheckedThrowingContinuation { continuation in
            persistentContainer.performBackgroundTask { context in
                do {
                    let result = try block(context)
                    continuation.resume(returning: result)
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }
}


================================================================================

File: Models/FolderTransfer.swift
//
//  FolderTransfer.swift
//  Pangolin
//
//  Created by Matt Kevan on 17/08/2025.
//

import Foundation
import UniformTypeIdentifiers
import CoreTransferable

struct FolderTransfer: Codable, Transferable {
    let id: UUID
    let name: String
    let parentId: UUID?
    
    init(folder: Folder) {
        self.id = folder.id!
        self.name = folder.name!
        self.parentId = folder.parentFolder?.id
    }
    
    static var transferRepresentation: some TransferRepresentation {
        CodableRepresentation(contentType: .data)
    }
}

================================================================================

File: Models/ContentTransfer.swift
//
//  ContentTransfer.swift
//  Pangolin
//
//  Created by Matt Kevan on 18/08/2025.
//

import Foundation
import CoreTransferable

struct ContentTransfer: Codable, Transferable {
    let itemIDs: [UUID]
    
    static var transferRepresentation: some TransferRepresentation {
        CodableRepresentation(contentType: .data)
    }
}

================================================================================

File: Models/VideoModel.swift
//
//  Video.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//


// Models/VideoModel.swift
import Foundation
import CoreData
import AVFoundation

// MARK: - Core Data Extensions
// Base classes are auto-generated by Core Data from .xcdatamodeld

// MARK: - Video Extensions
extension Video {
    // Computed properties
    var fileURL: URL? {
        guard let library = library,
              let libraryPath = library.url else { return nil }
        return libraryPath.appendingPathComponent("Videos").appendingPathComponent(relativePath!)
    }
    
    var formattedDuration: String {
        let formatter = DateComponentsFormatter()
        formatter.allowedUnits = [.hour, .minute, .second]
        formatter.unitsStyle = .positional
        formatter.zeroFormattingBehavior = .pad
        return formatter.string(from: duration) ?? "00:00"
    }
    
    var hasSubtitles: Bool {
        return (subtitles?.count ?? 0) > 0
    }
    
    var thumbnailURL: URL? {
        guard let library = library,
              let libraryPath = library.url,
              let thumbnailPath = thumbnailPath else { return nil }
        return libraryPath.appendingPathComponent("Thumbnails").appendingPathComponent(thumbnailPath)
    }
}

// MARK: - Folder Extensions
extension Folder {
    // Computed properties
    var childFoldersArray: [Folder] {
        guard let children = childFolders else { return [] }
        return children.compactMap { $0 as? Folder }.sorted { 
            ($0.name ?? "").localizedCompare($1.name ?? "") == .orderedAscending 
        }
    }
    
    var videosArray: [Video] {
        guard let videos = videos else { return [] }
        return videos.compactMap { $0 as? Video }.sorted { 
            ($0.title ?? "").localizedCompare($1.title ?? "") == .orderedAscending 
        }
    }
    
    var itemCount: Int {
        return (childFolders?.count ?? 0) + (videos?.count ?? 0)
    }
    
    var totalVideoCount: Int {
        let directVideos = videos?.count ?? 0
        let childVideos = childFolders?.reduce(into: 0) { result, folder in
            if let folder = folder as? Folder {
                result += folder.totalVideoCount
            }
        } ?? 0
        return directVideos + childVideos
    }
}

// MARK: - Subtitle Extensions
extension Subtitle {
    // Computed properties
    var fileURL: URL? {
        guard let video = video,
              let library = video.library,
              let libraryPath = library.url else { return nil }
        return libraryPath.appendingPathComponent("Subtitles").appendingPathComponent(relativePath!)
    }
    
    var displayName: String {
        if let languageName = languageName {
            return languageName
        } else if let language = language {
            return Locale.current.localizedString(forLanguageCode: language) ?? language
        }
        return fileName!
    }
}

// MARK: - Library Extensions
extension Library {
    // Computed properties
    var url: URL? {
        return URL(fileURLWithPath: libraryPath!)
    }
    
    var videoCount: Int {
        return videos?.count ?? 0
    }
    
    var totalSize: Int64 {
        return videos?.reduce(into: 0) { result, video in
            if let video = video as? Video {
                result += video.fileSize
            }
        } ?? 0
    }
    
    var formattedSize: String {
        let formatter = ByteCountFormatter()
        formatter.countStyle = .file
        return formatter.string(fromByteCount: totalSize)
    }
}

// MARK: - Content Types
enum ContentType: Hashable {
    case folder(Folder)
    case video(Video)
    
    var id: UUID {
        switch self {
        case .folder(let folder): return folder.id!
        case .video(let video): return video.id!
        }
    }
    
    var name: String {
        switch self {
        case .folder(let folder): return folder.name ?? ""
        case .video(let video): return video.title ?? ""
        }
    }
    
    var dateCreated: Date {
        switch self {
        case .folder(let folder): return folder.dateCreated ?? Date()
        case .video(let video): return video.dateAdded ?? Date()
        }
    }
    
    var isFolder: Bool {
        if case .folder = self { return true }
        return false
    }
}

// MARK: - Sorting
enum SortOption: String, CaseIterable {
    case nameAscending = "Name A-Z"
    case nameDescending = "Name Z-A"
    case dateCreatedNewest = "Newest First"
    case dateCreatedOldest = "Oldest First"
    case foldersFirst = "Folders First"
}

enum SubtitleFormat: String, CaseIterable {
    case srt = "srt"
    case vtt = "vtt"
    case ssa = "ssa"
    case ass = "ass"
    
    var displayName: String {
        switch self {
        case .srt: return "SubRip (.srt)"
        case .vtt: return "WebVTT (.vtt)"
        case .ssa, .ass: return "SubStation Alpha (.ssa/.ass)"
        }
    }
}

enum VideoFormat: String, CaseIterable {
    case mp4 = "mp4"
    case mov = "mov"
    case m4v = "m4v"
    case mkv = "mkv"
    case avi = "avi"
    case webm = "webm"
    
    static var supportedExtensions: [String] {
        return VideoFormat.allCases.map { $0.rawValue }
    }
}

// MARK: - Library Descriptor (for multiple libraries)
struct LibraryDescriptor: Codable, Identifiable {
    let id: UUID
    let name: String
    let path: URL
    let lastOpenedDate: Date
    let createdDate: Date
    let version: String
    let thumbnailData: Data?
    let videoCount: Int
    let totalSize: Int64
    
    var isAvailable: Bool {
        return FileManager.default.fileExists(atPath: path.path)
    }
    
    var formattedSize: String {
        let formatter = ByteCountFormatter()
        formatter.countStyle = .file
        return formatter.string(fromByteCount: totalSize)
    }
}



================================================================================

File: Models/HierarchicalContent.swift
//
//  HierarchicalContent.swift
//  Pangolin
//
//  Created by Claude on 19/08/2025.
//

import Foundation
import SwiftUI

// MARK: - Hierarchical Content Model for OutlineGroup/hierarchical List

/// Represents content items in a hierarchical structure for use with SwiftUI OutlineGroup
struct HierarchicalContentItem: Identifiable, Hashable {
    let id: UUID
    let name: String
    let contentType: ContentType
    var children: [HierarchicalContentItem]?
    
    /// Initialize from a folder (with potential children)
    init(folder: Folder) {
        self.id = folder.id!
        self.name = folder.name!
        self.contentType = .folder(folder)
        
        // Combine child folders and videos into hierarchical structure
        var childItems: [HierarchicalContentItem] = []
        
        // Add child folders (which can have their own children)
        for childFolder in folder.childFoldersArray {
            childItems.append(HierarchicalContentItem(folder: childFolder))
        }
        
        // Add videos (leaf nodes - no children)
        for video in folder.videosArray {
            childItems.append(HierarchicalContentItem(video: video))
        }
        
        // Set children to nil if empty (indicates leaf node for OutlineGroup)
        self.children = childItems.isEmpty ? nil : childItems
    }
    
    /// Initialize from a video (leaf node)
    init(video: Video) {
        self.id = video.id!
        self.name = video.title!
        self.contentType = .video(video)
        self.children = nil // Videos are always leaf nodes
    }
    
    /// Whether this item has children (for disclosure triangle display)
    var hasChildren: Bool {
        return children != nil
    }
    
    /// Whether this represents a folder
    var isFolder: Bool {
        if case .folder = contentType { return true }
        return false
    }
    
    /// Get the underlying folder (if this is a folder item)
    var folder: Folder? {
        if case .folder(let folder) = contentType { return folder }
        return nil
    }
    
    /// Get the underlying video (if this is a video item)
    var video: Video? {
        if case .video(let video) = contentType { return video }
        return nil
    }
}

// MARK: - Extensions for SwiftUI Integration

extension HierarchicalContentItem {
    /// Static keypath for children (required by hierarchical List)
    static let childrenKeyPath: WritableKeyPath<HierarchicalContentItem, [HierarchicalContentItem]?> = \.children
}

================================================================================

File: Extensions/View+Extensions.swift
//
//  View+Extensions.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//

// Extensions/View+Extensions.swift
import SwiftUI

extension View {
    func pangolinAlert<T: LocalizedError>(error: Binding<T?>) -> some View {
        self.alert(isPresented: .constant(error.wrappedValue != nil)) {
            Alert(
                title: Text("Error"),
                message: Text(error.wrappedValue?.errorDescription ?? "An unknown error occurred"),
                dismissButton: .default(Text("OK")) {
                    error.wrappedValue = nil
                }
            )
        }
    }
}


================================================================================

File: Extensions/URL+Extensions.swift
//
//  URL+Extensions.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//

// Extensions/URL+Extensions.swift

import Foundation

extension URL {
    var isVideo: Bool {
        let videoExtensions = VideoFormat.supportedExtensions
        return videoExtensions.contains(self.pathExtension.lowercased())
    }
    
    var isSubtitle: Bool {
        let subtitleExtensions = ["srt", "vtt", "ssa", "ass", "sub"]
        return subtitleExtensions.contains(self.pathExtension.lowercased())
    }
    
    var parentDirectory: URL {
        return self.deletingLastPathComponent()
    }
}


================================================================================

File: Utilities/PlatformUtilities.swift
//
//  PlatformUtilities.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//


// Utilities/PlatformUtilities.swift
import Foundation
#if os(macOS)
import AppKit
#else
import UIKit
#endif

struct PlatformUtilities {
    static var isRunningOnMac: Bool {
        #if os(macOS)
        return true
        #else
        return false
        #endif
    }
    
    static var deviceType: String {
        #if os(macOS)
        return "Mac"
        #elseif os(iOS)
        if UIDevice.current.userInterfaceIdiom == .pad {
            return "iPad"
        } else {
            return "iPhone"
        }
        #endif
    }
    
    static func openFilePanel(completion: @escaping (URL?) -> Void) {
        #if os(macOS)
        let panel = NSOpenPanel()
        panel.allowsMultipleSelection = false
        panel.canChooseDirectories = true
        panel.canChooseFiles = false
        panel.message = "Choose a location for your video library"
        
        panel.begin { response in
            if response == .OK {
                completion(panel.url)
            } else {
                completion(nil)
            }
        }
        #else
        // iOS would use document picker
        completion(nil)
        #endif
    }
    
    static func selectVideosForImport(completion: @escaping ([URL]) -> Void) {
        #if os(macOS)
        let panel = NSOpenPanel()
        panel.allowsMultipleSelection = true
        panel.canChooseDirectories = true
        panel.canChooseFiles = true
        panel.message = "Select videos or folders to import"
        panel.allowedContentTypes = [.movie, .video]
        
        panel.begin { response in
            if response == .OK {
                completion(panel.urls)
            } else {
                completion([])
            }
        }
        #else
        // iOS document picker implementation
        completion([])
        #endif
    }
}


================================================================================

File: Utilities/NotificationNames.swift
//
//  NotificationNames.swift
//  Pangolin
//
//  Created by Matt Kevan on 18/08/2025.
//

import Foundation

extension Notification.Name {
    /// Notification posted when the content of a folder or library has been updated (e.g., after an import).
    static let contentUpdated = Notification.Name("com.pangolin.contentUpdated")
}


================================================================================

File: Import/VideoImporter.swift
//
//  VideoImporter.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//


// Import/VideoImporter.swift
import Foundation
import Combine
import AVFoundation
import CoreData

class VideoImporter: ObservableObject {
    @Published var isImporting = false
    @Published var currentFile = ""
    @Published var progress: Double = 0
    @Published var totalFiles = 0
    @Published var processedFiles = 0
    @Published var errors: [ImportError] = []
    @Published var importedVideos: [Video] = []
    
    private let fileSystemManager = FileSystemManager.shared
    private let subtitleMatcher = SubtitleMatcher()
    private var cancellables = Set<AnyCancellable>()
    
    struct ImportError: Identifiable {
        let id = UUID()
        let fileName: String
        let error: Error
    }
    
    func importFiles(_ urls: [URL], to library: Library, context: NSManagedObjectContext) async {
        await MainActor.run {
            isImporting = true
            errors = []
            importedVideos = []
            progress = 0
        }
        
        // Analyze import structure to create folders
        let folderStructure = analyzeFolderStructure(from: urls)
        let createdFolders = await createFoldersFromStructure(folderStructure, library: library, context: context)
        
        // Gather all video files
        let videoFiles = gatherVideoFiles(from: urls)
        await MainActor.run {
            totalFiles = videoFiles.count
        }
        
        // Import each file
        for (index, fileURL) in videoFiles.enumerated() {
            await MainActor.run {
                currentFile = fileURL.lastPathComponent
                processedFiles = index
                progress = Double(index) / Double(videoFiles.count)
            }
            
            do {
                // Import video
                let video = try await fileSystemManager.importVideo(
                    from: fileURL,
                    to: library,
                    context: context,
                    copyFile: library.copyFilesOnImport
                )
                
                // Add video to appropriate folder based on its original folder path
                assignVideoToFolder(video: video, originalPath: fileURL, createdFolders: createdFolders)
                
                // Find and import matching subtitles
                if library.autoMatchSubtitles {
                    let subtitles = subtitleMatcher.findMatchingSubtitles(
                        for: fileURL,
                        in: fileURL.deletingLastPathComponent()
                    )
                    
                    for subtitleURL in subtitles {
                        _ = try? await importSubtitle(
                            from: subtitleURL,
                            for: video,
                            to: library,
                            context: context
                        )
                    }
                }
                
                await MainActor.run {
                    importedVideos.append(video)
                }
                
            } catch {
                await MainActor.run {
                    errors.append(ImportError(
                        fileName: fileURL.lastPathComponent,
                        error: error
                    ))
                }
            }
        }
        
        // Save context
        do {
            try context.save()
        } catch {
            await MainActor.run {
                errors.append(ImportError(
                    fileName: "Core Data",
                    error: error
                ))
            }
        }
        
        await MainActor.run {
            isImporting = false
            progress = 1.0
            processedFiles = totalFiles
        }
    }
    
    private func gatherVideoFiles(from urls: [URL]) -> [URL] {
        var videoFiles: [URL] = []
        
        for url in urls {
            var isDirectory: ObjCBool = false
            if FileManager.default.fileExists(atPath: url.path, isDirectory: &isDirectory) {
                if isDirectory.boolValue {
                    // Recursively find video files in directory
                    videoFiles.append(contentsOf: findVideoFiles(in: url))
                } else if isVideoFile(url) {
                    videoFiles.append(url)
                }
            }
        }
        
        return videoFiles
    }
    
    private func findVideoFiles(in directory: URL) -> [URL] {
        var videoFiles: [URL] = []
        
        if let enumerator = FileManager.default.enumerator(
            at: directory,
            includingPropertiesForKeys: [.isRegularFileKey],
            options: [.skipsHiddenFiles]
        ) {
            for case let fileURL as URL in enumerator {
                if isVideoFile(fileURL) {
                    videoFiles.append(fileURL)
                }
            }
        }
        
        return videoFiles
    }
    
    private func isVideoFile(_ url: URL) -> Bool {
        let videoExtensions = VideoFormat.supportedExtensions
        return videoExtensions.contains(url.pathExtension.lowercased())
    }
    
    private func importSubtitle(from url: URL, for video: Video, to library: Library, context: NSManagedObjectContext) async throws -> Subtitle {
        guard let libraryURL = library.url else {
            throw FileSystemError.invalidLibraryPath
        }
        
        // Create subtitle directory
        let videoDir = URL(fileURLWithPath: video.relativePath!).deletingLastPathComponent().path
        let subtitlesDir = libraryURL.appendingPathComponent("Subtitles")
            .appendingPathComponent(videoDir)
        
        try FileManager.default.createDirectory(
            at: subtitlesDir,
            withIntermediateDirectories: true
        )
        
        // Copy subtitle file
        let destinationURL = subtitlesDir.appendingPathComponent(url.lastPathComponent)
        try FileManager.default.copyItem(at: url, to: destinationURL)
        
        // Create subtitle entity in Core Data context using entity description
        guard let subtitleEntityDescription = context.persistentStoreCoordinator?.managedObjectModel.entitiesByName["Subtitle"] else {
            throw FileSystemError.importFailed("Could not find Subtitle entity description")
        }
        
        let subtitle = Subtitle(entity: subtitleEntityDescription, insertInto: context)
        subtitle.id = UUID()
        subtitle.fileName = url.lastPathComponent
        subtitle.relativePath = destinationURL.path
            .replacingOccurrences(of: libraryURL.path + "/Subtitles/", with: "")
        subtitle.format = url.pathExtension
        subtitle.encoding = "UTF-8"
        subtitle.isDefault = false
        subtitle.isForced = false
        subtitle.video = video
        
        // Detect language from filename
        let languageInfo = subtitleMatcher.detectLanguage(from: url.lastPathComponent)
        subtitle.language = languageInfo.code
        subtitle.languageName = languageInfo.name
        
        return subtitle
    }
    
    // MARK: - Folder Structure Analysis
    
    struct FolderNode {
        let url: URL
        let name: String
        var children: [FolderNode] = []
        var videoFiles: [URL] = []
        let isRoot: Bool
        
        init(url: URL, name: String, isRoot: Bool = false) {
            self.url = url
            self.name = name
            self.isRoot = isRoot
        }
    }
    
    private func analyzeFolderStructure(from urls: [URL]) -> [FolderNode] {
        var rootNodes: [FolderNode] = []
        
        for url in urls {
            var isDirectory: ObjCBool = false
            if FileManager.default.fileExists(atPath: url.path, isDirectory: &isDirectory) {
                if isDirectory.boolValue {
                    // This is a folder import
                    let folderNode = buildFolderTree(from: url)
                    rootNodes.append(folderNode)
                } else if isVideoFile(url) {
                    // Individual file import
                    continue
                }
            }
        }
        
        return rootNodes
    }
    
    private func buildFolderTree(from folderURL: URL) -> FolderNode {
        let folderName = folderURL.lastPathComponent
        var node = FolderNode(url: folderURL, name: folderName, isRoot: true)
        
        do {
            let contents = try FileManager.default.contentsOfDirectory(
                at: folderURL,
                includingPropertiesForKeys: [.isDirectoryKey, .isRegularFileKey],
                options: [.skipsHiddenFiles]
            )
            
            for item in contents {
                var isDirectory: ObjCBool = false
                if FileManager.default.fileExists(atPath: item.path, isDirectory: &isDirectory) {
                    if isDirectory.boolValue {
                        // Subfolder - recursively build tree
                        let childNode = buildFolderTree(from: item)
                        if !childNode.videoFiles.isEmpty || !childNode.children.isEmpty {
                            node.children.append(childNode)
                        }
                    } else if isVideoFile(item) {
                        // Video file
                        node.videoFiles.append(item)
                    }
                }
            }
        } catch {
            print("Error reading folder contents: \(error)")
        }
        
        return node
    }
    
    private func createFoldersFromStructure(_ folderNodes: [FolderNode], library: Library, context: NSManagedObjectContext) async -> [String: Folder] {
        var createdFolders: [String: Folder] = [:]
        
        for folderNode in folderNodes {
            if let folder = await createFolderFromNode(folderNode, parent: nil, library: library, context: context) {
                createdFolders[folderNode.url.path] = folder
                await addChildFolders(for: folderNode, parentFolder: folder, library: library, context: context, createdFolders: &createdFolders)
            }
        }
        
        return createdFolders
    }
    
    private func createFolderFromNode(_ node: FolderNode, parent: Folder?, library: Library, context: NSManagedObjectContext) async -> Folder? {
        // Only create folder if there are videos in this folder or subfolders
        guard !node.videoFiles.isEmpty || !node.children.isEmpty else { 
            return nil 
        }
        
        guard let folderEntityDescription = context.persistentStoreCoordinator?.managedObjectModel.entitiesByName["Folder"] else {
            print("Could not find Folder entity description")
            return nil
        }
        
        let folder = Folder(entity: folderEntityDescription, insertInto: context)
        folder.id = UUID()
        folder.name = node.name
        folder.dateCreated = Date()
        folder.dateModified = Date()
        folder.library = library
        folder.parentFolder = parent
        folder.isTopLevel = (parent == nil)
        
        return folder
    }
    
    private func addChildFolders(for node: FolderNode, parentFolder: Folder, library: Library, context: NSManagedObjectContext, createdFolders: inout [String: Folder]) async {
        for childNode in node.children {
            if let childFolder = await createFolderFromNode(childNode, parent: parentFolder, library: library, context: context) {
                createdFolders[childNode.url.path] = childFolder
                await addChildFolders(for: childNode, parentFolder: childFolder, library: library, context: context, createdFolders: &createdFolders)
            }
        }
    }
    
    private func assignVideoToFolder(video: Video, originalPath: URL, createdFolders: [String: Folder]) {
        // Find the folder that corresponds to the video's original folder
        let videoDirectory = originalPath.deletingLastPathComponent()
        
        // Look for a folder that matches this directory or any parent directory
        for (folderPath, folder) in createdFolders {
            let folderURL = URL(fileURLWithPath: folderPath)
            
            // Check if the video's directory is the same as or a subdirectory of the folder's directory
            if videoDirectory.path.hasPrefix(folderURL.path) {
                // Assign video to this folder
                video.folder = folder
                break
            }
        }
    }
}

================================================================================

File: Import/VideoDropDelegate.swift
//
//  VideoDropDelegate.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//


// Import/DragDropHandler.swift
import SwiftUI
import UniformTypeIdentifiers

struct VideoDropDelegate: DropDelegate {
    @Binding var isTargeted: Bool
    let library: Library
    let importer: VideoImporter
    @EnvironmentObject var libraryManager: LibraryManager
    
    func validateDrop(info: DropInfo) -> Bool {
        return info.hasItemsConforming(to: [.fileURL])
    }
    
    func dropEntered(info: DropInfo) {
        isTargeted = true
    }
    
    func dropExited(info: DropInfo) {
        isTargeted = false
    }
    
    func performDrop(info: DropInfo) -> Bool {
        isTargeted = false
        
        let providers = info.itemProviders(for: [.fileURL])
        var urls: [URL] = []
        
        let group = DispatchGroup()
        
        for provider in providers {
            group.enter()
            provider.loadItem(forTypeIdentifier: UTType.fileURL.identifier, options: nil) { item, error in
                if let data = item as? Data,
                   let url = URL(dataRepresentation: data, relativeTo: nil) {
                    urls.append(url)
                }
                group.leave()
            }
        }
        
        group.notify(queue: .main) {
            Task {
                if let context = libraryManager.viewContext {
                    await importer.importFiles(urls, to: library, context: context)
                }
            }
        }
        
        return true
    }
}

================================================================================

File: Import/SubtitleMatcher.swift
//
//  SubtitleMatcher.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//


// Import/SubtitleMatcher.swift
import Foundation

class SubtitleMatcher {
    private let languagePatterns: [(pattern: String, code: String, name: String)] = [
        (".en.", "en", "English"),
        (".eng.", "en", "English"),
        ("_en.", "en", "English"),
        ("_eng.", "en", "English"),
        ("[English]", "en", "English"),
        (".fr.", "fr", "French"),
        (".fra.", "fr", "French"),
        ("_fr.", "fr", "French"),
        ("[French]", "fr", "French"),
        (".es.", "es", "Spanish"),
        (".spa.", "es", "Spanish"),
        ("_es.", "es", "Spanish"),
        ("[Spanish]", "es", "Spanish"),
        (".de.", "de", "German"),
        (".deu.", "de", "German"),
        ("_de.", "de", "German"),
        ("[German]", "de", "German"),
        (".it.", "it", "Italian"),
        (".ita.", "it", "Italian"),
        ("_it.", "it", "Italian"),
        ("[Italian]", "it", "Italian"),
        (".ja.", "ja", "Japanese"),
        (".jpn.", "ja", "Japanese"),
        ("_ja.", "ja", "Japanese"),
        ("[Japanese]", "ja", "Japanese"),
        (".zh.", "zh", "Chinese"),
        (".chi.", "zh", "Chinese"),
        ("_zh.", "zh", "Chinese"),
        ("[Chinese]", "zh", "Chinese"),
    ]
    
    func findMatchingSubtitles(for videoURL: URL, in directory: URL) -> [URL] {
        let videoName = videoURL.deletingPathExtension().lastPathComponent
        var subtitles: [URL] = []
        
        do {
            let files = try FileManager.default.contentsOfDirectory(
                at: directory,
                includingPropertiesForKeys: nil
            )
            
            for file in files {
                if isSubtitleFile(file) {
                    let subtitleName = file.deletingPathExtension().lastPathComponent
                    
                    // Check various matching patterns
                    if matchesVideo(subtitleName: subtitleName, videoName: videoName) {
                        subtitles.append(file)
                    }
                }
            }
        } catch {
            print("Error finding subtitles: \(error)")
        }
        
        return subtitles
    }
    
    func detectLanguage(from filename: String) -> (code: String?, name: String?) {
        let lowercased = filename.lowercased()
        
        for (pattern, code, name) in languagePatterns {
            if lowercased.contains(pattern.lowercased()) {
                return (code, name)
            }
        }
        
        // Try to extract ISO 639-1 codes (2 letters)
        let components = filename.components(separatedBy: CharacterSet(charactersIn: "._-[]"))
        for component in components {
            if component.count == 2 {
                if let languageName = Locale.current.localizedString(forLanguageCode: component) {
                    return (component, languageName)
                }
            }
        }
        
        return (nil, nil)
    }
    
    private func isSubtitleFile(_ url: URL) -> Bool {
        let subtitleExtensions = ["srt", "vtt", "ssa", "ass", "sub"]
        return subtitleExtensions.contains(url.pathExtension.lowercased())
    }
    
    private func matchesVideo(subtitleName: String, videoName: String) -> Bool {
        // Exact match
        if subtitleName == videoName {
            return true
        }
        
        // Prefix match (allows for language codes)
        if subtitleName.hasPrefix(videoName) {
            return true
        }
        
        // Fuzzy matching with similarity threshold
        let similarity = calculateSimilarity(subtitleName, videoName)
        if similarity > 0.8 {
            return true
        }
        
        return false
    }
    
    private func calculateSimilarity(_ str1: String, _ str2: String) -> Double {
        // Simple Jaccard similarity
        let set1 = Set(str1.lowercased())
        let set2 = Set(str2.lowercased())
        
        let intersection = set1.intersection(set2).count
        let union = set1.union(set2).count
        
        return union > 0 ? Double(intersection) / Double(union) : 0
    }
}

================================================================================

File: Views/DetailView.swift
//
//  DetailView.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//


import SwiftUI
import AVKit

struct DetailView: View {
    let video: Video?
    @StateObject private var playerViewModel = VideoPlayerViewModel()
    
    // CORRECTED: Use platform-specific color APIs.
    private var controlsBackgroundColor: Color {
        #if os(macOS)
        return Color(NSColor.controlBackgroundColor)
        #else
        return Color(.systemBackground)
        #endif
    }
    
    private var windowBackgroundColor: Color {
        #if os(macOS)
        return Color(NSColor.windowBackgroundColor)
        #else
        return Color(.secondarySystemBackground)
        #endif
    }
    
    var body: some View {
        GeometryReader { geometry in
            if let video = video {
                VStack(spacing: 0) {
                    // Video Player with Poster Frame
                    VideoPlayerWithPosterView(video: video, viewModel: playerViewModel)
                        .frame(height: geometry.size.height * 0.67)
                    
                    // Controls Bar
                    VideoControlsBar(viewModel: playerViewModel)
                        .frame(height: 60)
                        .background(controlsBackgroundColor)
                    
                    // Bottom area
                    VideoInfoView(video: video)
                        .frame(maxHeight: .infinity)
                        .background(windowBackgroundColor)
                }
            } else {
                ContentUnavailableView(
                    "Select a Video",
                    systemImage: "play.rectangle",
                    description: Text("Choose a video from the list to start watching")
                )
            }
        }
    }
}


================================================================================

File: Views/VideoPlayerView.swift
// Views/VideoPlayerView.swift
import SwiftUI
import AVKit

#if os(macOS)
struct VideoPlayerView: NSViewRepresentable {
    @ObservedObject var viewModel: VideoPlayerViewModel
    
    func makeNSView(context: Context) -> AVPlayerView {
        let playerView = AVPlayerView()
        playerView.player = viewModel.player
        playerView.controlsStyle = .none // We'll use custom controls
        playerView.showsFullScreenToggleButton = true
        return playerView
    }
    
    func updateNSView(_ nsView: AVPlayerView, context: Context) {
        nsView.player = viewModel.player
    }
}
#elseif os(iOS)
struct VideoPlayerView: UIViewRepresentable {
    @ObservedObject var viewModel: VideoPlayerViewModel
    
    func makeUIView(context: Context) -> UIView {
        // We need to wrap the AVPlayerViewController to use its view
        let controller = AVPlayerViewController()
        controller.player = viewModel.player
        controller.showsPlaybackControls = false // Custom controls
        
        // This makes sure the view from the controller is returned
        return controller.view
    }
    
    func updateUIView(_ uiView: UIView, context: Context) {
        // This is tricky because we don't have direct access to the controller.
        // For simple player updates, swapping the player on the viewModel should be sufficient.
        // More complex updates might require a Coordinator.
    }
}
#endif


================================================================================

File: Views/SidebarView.swift
//
//  SidebarView.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//

import SwiftUI
import CoreData

struct SidebarView: View {
    @EnvironmentObject private var store: FolderNavigationStore
    @Environment(\.managedObjectContext) private var viewContext
    
    @State private var isShowingCreateFolder = false
    @State private var editingFolder: Folder?
    @State private var renamingFolderID: UUID? = nil
    @FocusState private var focusedField: UUID?
    
    // Use @FetchRequest for automatic Core Data change observation
    @FetchRequest(
        sortDescriptors: [NSSortDescriptor(keyPath: \Folder.name, ascending: true)],
        predicate: NSPredicate(format: "isTopLevel == YES AND isSmartFolder == YES")
    ) private var allSystemFolders: FetchedResults<Folder>
    
    @FetchRequest(
        sortDescriptors: [NSSortDescriptor(keyPath: \Folder.name, ascending: true)],
        predicate: NSPredicate(format: "isTopLevel == YES AND isSmartFolder == NO")
    ) private var allUserFolders: FetchedResults<Folder>
    
    // Filter by current library - these will update automatically when @FetchRequest data changes
    private var systemFolders: [Folder] {
        // Use the store's systemFolders method to get the current library filtering
        // This will trigger when @FetchRequest data changes due to the allSystemFolders dependency
        let _ = allSystemFolders // Create dependency on @FetchRequest
        return store.systemFolders()
    }
    
    private var userFolders: [Folder] {
        // Use the store's userFolders method to get the current library filtering
        // This will trigger when @FetchRequest data changes due to the allUserFolders dependency
        let _ = allUserFolders // Create dependency on @FetchRequest
        return store.userFolders()
    }
    
    var body: some View {
        List(selection: $store.selectedTopLevelFolder) {
            // System folders (smart folders)
            Section("Pangolin") {
                ForEach(systemFolders) { folder in
                    FolderRowView(
                        folder: folder, 
                        showContextMenu: false, 
                        editingFolder: $editingFolder,
                        renamingFolderID: $renamingFolderID,
                        focusedField: $focusedField,
                        onDelete: {}
                    )
                    .tag(folder)
                }
            }
            
            // User folders
            Section("Library") {
                ForEach(userFolders) { folder in
                    FolderRowView(
                        folder: folder, 
                        showContextMenu: true, 
                        editingFolder: $editingFolder,
                        renamingFolderID: $renamingFolderID,
                        focusedField: $focusedField,
                        onDelete: { deleteFolder(folder) }
                    )
                    .tag(folder)
                }
            }
        }
        .onChange(of: store.selectedTopLevelFolder) { _, newFolder in
            // Defer the state update to avoid "Publishing changes from within view updates" error
            Task { @MainActor in
                if let newFolder {
                    store.currentFolderID = newFolder.id
                }
            }
        }
        #if os(macOS)
        .listStyle(SidebarListStyle())
        #else
        .listStyle(InsetGroupedListStyle())
        #endif
        .toolbar {
            ToolbarItem(placement: .automatic) {
                Button(action: { isShowingCreateFolder = true }) {
                    Label("Add Folder", systemImage: "plus")
                }
            }
        }
        .sheet(isPresented: $isShowingCreateFolder) {
            CreateFolderView(parentFolderID: nil)
        }
        .onKeyPress { keyPress in
            if keyPress.key == .return,
               let selected = store.selectedTopLevelFolder,
               !selected.isSmartFolder { // Only allow renaming for user folders
                renamingFolderID = selected.id
                Task { @MainActor in
                    try? await Task.sleep(nanoseconds: 100_000_000) // 0.1s delay
                    focusedField = selected.id
                }
                return .handled
            }
            return .ignored
        }
        // Handle focus loss to end rename mode
        .onChange(of: focusedField) { _, newValue in
            if newValue == nil {
                renamingFolderID = nil
            }
        }
        // @FetchRequest automatically observes Core Data changes, no manual refresh needed
    }
    
    private func deleteFolder(_ folder: Folder) {
        // TODO: Implement folder deletion with confirmation
        print("Deleting folder: \(folder.name!)")
    }
}

// MARK: - Folder Row View
private struct FolderRowView: View {
    @EnvironmentObject private var store: FolderNavigationStore
    let folder: Folder
    let showContextMenu: Bool
    @Binding var editingFolder: Folder?
    @Binding var renamingFolderID: UUID?
    @FocusState.Binding var focusedField: UUID?
    let onDelete: () -> Void
    
    @State private var isDropTargeted = false
    @State private var editedName: String = ""
    @State private var shouldCommitOnDisappear = false

    var body: some View {
        Label {
            nameEditorView
        } icon: {
            Image(systemName: folder.isSmartFolder ? getSmartFolderIcon(folder.name!) : "folder")
                .foregroundColor(folder.isSmartFolder ? .blue : .orange)
        }
        .onTapGesture {
            handleSlowClickRename()
        }
        .contextMenu {
            if showContextMenu {
                Button("Rename") {
                    renamingFolderID = folder.id
                    Task { @MainActor in
                        try? await Task.sleep(nanoseconds: 100_000_000) // 0.1s delay
                        focusedField = folder.id
                    }
                }
                Button("Delete", role: .destructive) {
                    onDelete()
                }
            }
        }
        .onDrop(of: [.data], isTargeted: $isDropTargeted) { providers in
            guard !folder.isSmartFolder else { return false }
            
            if let provider = providers.first {
                let _ = provider.loadDataRepresentation(for: .data) { data, _ in
                    if let data = data,
                       let transfer = try? JSONDecoder().decode(ContentTransfer.self, from: data) {
                        Task { @MainActor in
                            await store.moveItems(Set(transfer.itemIDs), to: folder.id)
                        }
                    }
                }
                return true
            }
            return false
        }
        .overlay {
            // Provide visual feedback when a drop is targeted
            if isDropTargeted && !folder.isSmartFolder {
                RoundedRectangle(cornerRadius: 6)
                    .stroke(Color.accentColor, lineWidth: 2)
                    #if os(macOS)
                    .padding(-4)
                    #endif
            }
        }
    }
    
    /// A view that conditionally shows a `Text` label or a `TextField` for renaming.
    @ViewBuilder
    private var nameEditorView: some View {
        if renamingFolderID == folder.id {
            TextField("Name", text: $editedName)
                .textFieldStyle(.plain)
                .focused($focusedField, equals: folder.id)
                .onAppear {
                    editedName = folder.name!
                    shouldCommitOnDisappear = true
                }
                .onSubmit {
                    // Commit the rename when the user presses Return/Enter
                    shouldCommitOnDisappear = false // Prevent double commit
                    commitRename()
                }
                .onKeyPress { keyPress in
                    if keyPress.key == .escape {
                        // Cancel the rename when the user presses Escape
                        shouldCommitOnDisappear = false
                        cancelRename()
                        return .handled
                    }
                    return .ignored
                }
                .onChange(of: focusedField) { oldValue, newValue in
                    // Detect when THIS TextField loses focus
                    if oldValue == folder.id && newValue != folder.id && shouldCommitOnDisappear {
                        print("ðŸŽ¯ FOCUS: TextField \(folder.id) lost focus (old: \(oldValue?.uuidString ?? "nil") -> new: \(newValue?.uuidString ?? "nil")), committing rename")
                        commitRename()
                    }
                }
        } else {
            Text(folder.name!)
        }
    }
    
    /// Commits the new name to the data store.
    private func commitRename() {
        print("ðŸ·ï¸ SIDEBAR: commitRename called for '\(folder.name!)' -> '\(editedName)'")
        shouldCommitOnDisappear = false // Prevent further commits
        let trimmedName = editedName.trimmingCharacters(in: .whitespacesAndNewlines)
        if !trimmedName.isEmpty && trimmedName != folder.name! {
            print("ðŸš€ SIDEBAR: About to call store.renameItem")
            Task {
                await store.renameItem(id: folder.id!, to: trimmedName)
                await MainActor.run {
                    renamingFolderID = nil
                    focusedField = nil
                }
            }
        } else {
            // Cancel if no change
            renamingFolderID = nil
            focusedField = nil
        }
    }

    /// Cancels the renaming process.
    private func cancelRename() {
        editedName = folder.name! // Reset to original name
        shouldCommitOnDisappear = false
        renamingFolderID = nil
        focusedField = nil
    }
    
    /// Handles slow-click rename for user folders only
    private func handleSlowClickRename() {
        // Only allow renaming for user folders (not system folders) and only if this folder is already selected
        guard !folder.isSmartFolder, 
              showContextMenu, 
              store.selectedTopLevelFolder?.id == folder.id,
              renamingFolderID == nil else { 
            return 
        }
        
        // Start renaming
        editedName = folder.name!
        renamingFolderID = folder.id
        Task { @MainActor in
            try? await Task.sleep(nanoseconds: 100_000_000) // 0.1s delay
            focusedField = folder.id
        }
    }
    
    private func getSmartFolderIcon(_ name: String) -> String {
        switch name {
        case "All Videos": return "video.fill"
        case "Recent": return "clock.fill"
        case "Favorites": return "heart.fill"
        default: return "folder"
        }
    }
}


================================================================================

File: Views/ImportProgressView.swift
//
//  ImportProgressView.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//


// Views/ImportProgressView.swift
import SwiftUI

struct ImportProgressView: View {
    @ObservedObject var importer: VideoImporter
    @Environment(\.dismiss) var dismiss
    
    var body: some View {
        VStack(spacing: 20) {
            Text("Importing Videos")
                .font(.headline)
            
            if importer.totalFiles > 0 {
                Text("\(importer.processedFiles) of \(importer.totalFiles) files")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
            
            if !importer.currentFile.isEmpty {
                Text(importer.currentFile)
                    .font(.caption)
                    .lineLimit(1)
                    .truncationMode(.middle)
            }
            
            ProgressView(value: importer.progress)
                .progressViewStyle(.linear)
                .frame(width: 300)
            
            if !importer.errors.isEmpty {
                VStack(alignment: .leading) {
                    Text("Errors:")
                        .font(.caption)
                        .fontWeight(.semibold)
                    
                    ScrollView {
                        VStack(alignment: .leading) {
                            ForEach(importer.errors) { error in
                                Text("â€¢ \(error.fileName): \(error.error.localizedDescription)")
                                    .font(.caption)
                                    .foregroundColor(.red)
                            }
                        }
                    }
                    .frame(maxHeight: 100)
                }
            }
            
            if !importer.isImporting {
                HStack {
                    if !importer.errors.isEmpty {
                        Text("\(importer.importedVideos.count) videos imported successfully")
                            .font(.caption)
                            .foregroundColor(.green)
                    }
                    
                    Spacer()
                    
                    Button("Done") {
                        dismiss()
                    }
                    .keyboardShortcut(.defaultAction)
                }
            }
        }
        .padding()
        .frame(width: 400)
        .frame(minHeight: 200)
    }
}

================================================================================

File: Views/HierarchicalContentView.swift
//
//  HierarchicalContentView.swift  
//  Pangolin
//
//  Created by Claude on 19/08/2025.
//

import SwiftUI
import CoreData

/// A Finder-like hierarchical content view using SwiftUI's native OutlineGroup/hierarchical List
struct HierarchicalContentView: View {
    @EnvironmentObject private var store: FolderNavigationStore
    @EnvironmentObject var libraryManager: LibraryManager
    let searchText: String
    
    @State private var selectedItems: Set<UUID> = []
    @State private var showingImportPicker = false
    @State private var showingImportProgress = false
    @State private var showingCreateFolder = false
    @State private var isGeneratingThumbnails = false
    @StateObject private var videoImporter = VideoImporter()
    
    // Renaming state
    @State private var renamingItemID: UUID? = nil
    @FocusState private var focusedField: UUID?
    @State private var editedName: String = ""
    
    private var hierarchicalContent: [HierarchicalContentItem] {
        let allContent = store.hierarchicalContent(for: store.currentFolderID)
        
        if searchText.isEmpty {
            return allContent
        } else {
            // Filter hierarchical content by search text
            return filterHierarchicalContent(allContent, searchText: searchText)
        }
    }
    
    var body: some View {
        contentView
        .toolbar {
            toolbarContent
        }
        .fileImporter(isPresented: $showingImportPicker, allowedContentTypes: [.movie, .video, .folder], allowsMultipleSelection: true) { result in
            switch result {
            case .success(let urls):
                if let library = libraryManager.currentLibrary, let context = libraryManager.viewContext {
                    showingImportProgress = true
                    Task {
                        await videoImporter.importFiles(urls, to: library, context: context)
                    }
                }
            case .failure(let error):
                print("Error importing files: \(error)")
            }
        }
        .sheet(isPresented: $showingImportProgress) {
            ImportProgressView(importer: videoImporter)
        }
        .sheet(isPresented: $showingCreateFolder) {
            CreateFolderView(parentFolderID: store.currentFolderID)
        }
        .onChange(of: videoImporter.isImporting) { _, isImporting in
            if !isImporting && showingImportProgress {
                NotificationCenter.default.post(name: .contentUpdated, object: nil)
            }
        }
        .onReceive(NotificationCenter.default.publisher(for: .contentUpdated)) { _ in
            // Core Data change notifications now handled automatically
        }
        .onKeyPress { keyPress in
            // Return key triggers rename on single selected item
            guard keyPress.key == .return, selectedItems.count == 1,
                  let selectedID = selectedItems.first,
                  let selectedItem = findItem(withID: selectedID, in: hierarchicalContent) else {
                return .ignored
            }
            
            startRenaming(selectedItem)
            return .handled
        }
    }
    
    @ViewBuilder
    private var contentView: some View {
        if hierarchicalContent.isEmpty {
            ContentUnavailableView(
                "No Content", 
                systemImage: "folder.badge.questionmark", 
                description: Text(store.currentFolderID == nil ? "Import videos to get started" : "This folder is empty")
            )
        } else {
            hierarchicalListView
        }
    }
    
    @ViewBuilder 
    private var hierarchicalListView: some View {
        List(hierarchicalContent, id: \.id, children: \.children, selection: $selectedItems) { item in
            HierarchicalContentRowView(
                item: item,
                renamingItemID: $renamingItemID,
                focusedField: $focusedField,
                editedName: $editedName,
                selectedItems: $selectedItems
            )
            .contentShape(Rectangle()) // Ensure full row is clickable
        }
        .onChange(of: selectedItems) { _, newSelection in
            handleSelectionChange(newSelection)
        }
    }
    
    @ToolbarContentBuilder
    private var toolbarContent: some ToolbarContent {
        #if os(macOS)
        ToolbarItemGroup {
            macOSToolbarButtons
        }
        
        // Show selection count when items are selected
        ToolbarItem(placement: .status) {
            if !selectedItems.isEmpty {
                Text("\(selectedItems.count) selected")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
        #else
        ToolbarItemGroup(placement: .navigationBarTrailing) {
            iOSMenu
        }
        #endif
    }
    
    @ViewBuilder
    private var macOSToolbarButtons: some View {
        Button("Create Folder") { showingCreateFolder = true }
        Button("Import Videos") { showingImportPicker = true }
            .disabled(libraryManager.currentLibrary == nil)
        
        if !videosWithoutThumbnails.isEmpty {
            Button(isGeneratingThumbnails ? "Generating..." : "Generate Thumbnails") {
                generateThumbnailsForVideos()
            }
            .disabled(isGeneratingThumbnails)
        }
        
        Menu {
            ForEach(SortOption.allCases, id: \.self) { option in
                Button(option.rawValue) { store.currentSortOption = option }
            }
        } label: {
            Label("Sort", systemImage: "arrow.up.arrow.down")
        }
    }
    
    @ViewBuilder
    private var iOSMenu: some View {
        Menu {
            Button { showingImportPicker = true } label: { 
                Label("Import Videos", systemImage: "square.and.arrow.down") 
            }
            .disabled(libraryManager.currentLibrary == nil)
            Button { showingCreateFolder = true } label: { 
                Label("New Folder", systemImage: "folder.badge.plus") 
            }
        } label: {
            Image(systemName: "ellipsis.circle")
        }
    }
    
    // MARK: - Helper Functions
    
    private var videosWithoutThumbnails: [Video] {
        return getAllVideos(from: hierarchicalContent).filter { $0.thumbnailPath == nil }
    }
    
    private func getAllVideos(from items: [HierarchicalContentItem]) -> [Video] {
        var videos: [Video] = []
        for item in items {
            if let video = item.video {
                videos.append(video)
            }
            if let children = item.children {
                videos.append(contentsOf: getAllVideos(from: children))
            }
        }
        return videos
    }
    
    private func findItem(withID id: UUID, in items: [HierarchicalContentItem]) -> HierarchicalContentItem? {
        for item in items {
            if item.id == id {
                return item
            }
            if let children = item.children,
               let found = findItem(withID: id, in: children) {
                return found
            }
        }
        return nil
    }
    
    private func filterHierarchicalContent(_ items: [HierarchicalContentItem], searchText: String) -> [HierarchicalContentItem] {
        return items.compactMap { item in
            let nameMatches = item.name.localizedCaseInsensitiveContains(searchText)
            let filteredChildren = item.children?.compactMap { child in
                filterHierarchicalContent([child], searchText: searchText).first
            }
            
            if nameMatches || (filteredChildren?.isEmpty == false) {
                var filteredItem = item
                filteredItem.children = filteredChildren
                return filteredItem
            }
            return nil
        }
    }
    
    private func handleSelectionChange(_ newSelection: Set<UUID>) {
        // Defer the state update to avoid "Publishing changes from within view updates" error
        Task { @MainActor in
            // When a single video is selected, set it for detail view
            if newSelection.count == 1, let selectedID = newSelection.first {
                if let selectedItem = findItem(withID: selectedID, in: hierarchicalContent),
                   let video = selectedItem.video {
                    store.selectVideo(video)
                }
            } else {
                store.selectedVideo = nil
            }
        }
    }
    
    private func startRenaming(_ item: HierarchicalContentItem) {
        editedName = item.name
        renamingItemID = item.id
        Task { @MainActor in
            try? await Task.sleep(nanoseconds: 100_000_000) // 0.1s delay
            focusedField = item.id
        }
    }
    
    private func generateThumbnailsForVideos() {
        guard let library = libraryManager.currentLibrary, let context = libraryManager.viewContext else { return }
        isGeneratingThumbnails = true
        Task {
            await FileSystemManager.shared.generateMissingThumbnails(for: library, context: context)
            await MainActor.run {
                isGeneratingThumbnails = false
            }
        }
    }
}

================================================================================

File: Views/MainView.swift
// Views/MainView.swift

import SwiftUI

struct MainView: View {
    @EnvironmentObject var libraryManager: LibraryManager
    @StateObject private var folderStore: FolderNavigationStore
    @State private var searchText = ""
    @State private var columnVisibility = NavigationSplitViewVisibility.all
    
    // REFACTORED: The initializer now requires the active LibraryManager.
    // This is the standard SwiftUI pattern for initializing a @StateObject
    // that has dependencies, ensuring it's created only once with the correct state.
    init(libraryManager: LibraryManager) {
        self._folderStore = StateObject(wrappedValue: FolderNavigationStore(libraryManager: libraryManager))
    }
    
    var body: some View {
        NavigationSplitView(columnVisibility: $columnVisibility) {
            // Sidebar
            SidebarView()
                .navigationSplitViewColumnWidth(min: 200, ideal: 250, max: 350)
                .environmentObject(folderStore)
                .environment(\.managedObjectContext, libraryManager.viewContext!)
        } content: {
            // Hierarchical Content View - shows content of selected top-level sidebar item
            HierarchicalContentView(searchText: searchText)
                .navigationTitle(folderStore.folderName(for: folderStore.currentFolderID))
                .navigationSplitViewColumnWidth(min: 300, ideal: 400, max: 600)
                .searchable(text: $searchText, prompt: "Search videos")
                .environmentObject(folderStore)
                .environment(\.managedObjectContext, libraryManager.viewContext!)
        } detail: {
            // Detail View
            DetailView(video: folderStore.selectedVideo)
                .navigationSplitViewColumnWidth(min: 500, ideal: 700)
        }
        .navigationTitle(libraryManager.currentLibrary?.name ?? "Pangolin")
        .pangolinAlert(error: $libraryManager.error)
    }
}


================================================================================

File: Views/ContentListView.swift
//
//  ContentListView.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//

import SwiftUI
import CoreData
import Combine

// NOTE: The old 'extension Notification.Name' is REMOVED from this file.
// The new name is now globally available from the 'NotificationNames.swift' file.

struct ContentListView: View {
    @EnvironmentObject private var store: FolderNavigationStore
    let searchText: String
    @AppStorage("contentViewMode") private var viewMode = ViewMode.grid
    @State private var showingImportPicker = false
    @State private var showingImportProgress = false
    @StateObject private var videoImporter = VideoImporter()
    @EnvironmentObject var libraryManager: LibraryManager
    @State private var showingCreateFolder = false
    @State private var isGeneratingThumbnails = false
    
    // Renaming state
    @State private var renamingItemID: UUID? = nil
    @FocusState private var focusedField: UUID?
    @State private var editedName: String = ""
    
    @State private var selectedItems: Set<UUID> = []
    #if os(iOS)
    @Environment(\.editMode) private var editMode
    #endif
    
    private var isSelectionMode: Bool {
        #if os(iOS)
        return editMode?.wrappedValue.isEditing ?? false
        #else
        return _isSelectionMode
        #endif
    }
    @State private var _isSelectionMode = false

    enum ViewMode: String, CaseIterable {
        case grid = "Grid"
        case list = "List"
    }
    
    var content: [ContentType] {        
        var allContent = store.content(for: store.currentFolderID)
        if !searchText.isEmpty {
            allContent = allContent.filter { item in
                item.name.localizedCaseInsensitiveContains(searchText)
            }
        }
        return allContent
    }
    
    var videosWithoutThumbnails: [Video] {
        return content.compactMap { item in
            if case .video(let video) = item, video.thumbnailPath == nil {
                return video
            }
            return nil
        }
    }
    
    var body: some View {
        VStack(spacing: 0) {
            FolderNavigationHeader {
                showingCreateFolder = true
            }
            
            contentView
        }
        .toolbar {
            toolbarContent
        }
        .fileImporter(isPresented: $showingImportPicker, allowedContentTypes: [.movie, .video, .folder], allowsMultipleSelection: true) { result in
            switch result {
            case .success(let urls):
                if let library = libraryManager.currentLibrary, let context = libraryManager.viewContext {
                    showingImportProgress = true
                    Task {
                        await videoImporter.importFiles(urls, to: library, context: context)
                    }
                }
            case .failure(let error):
                print("Error importing files: \(error)")
            }
        }
        .sheet(isPresented: $showingImportProgress) {
            ImportProgressView(importer: videoImporter)
        }
        .onChange(of: videoImporter.isImporting) { _, isImporting in
            if !isImporting && showingImportProgress {
                // CORRECTED: This now uses the globally defined notification name.
                // Apply this fix to all places where you post this notification.
                NotificationCenter.default.post(name: .contentUpdated, object: nil)
            }
        }
        .sheet(isPresented: $showingCreateFolder) {
            CreateFolderView(parentFolderID: store.currentFolderID)
        }
        .onChange(of: focusedField) { _, newValue in
            if newValue == nil {
                // When focus is lost, clear renaming state if no commit happened
                if renamingItemID != nil {
                    renamingItemID = nil
                }
            }
        }
        .onKeyPress { keyPress in
            // Trigger rename on Return key for the single selected item on macOS
            guard keyPress.key == .return, selectedItems.count == 1,
                  let selectedID = selectedItems.first, renamingItemID == nil,
                  let selectedItem = content.first(where: { $0.id == selectedID }) else {
                return .ignored
            }
            
            // Initiate the rename process
            editedName = selectedItem.name
            renamingItemID = selectedID
            
            // Set focus programmatically
            Task { @MainActor in
                try? await Task.sleep(nanoseconds: 100_000_000) // 0.1s delay
                focusedField = selectedID
            }
            return .handled
        }
        .onReceive(NotificationCenter.default.publisher(for: .contentUpdated)) { _ in
            // Core Data change notifications now handled automatically
        }
    }
    
    @ViewBuilder
    private var contentView: some View {
        if content.isEmpty {
            ContentUnavailableView("No Content", systemImage: "folder.badge.questionmark", description: Text(store.currentFolderID == nil ? "Import videos to get started" : "This folder is empty"))
        } else {
            switch viewMode {
            case .grid: gridView
            case .list: listView
            }
        }
    }
    
    @ViewBuilder
    private var gridView: some View {
        ScrollView {
            LazyVGrid(columns: [GridItem(.adaptive(minimum: 180))], spacing: 20) {
                ForEach(content, id: \.id) { item in
                    ContentRowView(
                        content: item,
                        isSelected: selectedItems.contains(item.id),
                        showCheckbox: isSelectionMode,
                        viewMode: .grid,
                        selectedItems: $selectedItems,
                        renamingItemID: $renamingItemID,
                        focusedField: $focusedField,
                        editedName: $editedName
                    )
                    .contentShape(Rectangle())
                    .onTapGesture(count: 2) {
                        handleGridDoubleClick(on: item)
                    }
                    .simultaneousGesture(
                        TapGesture()
                            .modifiers(.command)
                            .onEnded {
                                handleGridCommandClick(on: item)
                            }
                    )
                    .simultaneousGesture(
                        TapGesture()
                            .modifiers(.shift)
                            .onEnded {
                                handleGridShiftClick(on: item)
                            }
                    )
                    .onTapGesture { 
                        handleGridTap(on: item)
                    }
                    .contextMenu {
                        Button("Rename") {
                            startRenaming(item)
                        }
                        Button("Delete", role: .destructive) {
                            // TODO: Implement deletion
                        }
                    }
                }
            }
            .padding()
        }
    }
    
    @ViewBuilder
    private var listView: some View {
        List(selection: $selectedItems) {
            ForEach(content, id: \.id) { item in
                ContentRowView(
                    content: item,
                    isSelected: selectedItems.contains(item.id),
                    showCheckbox: isSelectionMode,
                    viewMode: .list,
                    selectedItems: $selectedItems,
                    renamingItemID: $renamingItemID,
                    focusedField: $focusedField,
                    editedName: $editedName
                )
                .contentShape(Rectangle()) // Ensure entire row is clickable
                .onTapGesture(count: 2) {
                    // Handle double-click separately
                    handleDoubleClick(on: item)
                }
                .contextMenu {
                    Button("Rename") {
                        startRenaming(item)
                    }
                    Button("Delete", role: .destructive) {
                        // TODO: Implement deletion
                    }
                }
                .tag(item.id)
            }
        }
        .onChange(of: selectedItems) { _, newSelection in
            handleSelectionChange(newSelection)
        }
        #if os(iOS)
        .environment(\.editMode, editMode)
        #endif
    }
    
    @ToolbarContentBuilder
    private var toolbarContent: some ToolbarContent {
        #if os(macOS)
        ToolbarItemGroup {
            if _isSelectionMode {
                Button("Done") {
                    _isSelectionMode = false
                    selectedItems.removeAll()
                }
            } else {
                macOSNormalButtons
            }
        }
        
        // Show selection count when items are selected (following macOS Finder pattern)
        ToolbarItem(placement: .status) {
            if !selectedItems.isEmpty && !isSelectionMode {
                Text("\(selectedItems.count) selected")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
        #else
        ToolbarItem(placement: .navigationBarLeading) {
            if !content.isEmpty {
                EditButton()
            }
        }
        ToolbarItemGroup(placement: .navigationBarTrailing) {
            iOSMenu
        }
        #endif
    }
    
    @ViewBuilder
    private var macOSNormalButtons: some View {
        Button("Create Folder") { showingCreateFolder = true }
        Button("Import Videos") { showingImportPicker = true }
            .disabled(libraryManager.currentLibrary == nil)
        
        if !videosWithoutThumbnails.isEmpty {
            Button(isGeneratingThumbnails ? "Generating..." : "Generate Thumbnails") {
                generateThumbnailsForVideos()
            }
            .disabled(isGeneratingThumbnails)
        }
        
        Button("Select") { _isSelectionMode = true }
            .disabled(content.isEmpty)
        
        Picker("View Mode", selection: $viewMode) {
            ForEach(ViewMode.allCases, id: \.self) { mode in
                Label(mode.rawValue, systemImage: mode == .grid ? "square.grid.2x2" : "list.bullet")
                    .tag(mode)
            }
        }
        .pickerStyle(.segmented)
        
        Menu {
            ForEach(SortOption.allCases, id: \.self) { option in
                Button(option.rawValue) { store.currentSortOption = option }
            }
        } label: {
            Label("Sort", systemImage: "arrow.up.arrow.down")
        }
    }
    
    @ViewBuilder
    private var iOSMenu: some View {
        Menu {
            Button { showingImportPicker = true } label: { Label("Import Videos", systemImage: "square.and.arrow.down") }
                .disabled(libraryManager.currentLibrary == nil)
            Button { showingCreateFolder = true } label: { Label("New Folder", systemImage: "folder.badge.plus") }
            Picker("View Mode", selection: $viewMode) {
                ForEach(ViewMode.allCases, id: \.self) { mode in
                    Label(mode.rawValue, systemImage: mode == .grid ? "square.grid.2x2" : "list.bullet").tag(mode)
                }
            }
            Menu {
                ForEach(SortOption.allCases, id: \.self) { option in
                    Button(option.rawValue) { store.currentSortOption = option }
                }
            } label: { Label("Sort", systemImage: "arrow.up.arrow.down") }
        } label: {
            Image(systemName: "ellipsis.circle")
        }
    }
    
    private func handleContentSelection(item: ContentType) {
        if isSelectionMode {
            if viewMode == .grid {
                if selectedItems.contains(item.id) {
                    selectedItems.remove(item.id)
                } else {
                    selectedItems.insert(item.id)
                }
            }
        } else {
            switch item {
            case .folder(let folder):
                store.navigateToFolder(folder.id!)
            case .video(let video):
                Task { @MainActor in
                    store.selectVideo(video)
                }
            }
            selectedItems.removeAll()
        }
    }
    
    /// Handles changes to SwiftUI List selection
    private func handleSelectionChange(_ newSelection: Set<UUID>) {
        guard !isSelectionMode else { return }
        
        // Defer the state update to avoid "Publishing changes from within view updates" error
        Task { @MainActor in
            // When a single video is selected, set it for detail view
            if newSelection.count == 1, let selectedID = newSelection.first {
                if let selectedItem = content.first(where: { $0.id == selectedID }),
                   case .video(let video) = selectedItem {
                    store.selectVideo(video)
                }
            } else {
                // Clear selected video if not single selection
                store.selectedVideo = nil
            }
        }
    }
    
    /// Handles double-click for navigation
    private func handleDoubleClick(on item: ContentType) {
        guard !isSelectionMode else { return }
        
        switch item {
        case .folder(let folder):
            store.navigateToFolder(folder.id!)
        case .video(let video):
            Task { @MainActor in
                store.selectVideo(video)
            }
        }
    }
    
    /// Starts renaming for the given item
    private func startRenaming(_ item: ContentType) {
        editedName = item.name
        renamingItemID = item.id
        Task { @MainActor in
            try? await Task.sleep(nanoseconds: 100_000_000) // 0.1s delay
            focusedField = item.id
        }
    }
    
    /// Handles all tap gestures for grid view (which doesn't have built-in selection)
    private func handleGridTap(on item: ContentType) {
        if isSelectionMode {
            if selectedItems.contains(item.id) {
                selectedItems.remove(item.id)
            } else {
                selectedItems.insert(item.id)
            }
        } else {
            // Check for rename on already selected item (slow-click)
            if selectedItems.count == 1 && selectedItems.first == item.id && renamingItemID == nil {
                // Delay to distinguish from double-click
                Task { @MainActor in
                    try? await Task.sleep(nanoseconds: 300_000_000) // 0.3s delay
                    if selectedItems.count == 1 && selectedItems.first == item.id {
                        editedName = item.name
                        renamingItemID = item.id
                        try? await Task.sleep(nanoseconds: 100_000_000) // 0.1s for focus
                        focusedField = item.id
                    }
                }
            } else {
                // Normal selection - need to handle manually for grid view
                selectedItems = [item.id]
                renamingItemID = nil // Cancel any ongoing rename
                
                // For videos, also set the selected video for detail view
                if case .video(let video) = item {
                    Task { @MainActor in
                        store.selectVideo(video)
                    }
                }
            }
        }
    }
    
    /// Handles double-click for grid view navigation
    private func handleGridDoubleClick(on item: ContentType) {
        guard !isSelectionMode else { return }
        
        switch item {
        case .folder(let folder):
            store.navigateToFolder(folder.id!)
        case .video(let video):
            // Double-click should also select the video
            Task { @MainActor in
                store.selectVideo(video)
            }
        }
    }
    
    /// Handles Command+Click for multi-selection
    private func handleGridCommandClick(on item: ContentType) {
        if selectedItems.contains(item.id) {
            selectedItems.remove(item.id)
        } else {
            selectedItems.insert(item.id)
        }
    }
    
    /// Handles Shift+Click for range selection
    private func handleGridShiftClick(on item: ContentType) {
        // Find the last selected item's index by checking the content array
        var lastSelectedIndex: Int?
        for (index, contentItem) in content.enumerated() {
            if selectedItems.contains(contentItem.id) {
                lastSelectedIndex = index
            }
        }
        
        guard let lastIndex = lastSelectedIndex,
              let currentIndex = content.firstIndex(where: { $0.id == item.id }) else {
            // If no previous selection or can't find indices, just select this item
            selectedItems = [item.id]
            return
        }
        
        let startIndex = min(lastIndex, currentIndex)
        let endIndex = max(lastIndex, currentIndex)
        
        // Select all items in range
        let rangeItems = content[startIndex...endIndex].map { $0.id }
        selectedItems.formUnion(rangeItems)
    }
    
    private func generateThumbnailsForVideos() {
        guard let library = libraryManager.currentLibrary, let context = libraryManager.viewContext else { return }
        isGeneratingThumbnails = true
        Task {
            await FileSystemManager.shared.generateMissingThumbnails(for: library, context: context)
            await MainActor.run {
                isGeneratingThumbnails = false
            }
        }
    }
}


================================================================================

File: Views/Sidebar/CreateFolderView.swift
// Views/Sidebar/CreateFolderView.swift
import SwiftUI
import CoreData

struct CreateFolderView: View {
    @Environment(\.dismiss) var dismiss
    @EnvironmentObject private var store: FolderNavigationStore
    @State private var folderName = ""
    
    let parentFolderID: UUID?
    
    var body: some View {
        VStack {
            Text("Create New Folder")
                .font(.headline)
            
            TextField("Folder Name", text: $folderName)
                .textFieldStyle(.roundedBorder)
                .frame(width: 300)
            
            HStack {
                Button("Cancel") {
                    dismiss()
                }
                .keyboardShortcut(.cancelAction)
                
                Button("Create") {
                    Task {
                        await createFolder()
                    }
                }
                .keyboardShortcut(.defaultAction)
                .disabled(folderName.isEmpty)
            }
        }
        .padding()
        .frame(width: 400, height: 150)
    }
    
    private func createFolder() async {
        let trimmedName = folderName.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmedName.isEmpty else { return }
        
        await store.createFolder(name: trimmedName, in: parentFolderID)
        dismiss()
    }
}


================================================================================

File: Views/Components/VideoControlsBar.swift
//
//  VideoControlsBar.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//


// Views/Components/VideoControlsBar.swift
import SwiftUI

struct VideoControlsBar: View {
    @ObservedObject var viewModel: VideoPlayerViewModel
    
    var body: some View {
        HStack(spacing: 20) {
            // Play/Pause button
            Button(action: { viewModel.togglePlayPause() }) {
                Image(systemName: viewModel.isPlaying ? "pause.fill" : "play.fill")
                    .font(.title2)
            }
            .buttonStyle(.plain)
            
            // Skip backward
            Button(action: { viewModel.skipBackward() }) {
                Image(systemName: "gobackward.10")
            }
            .buttonStyle(.plain)
            
            // Skip forward
            Button(action: { viewModel.skipForward() }) {
                Image(systemName: "goforward.10")
            }
            .buttonStyle(.plain)
            
            // Time display
            Text(formatTime(viewModel.currentTime))
                .monospacedDigit()
            
            // Progress slider
            Slider(value: Binding(
                get: { viewModel.currentTime },
                set: { viewModel.seek(to: $0) }
            ), in: 0...max(viewModel.duration, 1))
            
            // Duration display
            Text(formatTime(viewModel.duration))
                .monospacedDigit()
            
            // Volume control
            Image(systemName: "speaker.fill")
            Slider(value: $viewModel.volume, in: 0...1)
                .frame(width: 100)
            
            // Playback speed
            Menu {
                ForEach([0.5, 0.75, 1.0, 1.25, 1.5, 2.0], id: \.self) { rate in
                    Button(String(format: "%.2fx", rate)) {
                        viewModel.setPlaybackRate(Float(rate))
                    }
                }
            } label: {
                Text(String(format: "%.2fx", viewModel.playbackRate))
            }
            .frame(width: 60)
            
            // Subtitle menu
            if !viewModel.availableSubtitles.isEmpty {
                Menu {
                    Button("Off") {
                        viewModel.selectSubtitle(nil)
                    }
                    Divider()
                    ForEach(viewModel.availableSubtitles, id: \.id) { subtitle in
                        Button(subtitle.displayName) {
                            viewModel.selectSubtitle(subtitle)
                        }
                    }
                } label: {
                    Image(systemName: "captions.bubble")
                }
            }
        }
        .padding(.horizontal)
    }
    
    func formatTime(_ time: TimeInterval) -> String {
        let formatter = DateComponentsFormatter()
        formatter.allowedUnits = [.hour, .minute, .second]
        formatter.unitsStyle = .positional
        formatter.zeroFormattingBehavior = .pad
        return formatter.string(from: time) ?? "00:00"
    }
}

================================================================================

File: Views/Components/FolderNavigationHeader.swift
//
//  FolderNavigationHeader.swift
//  Pangolin
//
//  Created by Matt Kevan on 18/08/2025.
//

import SwiftUI

struct FolderNavigationHeader: View {
    @EnvironmentObject private var store: FolderNavigationStore
    let onCreateSubfolder: () -> Void
    
    private var canGoBack: Bool {
        !store.navigationPath.isEmpty
    }
    
    private var folderName: String {
        store.folderName(for: store.currentFolderID)
    }
    
    var body: some View {
        HStack {
            // Back button
            if canGoBack {
                Button {
                    store.navigateBack()
                } label: {
                    HStack(spacing: 4) {
                        Image(systemName: "chevron.left")
                            .font(.system(size: 12, weight: .medium))
                        Text("Back")
                            .font(.system(size: 14))
                    }
                }
                .buttonStyle(.plain)
                .foregroundColor(.primary)
            }
            
            Spacer()
            
            // Folder name
            Text(folderName)
                .font(.headline)
                .lineLimit(1)
                .truncationMode(.middle)
            
            Spacer()
            
            // Create subfolder button
            Button {
                onCreateSubfolder()
            } label: {
                HStack(spacing: 4) {
                    Image(systemName: "folder.badge.plus")
                        .font(.system(size: 14))
                    Text("New Folder")
                        .font(.system(size: 14))
                }
            }
            .buttonStyle(.plain)
            .foregroundColor(.primary)
            .help("Create New Subfolder")
        }
        .padding(.horizontal, 16)
        .padding(.vertical, 12)
        .background(backgroundMaterial)
        .overlay(
            Rectangle()
                .fill(separatorColor)
                .frame(height: 0.5),
            alignment: .bottom
        )
    }
    
    private var backgroundMaterial: some View {
        #if os(macOS)
        Color(NSColor.controlBackgroundColor)
        #else
        Color(.secondarySystemGroupedBackground)
        #endif
    }
    
    private var separatorColor: Color {
        #if os(macOS)
        Color(NSColor.separatorColor)
        #else
        Color(.separator)
        #endif
    }
}

#Preview {
    FolderNavigationHeader {
        // Preview action
    }
    .environmentObject(FolderNavigationStore(libraryManager: LibraryManager.shared))
}

================================================================================

File: Views/Components/FolderContentView.swift
//
//  FolderContentView.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//

import SwiftUI
import CoreData

struct FolderContentView: View {
    @EnvironmentObject private var store: FolderNavigationStore
    let searchText: String
    @AppStorage("contentViewMode") private var viewMode = ViewMode.grid
    @State private var showingImportPicker = false
    @State private var showingImportProgress = false
    @StateObject private var videoImporter = VideoImporter()
    @EnvironmentObject var libraryManager: LibraryManager
    @State private var showingCreateFolder = false
    @State private var isGeneratingThumbnails = false
    
    // State for managing which item is being renamed and which field is focused.
    @State private var renamingItemID: UUID? = nil
    @FocusState private var focusedField: UUID?
    @State private var editedName: String = ""

    @State private var selectedItems: Set<UUID> = []
    #if os(iOS)
    @Environment(\.editMode) private var editMode
    #endif
    
    private var isSelectionMode: Bool {
        #if os(iOS)
        return editMode?.wrappedValue.isEditing ?? false
        #else
        return _isSelectionMode
        #endif
    }
    @State private var _isSelectionMode = false

    enum ViewMode: String, CaseIterable {
        case grid = "Grid"
        case list = "List"
    }
    
    var content: [ContentType] {
        var allContent = store.content(for: store.currentFolderID)
        if !searchText.isEmpty {
            allContent = allContent.filter { item in
                item.name.localizedCaseInsensitiveContains(searchText)
            }
        }
        return allContent
    }
    
    var videosWithoutThumbnails: [Video] {
        return content.compactMap { item in
            if case .video(let video) = item, video.thumbnailPath == nil {
                return video
            }
            return nil
        }
    }
    
    var body: some View {
        contentView
        .toolbar {
            toolbarContent
        }
        .fileImporter(isPresented: $showingImportPicker, allowedContentTypes: [.movie, .video, .folder], allowsMultipleSelection: true) { result in
            switch result {
            case .success(let urls):
                if let library = libraryManager.currentLibrary, let context = libraryManager.viewContext {
                    showingImportProgress = true
                    Task {
                        await videoImporter.importFiles(urls, to: library, context: context)
                    }
                }
            case .failure(let error):
                print("Error importing files: \(error)")
            }
        }
        .sheet(isPresented: $showingImportProgress) {
            ImportProgressView(importer: videoImporter)
        }
        .onChange(of: videoImporter.isImporting) { _, isImporting in
            if !isImporting && showingImportProgress {
                NotificationCenter.default.post(name: .contentUpdated, object: nil)
            }
        }
        .sheet(isPresented: $showingCreateFolder) {
            CreateFolderView(parentFolderID: store.currentFolderID)
        }
        // This onChange handles committing a rename when the user clicks away,
        // causing the TextField to lose focus.
        .onChange(of: focusedField) { _, newValue in
            if newValue == nil {
                // If focus is lost (e.g., user clicked elsewhere), and we were in the middle
                // of a rename, we should end the rename process. The commit is handled
                // by the `onSubmit` modifier in the ContentRowView's TextField.
                renamingItemID = nil
            }
        }
        .onKeyPress { keyPress in
            // Trigger rename on Return key for the single selected item on macOS
            guard keyPress.key == .return, selectedItems.count == 1,
                  let selectedID = selectedItems.first else {
                return .ignored
            }
            
            // Initiate the rename process
            renamingItemID = selectedID
            
            // Programmatically set focus to the TextField
            Task { @MainActor in
                try? await Task.sleep(nanoseconds: 100_000_000) // 0.1s delay
                focusedField = selectedID
            }
            return .handled
        }
    }
    
    @ViewBuilder
    private var contentView: some View {
        if content.isEmpty {
            ContentUnavailableView("No Content", systemImage: "folder.badge.questionmark", description: Text(store.currentFolderID == nil ? "Import videos to get started" : "This folder is empty"))
        } else {
            switch viewMode {
            case .grid: gridView
            case .list: listView
            }
        }
    }
    
    @ViewBuilder
    private var gridView: some View {
        ScrollView {
            LazyVGrid(columns: [GridItem(.adaptive(minimum: 180))], spacing: 20) {
                ForEach(content, id: \.id) { item in
                    ContentRowView(
                        content: item,
                        isSelected: selectedItems.contains(item.id),
                        showCheckbox: isSelectionMode,
                        viewMode: .grid,
                        selectedItems: $selectedItems,
                        renamingItemID: $renamingItemID,
                        focusedField: $focusedField,
                        editedName: $editedName
                    )
                    .contentShape(Rectangle())
                    .onTapGesture { handleTap(on: item) }
                }
            }
            .padding()
        }
    }
    
    @ViewBuilder
    private var listView: some View {
        List(selection: $selectedItems) {
            ForEach(content, id: \.id) { item in
                ContentRowView(
                    content: item,
                    isSelected: selectedItems.contains(item.id),
                    showCheckbox: isSelectionMode,
                    viewMode: .list,
                    selectedItems: $selectedItems,
                    renamingItemID: $renamingItemID,
                    focusedField: $focusedField,
                    editedName: $editedName
                )
                .contentShape(Rectangle())
                .onTapGesture { handleTap(on: item) }
                .tag(item.id)
            }
        }
        #if os(iOS)
        .environment(\.editMode, editMode)
        #endif
    }
    
    @ToolbarContentBuilder
    private var toolbarContent: some ToolbarContent {
        #if os(macOS)
        ToolbarItemGroup {
            if _isSelectionMode {
                Button("Done") {
                    _isSelectionMode = false
                    selectedItems.removeAll()
                }
            } else {
                macOSNormalButtons
            }
        }
        #else
        ToolbarItem(placement: .navigationBarLeading) {
            if !content.isEmpty {
                EditButton()
            }
        }
        ToolbarItemGroup(placement: .navigationBarTrailing) {
            iOSMenu
        }
        #endif
    }
    
    @ViewBuilder
    private var macOSNormalButtons: some View {
        Button("Create Folder") { showingCreateFolder = true }
        Button("Import Videos") { showingImportPicker = true }
            .disabled(libraryManager.currentLibrary == nil)
        
        if !videosWithoutThumbnails.isEmpty {
            Button(isGeneratingThumbnails ? "Generating..." : "Generate Thumbnails") {
                generateThumbnailsForVideos()
            }
            .disabled(isGeneratingThumbnails)
        }
        
        Button("Select") { _isSelectionMode = true }
            .disabled(content.isEmpty)
        
        Picker("View Mode", selection: $viewMode) {
            ForEach(ViewMode.allCases, id: \.self) { mode in
                Label(mode.rawValue, systemImage: mode == .grid ? "square.grid.2x2" : "list.bullet")
                    .tag(mode)
            }
        }
        .pickerStyle(.segmented)
        
        Menu {
            ForEach(SortOption.allCases, id: \.self) { option in
                Button(option.rawValue) { store.currentSortOption = option }
            }
        } label: {
            Label("Sort", systemImage: "arrow.up.arrow.down")
        }
    }
    
    @ViewBuilder
    private var iOSMenu: some View {
        Menu {
            Button { showingImportPicker = true } label: { Label("Import Videos", systemImage: "square.and.arrow.down") }
                .disabled(libraryManager.currentLibrary == nil)
            Button { showingCreateFolder = true } label: { Label("New Folder", systemImage: "folder.badge.plus") }
            Picker("View Mode", selection: $viewMode) {
                ForEach(ViewMode.allCases, id: \.self) { mode in
                    Label(mode.rawValue, systemImage: mode == .grid ? "square.grid.2x2" : "list.bullet").tag(mode)
                }
            }
            Menu {
                ForEach(SortOption.allCases, id: \.self) { option in
                    Button(option.rawValue) { store.currentSortOption = option }
                }
            } label: { Label("Sort", systemImage: "arrow.up.arrow.down") }
        } label: {
            Image(systemName: "ellipsis.circle")
        }
    }
    
    /// Handles all tap gestures to manage selection and trigger the Finder-style "slow-click" rename.
    private func handleTap(on item: ContentType) {
        if isSelectionMode {
            if viewMode == .grid {
                if selectedItems.contains(item.id) {
                    selectedItems.remove(item.id)
                } else {
                    selectedItems.insert(item.id)
                }
            }
        } else {
            // If the item we are tapping is the only one selected, start renaming it.
            if selectedItems.count == 1 && selectedItems.first == item.id {
                editedName = item.name
                renamingItemID = item.id
                Task { @MainActor in
                    try? await Task.sleep(nanoseconds: 100_000_000) // 0.1s delay
                    focusedField = item.id
                }
            } else {
                // Otherwise, handle normal navigation/selection.
                selectedItems = [item.id]
                switch item {
                case .folder(let folder):
                    store.navigateToFolder(folder.id!)
                case .video(let video):
                    Task { @MainActor in
                        store.selectVideo(video)
                    }
                }
            }
        }
    }
    
    private func generateThumbnailsForVideos() {
        guard let library = libraryManager.currentLibrary, let context = libraryManager.viewContext else { return }
        isGeneratingThumbnails = true
        Task {
            await FileSystemManager.shared.generateMissingThumbnails(for: library, context: context)
            await MainActor.run {
                isGeneratingThumbnails = false
            }
        }
    }
}


================================================================================

File: Views/Components/VideoPlayerWithPosterView.swift
//
//  VideoPlayerWithPosterView.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//

import SwiftUI
import AVKit

struct VideoPlayerWithPosterView: View {
    let video: Video?
    @ObservedObject var viewModel: VideoPlayerViewModel
    @State private var showPlayer = false
    @State private var hasStartedPlaying = false
    
    var body: some View {
        ZStack {
            // Background color
            Color.black
            
            if let video = video {
                if !showPlayer && !hasStartedPlaying {
                    // Show poster frame (thumbnail)
                    posterFrameView(for: video)
                } else {
                    // Show video player
                    VideoPlayerView(viewModel: viewModel)
                        .onAppear {
                            if !hasStartedPlaying {
                                hasStartedPlaying = true
                            }
                        }
                }
            } else {
                // No video selected state
                ContentUnavailableView(
                    "No Video Selected",
                    systemImage: "video.slash",
                    description: Text("Select a video from the library to start playing")
                )
                .foregroundColor(.white)
            }
        }
        .onChange(of: video?.id) { oldValue, newValue in
            // Reset state when video changes
            showPlayer = false
            hasStartedPlaying = false
        }
        .onChange(of: viewModel.isPlaying) { oldValue, newValue in
            if newValue {
                showPlayer = true
                hasStartedPlaying = true
            }
        }
    }
    
    @ViewBuilder
    private func posterFrameView(for video: Video) -> some View {
        ZStack {
            // Thumbnail background
            if let thumbnailURL = video.thumbnailURL,
               FileManager.default.fileExists(atPath: thumbnailURL.path) {
                AsyncImage(url: thumbnailURL) { image in
                    image
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                } placeholder: {
                    Rectangle()
                        .fill(Color.gray.opacity(0.3))
                        .overlay(
                            ProgressView()
                                .tint(.white)
                        )
                }
            } else {
                // Fallback when no thumbnail
                Rectangle()
                    .fill(Color.gray.opacity(0.3))
                    .overlay(
                        VStack(spacing: 12) {
                            Image(systemName: "video")
                                .font(.system(size: 48))
                                .foregroundColor(.white.opacity(0.7))
                            
                            Text(video.title!)
                                .font(.title2)
                                .foregroundColor(.white)
                                .multilineTextAlignment(.center)
                                .lineLimit(2)
                        }
                        .padding()
                    )
            }
            
            // Play button overlay
            playButtonOverlay
            
            // Video info overlay
            videoInfoOverlay(for: video)
        }
        .onTapGesture {
            startPlayback()
        }
    }
    
    @ViewBuilder
    private var playButtonOverlay: some View {
        Button(action: startPlayback) {
            ZStack {
                Circle()
                    .fill(Color.black.opacity(0.6))
                    .frame(width: 80, height: 80)
                
                Image(systemName: "play.fill")
                    .font(.system(size: 32))
                    .foregroundColor(.white)
                    .offset(x: 3) // Slight offset to center the play triangle visually
            }
        }
        .buttonStyle(PlainButtonStyle())
        .scaleEffect(1.0)
        .animation(.easeInOut(duration: 0.1), value: showPlayer)
    }
    
    @ViewBuilder
    private func videoInfoOverlay(for video: Video) -> some View {
        VStack {
            Spacer()
            
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text(video.title!)
                        .font(.title3)
                        .fontWeight(.semibold)
                        .foregroundColor(.white)
                        .shadow(color: .black.opacity(0.7), radius: 2)
                    
                    HStack(spacing: 12) {
                        Text(video.formattedDuration)
                        
                        if let resolution = video.resolution, !resolution.isEmpty {
                            Text(resolution)
                        }
                        
                        if video.playbackPosition > 0 {
                            Text("Resume from \(formatTime(video.playbackPosition))")
                                .foregroundColor(.accentColor)
                        }
                    }
                    .font(.caption)
                    .foregroundColor(.white.opacity(0.9))
                    .shadow(color: .black.opacity(0.7), radius: 1)
                }
                
                Spacer()
            }
            .padding()
            .background(
                LinearGradient(
                    colors: [.clear, .black.opacity(0.7)],
                    startPoint: .top,
                    endPoint: .bottom
                )
            )
        }
    }
    
    private func startPlayback() {
        guard let video = video else { return }
        
        // Load video if not already loaded
        if viewModel.player == nil || video != getCurrentVideo() {
            viewModel.loadVideo(video)
        }
        
        // Start playing
        viewModel.play()
        showPlayer = true
        hasStartedPlaying = true
    }
    
    private func getCurrentVideo() -> Video? {
        return viewModel.currentVideo
    }
    
    private func formatTime(_ seconds: TimeInterval) -> String {
        let formatter = DateComponentsFormatter()
        formatter.allowedUnits = [.hour, .minute, .second]
        formatter.unitsStyle = .positional
        formatter.zeroFormattingBehavior = .pad
        return formatter.string(from: seconds) ?? "00:00"
    }
}

#Preview {
    // Preview with mock data
    VideoPlayerWithPosterView(
        video: nil,
        viewModel: VideoPlayerViewModel()
    )
    .frame(height: 400)
    .background(Color.black)
}

================================================================================

File: Views/Components/HierarchicalContentRowView.swift
//
//  HierarchicalContentRowView.swift
//  Pangolin
//
//  Created by Claude on 19/08/2025.
//

import SwiftUI
import CoreData

/// Row view for hierarchical content items in the native SwiftUI List
struct HierarchicalContentRowView: View {
    let item: HierarchicalContentItem
    @Binding var renamingItemID: UUID?
    @FocusState.Binding var focusedField: UUID?
    @Binding var editedName: String
    @Binding var selectedItems: Set<UUID>
    
    @EnvironmentObject private var store: FolderNavigationStore
    
    var body: some View {
        HStack(spacing: 12) {
            // Icon or Thumbnail
            Group {
                if case .video(let video) = item.contentType {
                    VideoThumbnailView(video: video, size: CGSize(width: 32, height: 18))
                        .frame(width: 32, height: 18)
                        .clipShape(RoundedRectangle(cornerRadius: 3))
                        .overlay(
                            RoundedRectangle(cornerRadius: 3)
                                .stroke(Color.primary.opacity(0.1), lineWidth: 0.5)
                        )
                } else {
                    Image(systemName: iconName)
                        .foregroundColor(iconColor)
                        .frame(width: 16, height: 16)
                }
            }
            
            // Name (editable if renaming)
            if renamingItemID == item.id {
                TextField("Name", text: $editedName)
                    .textFieldStyle(.plain)
                    .focused($focusedField, equals: item.id)
                    .onSubmit {
                        commitRename()
                    }
                    .onKeyPress(.escape) {
                        cancelRename()
                        return .handled
                    }
            } else {
                Text(item.name)
                    .lineLimit(1)
                    .font(.system(.body, design: .default, weight: .regular))
            }
            
            Spacer()
            
            // Additional info for videos
            if case .video(let video) = item.contentType {
                Text(video.formattedDuration)
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
        .contextMenu {
            contextMenuContent
        }
        .draggable(dragPayload)
        .dropDestination(for: ContentTransfer.self) { items, location in
            handleDrop(items)
        } isTargeted: { isTargeted in
            // Could add visual feedback for drop targeting
        }
    }
    
    // MARK: - Computed Properties
    
    private var iconName: String {
        switch item.contentType {
        case .folder:
            return item.hasChildren ? "folder" : "folder"
        case .video:
            return "play.rectangle"
        }
    }
    
    private var iconColor: Color {
        switch item.contentType {
        case .folder:
            return .accentColor
        case .video:
            return .primary
        }
    }
    
    private var dragPayload: ContentTransfer {
        // If the dragged item is part of a larger selection, drag all selected items.
        // Otherwise, just drag the single item.
        if selectedItems.contains(item.id) {
            return ContentTransfer(itemIDs: Array(selectedItems))
        } else {
            return ContentTransfer(itemIDs: [item.id])
        }
    }
    
    @ViewBuilder
    private var contextMenuContent: some View {
        Button("Rename") {
            startRenaming()
        }
        
        if case .folder = item.contentType {
            Divider()
            Button("Create Subfolder") {
                // TODO: Implement subfolder creation
            }
        }
        
        Divider()
        Button("Delete", role: .destructive) {
            // TODO: Implement deletion
        }
    }
    
    // MARK: - Actions
    
    private func startRenaming() {
        editedName = item.name
        renamingItemID = item.id
        Task { @MainActor in
            try? await Task.sleep(nanoseconds: 100_000_000) // 0.1s delay
            focusedField = item.id
        }
    }
    
    private func commitRename() {
        guard let renamingID = renamingItemID,
              renamingID == item.id,
              !editedName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
            cancelRename()
            return
        }
        
        Task {
            await store.renameItem(id: item.id, to: editedName)
            await MainActor.run {
                renamingItemID = nil
                focusedField = nil
            }
        }
    }
    
    private func cancelRename() {
        renamingItemID = nil
        focusedField = nil
        editedName = ""
    }
    
    private func handleDrop(_ items: [ContentTransfer]) -> Bool {
        guard case .folder(let folder) = item.contentType else { return false }
        
        // Extract all item IDs from transfers
        let itemIDs = Set(items.flatMap { $0.itemIDs })
        
        // Don't allow dropping an item onto itself
        guard !itemIDs.contains(item.id) else { return false }
        
        Task {
            await store.moveItems(itemIDs, to: folder.id)
        }
        
        return true
    }
}



================================================================================

File: Views/Components/ContentRowView.swift
//
//  ContentRowView.swift
//  Pangolin
//
//  Created by Matt Kevan on 18/08/2025.
//

import SwiftUI

struct ContentRowView: View {
    let content: ContentType
    let isSelected: Bool
    let showCheckbox: Bool
    let viewMode: ViewMode
    @Binding var selectedItems: Set<UUID>
    @Binding var renamingItemID: UUID?
    @FocusState.Binding var focusedField: UUID?
    @Binding var editedName: String

    @EnvironmentObject private var store: FolderNavigationStore
    @State private var isDropTargeted = false
    @State private var shouldCommitOnDisappear = false

    enum ViewMode {
        case grid
        case list
    }

    private var dragPayload: ContentTransfer {
        // If the dragged item is part of a larger selection, drag all selected items.
        // Otherwise, just drag the single item.
        if selectedItems.contains(content.id) {
            return ContentTransfer(itemIDs: Array(selectedItems))
        } else {
            return ContentTransfer(itemIDs: [content.id])
        }
    }

    var body: some View {
        Group {
            switch viewMode {
            case .grid:
                gridContent
            case .list:
                listContent
            }
        }
        .contextMenu {
            Button("Rename") { startRenaming() }
            Button("Delete", role: .destructive) { /* TODO: Implement deletion */ }
        }
        .draggable(dragPayload)
        .onDrop(of: [.data], isTargeted: $isDropTargeted) { providers in
            guard case .folder(let folder) = content else { return false }
            
            if let provider = providers.first {
                let _ = provider.loadDataRepresentation(for: .data) { data, _ in
                    if let data = data,
                       let transfer = try? JSONDecoder().decode(ContentTransfer.self, from: data),
                       !transfer.itemIDs.contains(folder.id!) {
                        Task { @MainActor in
                            await store.moveItems(Set(transfer.itemIDs), to: folder.id)
                        }
                    }
                }
                return true
            }
            return false
        }
    }

    // MARK: - View Builders
    
    @ViewBuilder
    private var gridContent: some View {
        VStack {
            ZStack {
                RoundedRectangle(cornerRadius: 8)
                    .fill(content.isFolder ? Color.blue.opacity(0.1) : Color.gray.opacity(0.1))
                    .frame(height: 120)
                
                contentIcon
                    .font(.system(size: 40))
                    .foregroundColor(content.isFolder ? .blue : .primary)
                
                if showCheckbox {
                    VStack {
                        HStack {
                            Spacer()
                            Image(systemName: isSelected ? "checkmark.circle.fill" : "circle")
                                .foregroundColor(isSelected ? .blue : .gray)
                                .background(Color.white)
                                .clipShape(Circle())
                        }
                        Spacer()
                    }
                    .padding(8)
                }
            }
            
            VStack(alignment: .center, spacing: 4) {
                nameEditorView
                    .font(.caption)
                    .lineLimit(2)
                    .multilineTextAlignment(.center)
                
                if case .folder(let folder) = content {
                    Text("\(folder.itemCount) items")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                } else if case .video(let video) = content {
                    Text(video.formattedDuration)
                        .font(.caption2)
                        .foregroundColor(.secondary)
                }
            }
            .frame(maxWidth: .infinity)
        }
        .background(isSelected && !showCheckbox ? Color.accentColor.opacity(0.2) : Color.clear)
        .cornerRadius(8)
        .overlay(
            RoundedRectangle(cornerRadius: 8)
                .stroke(isDropTargeted ? Color.accentColor : Color.clear, lineWidth: 2)
        )
    }

    @ViewBuilder
    private var listContent: some View {
        HStack {
            if showCheckbox {
                Image(systemName: isSelected ? "checkmark.circle.fill" : "circle")
                    .foregroundColor(isSelected ? .blue : .gray)
            }
            
            contentIcon
                .font(.system(size: 20))
                .foregroundColor(content.isFolder ? .blue : .primary)
                .frame(width: 24)
            
            VStack(alignment: .leading, spacing: 2) {
                nameEditorView
                    .lineLimit(1)
                
                HStack {
                    if case .folder(let folder) = content {
                        Text("\(folder.itemCount) items")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    } else if case .video(let video) = content {
                        Text(video.formattedDuration)
                            .font(.caption)
                            .foregroundColor(.secondary)
                        
                        Spacer()
                        
                        Text(ByteCountFormatter().string(fromByteCount: video.fileSize))
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
            }
            Spacer()
        }
        .padding(.vertical, 4)
        .background(isSelected && !showCheckbox ? Color.accentColor.opacity(0.1) : Color.clear)
        .cornerRadius(4)
        .overlay(
             RoundedRectangle(cornerRadius: 4)
                .stroke(isDropTargeted ? Color.accentColor : Color.clear, lineWidth: 2)
        )
    }
    
    /// A view that conditionally shows a `Text` label or a `TextField` for renaming.
    @ViewBuilder
    private var nameEditorView: some View {
        if renamingItemID == content.id {
            TextField("Name", text: $editedName)
                .focused($focusedField, equals: content.id)
                .onAppear {
                    editedName = content.name
                    shouldCommitOnDisappear = true
                }
                .onSubmit {
                    shouldCommitOnDisappear = false // Prevent double commit
                    commitRename()
                }
                .onKeyPress { keyPress in
                    if keyPress.key == .escape {
                        shouldCommitOnDisappear = false
                        cancelRename()
                        return .handled
                    }
                    return .ignored
                }
                .onChange(of: focusedField) { oldValue, newValue in
                    // Detect when THIS TextField loses focus
                    if oldValue == content.id && newValue != content.id && shouldCommitOnDisappear {
                        print("ðŸŽ¯ FOCUS: ContentRow TextField \(content.id) lost focus (old: \(oldValue?.uuidString ?? "nil") -> new: \(newValue?.uuidString ?? "nil")), committing rename")
                        commitRename()
                    }
                }
        } else {
            Text(content.name)
        }
    }
    
    
    @ViewBuilder
    private var contentIcon: some View {
        switch content {
        case .folder:
            Image(systemName: "folder.fill")
        case .video(let video):
            if let thumbnailURL = video.thumbnailURL,
               FileManager.default.fileExists(atPath: thumbnailURL.path) {
                AsyncImage(url: thumbnailURL) { image in
                    image
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                } placeholder: {
                    Image(systemName: "video.fill")
                        .foregroundColor(.gray)
                }
                .frame(width: viewMode == .grid ? 80 : 20, height: viewMode == .grid ? 45 : 15)
                .clipShape(RoundedRectangle(cornerRadius: 4))
            } else {
                Image(systemName: "video.fill")
            }
        }
    }

    // MARK: - Renaming Logic

    /// Initiates the renaming process for this item.
    private func startRenaming() {
        editedName = content.name
        renamingItemID = content.id
        // Set focus after a brief delay to ensure TextField is rendered
        Task { @MainActor in
            try? await Task.sleep(nanoseconds: 100_000_000) // 0.1 seconds
            focusedField = content.id
        }
    }
    
    /// Commits the rename operation and updates the store.
    private func commitRename() {
        print("ðŸ”§ UI: commitRename called for '\(content.name)' -> '\(editedName)'")
        shouldCommitOnDisappear = false // Prevent further commits
        guard let itemID = renamingItemID, itemID == content.id else { 
            print("âŒ UI: Guard failed - renamingItemID: \(renamingItemID?.uuidString ?? "nil"), content.id: \(content.id)")
            return 
        }
        
        let trimmedName = editedName.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmedName.isEmpty && trimmedName != content.name else {
            // Cancel rename if name is empty or unchanged
            print("âŒ UI: Name unchanged or empty - '\(trimmedName)' vs '\(content.name)'")
            cancelRename()
            return
        }
        
        print("ðŸš€ UI: About to call store.renameItem")
        
        // Perform rename operation on background queue to avoid publishing changes during view update
        Task {
            await store.renameItem(id: itemID, to: trimmedName)
            await MainActor.run {
                renamingItemID = nil
                focusedField = nil
            }
        }
    }
    
    /// Cancels the rename operation without saving.
    private func cancelRename() {
        editedName = content.name // Reset to original name
        shouldCommitOnDisappear = false
        renamingItemID = nil
        focusedField = nil
    }


}


================================================================================

File: Views/Components/VideoInfoView.swift
//
//  VideoInfoView.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//

import SwiftUI

struct VideoInfoView: View {
    // Use @ObservedObject for a managed object to ensure the view updates on change
    @ObservedObject var video: Video
    @EnvironmentObject var libraryManager: LibraryManager
    
    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 16) {
                // Title and metadata
                VStack(alignment: .leading, spacing: 8) {
                    Text(video.title!)
                        .font(.title2)
                        .fontWeight(.bold)
                    
                    HStack {
                        Text(video.formattedDuration)
                        Text("â€¢")
                        Text(video.resolution ?? "Unknown")
                        Text("â€¢")
                        Text(ByteCountFormatter.string(fromByteCount: video.fileSize, countStyle: .file))
                    }
                    .font(.caption)
                    .foregroundColor(.secondary)
                }
                
                // Favorite Button
                Button(action: toggleFavorite) {
                    Label(video.isFavorite ? "Remove from Favorites" : "Add to Favorites",
                          systemImage: video.isFavorite ? "heart.fill" : "heart")
                }
                .buttonStyle(.bordered)
                .tint(video.isFavorite ? .red : .secondary)

                Divider()
                
                // File info
                VStack(alignment: .leading, spacing: 8) {
                    Text("File Information")
                        .font(.headline)
                    
                    InfoRow(label: "Filename", value: video.fileName!)
                    InfoRow(label: "Format", value: video.videoFormat ?? "Unknown")
                    InfoRow(label: "Frame Rate", value: String(format: "%.1f fps", video.frameRate))
                    InfoRow(label: "Date Added", value: DateFormatter.localizedString(from: video.dateAdded!, dateStyle: .medium, timeStyle: .short))
                    
                    if let lastPlayed = video.lastPlayed {
                        InfoRow(label: "Last Played", value: DateFormatter.localizedString(from: lastPlayed, dateStyle: .medium, timeStyle: .short))
                    }
                    
                    InfoRow(label: "Play Count", value: String(video.playCount))
                }
                
                if video.hasSubtitles {
                    Divider()
                    
                    VStack(alignment: .leading, spacing: 8) {
                        Text("Subtitles")
                            .font(.headline)
                        
                        if let subtitles = video.subtitles {
                            ForEach(Array(subtitles as! Set<Subtitle>), id: \.id) { subtitle in
                                HStack {
                                    Text(subtitle.displayName)
                                    Spacer()
                                    Text(subtitle.format!.uppercased())
                                        .font(.caption2)
                                        .padding(.horizontal, 6)
                                        .padding(.vertical, 2)
                                        .background(Color.secondary.opacity(0.2))
                                        .cornerRadius(4)
                                }
                            }
                        }
                    }
                }
                
                Spacer()
            }
            .padding()
        }
    }

    private func toggleFavorite() {
        video.isFavorite.toggle()
        Task {
            await libraryManager.save()
        }
    }
}

struct InfoRow: View {
    let label: String
    let value: String
    
    var body: some View {
        HStack {
            Text(label)
                .foregroundColor(.secondary)
            Spacer()
            Text(value)
                .fontWeight(.medium)
        }
        .font(.caption)
    }
}


================================================================================

File: Views/Components/VideoThumbnailView.swift
//
//  VideoThumbnailView.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//

import SwiftUI

struct VideoThumbnailView: View {
    let video: Video
    let size: CGSize
    
    init(video: Video, size: CGSize = CGSize(width: 160, height: 90)) {
        self.video = video
        self.size = size
    }
    
    var body: some View {
        Group {
            if let thumbnailURL = video.thumbnailURL,
               FileManager.default.fileExists(atPath: thumbnailURL.path) {
                AsyncImage(url: thumbnailURL) { image in
                    image
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                } placeholder: {
                    Rectangle()
                        .fill(Color.gray.opacity(0.2))
                        .overlay(
                            ProgressView()
                                .scaleEffect(0.7)
                        )
                }
            } else {
                // Fallback placeholder
                Rectangle()
                    .fill(Color.gray.opacity(0.2))
                    .overlay(
                        VStack(spacing: 4) {
                            Image(systemName: "play.rectangle.fill")
                                .font(.title2)
                                .foregroundColor(.gray.opacity(0.6))
                            
                            Text("No Preview")
                                .font(.caption2)
                                .foregroundColor(.secondary)
                        }
                    )
            }
        }
        .frame(width: size.width, height: size.height)
        .clipShape(RoundedRectangle(cornerRadius: 8))
        .overlay(
            // Duration overlay
            HStack {
                Spacer()
                VStack {
                    Spacer()
                    Text(video.formattedDuration)
                        .font(.caption2)
                        .foregroundColor(.white)
                        .padding(.horizontal, 6)
                        .padding(.vertical, 2)
                        .background(Color.black.opacity(0.7))
                        .clipShape(RoundedRectangle(cornerRadius: 4))
                        .padding(6)
                }
            }
        )
    }
}

#Preview {
    // Preview placeholder since we need actual video data
    Rectangle()
        .fill(Color.gray.opacity(0.2))
        .frame(width: 160, height: 90)
        .clipShape(RoundedRectangle(cornerRadius: 8))
        .overlay(
            VStack {
                Image(systemName: "play.rectangle.fill")
                    .font(.title2)
                Text("Thumbnail Preview")
                    .font(.caption)
            }
            .foregroundColor(.gray)
        )
}

================================================================================

File: Views/Main/LibraryWelcomeView.swift
//
//  LibraryWelcomeView.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//

import SwiftUI

struct LibraryWelcomeView: View {
    @Binding var showLibrarySelector: Bool
    @Binding var showCreateLibrary: Bool
    @EnvironmentObject var libraryManager: LibraryManager
    
    var body: some View {
        VStack(spacing: 40) {
            Image(systemName: "play.square.stack")
                .font(.system(size: 80))
                .foregroundColor(.accentColor)
            
            Text("Welcome to Pangolin")
                .font(.largeTitle)
                .fontWeight(.bold)
            
            Text("Your personal video library manager")
                .font(.title3)
                .foregroundColor(.secondary)
            
            VStack(spacing: 16) {
                Button(action: { showCreateLibrary = true }) {
                    Label("Create New Library", systemImage: "plus.square")
                        .frame(width: 200)
                }
                .controlSize(.large)
                .buttonStyle(.borderedProminent)
                
                Button(action: { showLibrarySelector = true }) {
                    Label("Open Existing Library", systemImage: "folder")
                        .frame(width: 200)
                }
                .controlSize(.large)
                .buttonStyle(.bordered)
                
                if !libraryManager.recentLibraries.isEmpty {
                    Divider()
                        .frame(width: 200)
                    
                    VStack(alignment: .leading) {
                        Text("Recent Libraries")
                            .font(.headline)
                        
                        ForEach(libraryManager.recentLibraries.prefix(3)) { library in
                            Button(action: {
                                Task {
                                    try? await libraryManager.openLibrary(at: library.path)
                                }
                            }) {
                                HStack {
                                    Image(systemName: "clock.arrow.circlepath")
                                    VStack(alignment: .leading) {
                                        Text(library.name)
                                            .font(.body)
                                        Text(library.path.path)
                                            .font(.caption)
                                            .foregroundColor(.secondary)
                                    }
                                }
                            }
                            .buttonStyle(.plain)
                            .disabled(!library.isAvailable)
                        }
                    }
                }
            }
        }
        .padding(50)
        .frame(minWidth: 600, minHeight: 500)
    }
}


================================================================================

