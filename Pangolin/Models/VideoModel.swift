//
//  Video.swift
//  Pangolin
//
//  Created by Matt Kevan on 16/08/2025.
//


// Models/VideoModel.swift
import Foundation
import CoreData
import AVFoundation

// MARK: - Core Data Extensions
// Base classes are auto-generated by Core Data from .xcdatamodeld

// MARK: - Sendable Conformance
extension Video: @unchecked Sendable {}
extension Library: @unchecked Sendable {}
extension Folder: @unchecked Sendable {}
extension Subtitle: @unchecked Sendable {}

// MARK: - Video Extensions
extension Video {
    // Computed properties
    var fileURL: URL? {
        guard let library = library,
              let relativePath = relativePath else { return nil }
        
        // For synchronous access, use basic library path construction
        // For proper storage resolution, use getResolvedFileURL() async method
        guard let libraryPath = library.url else { return nil }
        
        // Try to determine storage type and construct path accordingly
        if let storageTypeString = library.videoStorageType,
           let storageType = VideoStorageType(rawValue: storageTypeString) {
            switch storageType {
            case .iCloudDrive:
                // For iCloud Drive, files are stored in the library's Videos directory
                return libraryPath.appendingPathComponent("Videos").appendingPathComponent(relativePath)
            case .localLibrary:
                return libraryPath.appendingPathComponent("Videos").appendingPathComponent(relativePath)
            default:
                // For other storage types, async resolution needed - fall back to basic path
                return libraryPath.appendingPathComponent("Videos").appendingPathComponent(relativePath)
            }
        }
        
        // Default fallback
        return libraryPath.appendingPathComponent("Videos").appendingPathComponent(relativePath)
    }
    
    // Check if video file is accessible
    var isVideoFileAccessible: Bool {
        Task {
            let status = await VideoFileManager.shared.isVideoFileAccessible(self)
            return status == .available
        }
        // Synchronous fallback - just check if file exists
        guard let fileURL = fileURL else { return false }
        return FileManager.default.fileExists(atPath: fileURL.path)
    }
    
    // Get video file status asynchronously
    func getVideoFileStatus() async -> VideoFileStatus {
        return await VideoFileManager.shared.isVideoFileAccessible(self)
    }
    
    // Get properly resolved video file URL using VideoStorageManager
    func getResolvedFileURL() async throws -> URL {
        guard let library = library,
              let relativePath = relativePath else { 
            throw VideoFileError.invalidVideoPath 
        }
        
        let storageURL = try await MainActor.run {
            return try VideoStorageManager.shared.resolveVideoStorageURL(for: library)
        }
        return storageURL.appendingPathComponent(relativePath)
    }
    
    // Get video file URL with iCloud download if needed
    func getAccessibleFileURL(downloadIfNeeded: Bool = true) async throws -> URL {
        return try await VideoFileManager.shared.getVideoFileURL(for: self, downloadIfNeeded: downloadIfNeeded)
    }
    
    var formattedDuration: String {
        let formatter = DateComponentsFormatter()
        formatter.allowedUnits = [.hour, .minute, .second]
        formatter.unitsStyle = .positional
        formatter.zeroFormattingBehavior = .pad
        return formatter.string(from: duration) ?? "00:00"
    }
    
    var hasSubtitles: Bool {
        return (subtitles?.count ?? 0) > 0
    }
    
    var thumbnailURL: URL? {
        guard let library = library,
              let libraryPath = library.url,
              let thumbnailPath = thumbnailPath else { return nil }
        return libraryPath.appendingPathComponent("Thumbnails").appendingPathComponent(thumbnailPath)
    }
}

// MARK: - Folder Extensions
extension Folder {
    // Computed properties
    var childFoldersArray: [Folder] {
        guard let children = childFolders else { return [] }
        return children.compactMap { $0 as? Folder }.sorted { 
            ($0.name ?? "").localizedCompare($1.name ?? "") == .orderedAscending 
        }
    }
    
    var videosArray: [Video] {
        guard let videos = videos else { return [] }
        return videos.compactMap { $0 as? Video }.sorted { 
            ($0.title ?? "").localizedCompare($1.title ?? "") == .orderedAscending 
        }
    }
    
    var itemCount: Int {
        return (childFolders?.count ?? 0) + (videos?.count ?? 0)
    }
    
    var totalVideoCount: Int {
        let directVideos = videos?.count ?? 0
        let childVideos = childFolders?.reduce(into: 0) { result, folder in
            if let folder = folder as? Folder {
                result += folder.totalVideoCount
            }
        } ?? 0
        return directVideos + childVideos
    }
}

// MARK: - Subtitle Extensions
extension Subtitle {
    // Computed properties
    var fileURL: URL? {
        guard let video = video,
              let library = video.library,
              let libraryPath = library.url,
              let relativePath = relativePath else { return nil }
        return libraryPath.appendingPathComponent("Subtitles").appendingPathComponent(relativePath)
    }
    
    var displayName: String {
        if let languageName = languageName {
            return languageName
        } else if let language = language {
            return Locale.current.localizedString(forLanguageCode: language) ?? language
        }
        return fileName ?? "Unknown Subtitle"
    }
}

// MARK: - Library Extensions
extension Library {
    // Computed properties
    var url: URL? {
        guard let libraryPath = libraryPath else { return nil }
        return URL(fileURLWithPath: libraryPath)
    }
    
    var videoCount: Int {
        return videos?.count ?? 0
    }
    
    var totalSize: Int64 {
        return videos?.reduce(into: 0) { result, video in
            if let video = video as? Video {
                result += video.fileSize
            }
        } ?? 0
    }
    
    var formattedSize: String {
        let formatter = ByteCountFormatter()
        formatter.countStyle = .file
        return formatter.string(fromByteCount: totalSize)
    }
}

// MARK: - Content Types
enum ContentType: Hashable {
    case folder(Folder)
    case video(Video)
    
    var id: UUID {
        switch self {
        case .folder(let folder): return folder.id!
        case .video(let video): return video.id!
        }
    }
    
    var name: String {
        switch self {
        case .folder(let folder): return folder.name ?? ""
        case .video(let video): return video.title ?? ""
        }
    }
    
    var dateCreated: Date {
        switch self {
        case .folder(let folder): return folder.dateCreated ?? Date()
        case .video(let video): return video.dateAdded ?? Date()
        }
    }
    
    var isFolder: Bool {
        if case .folder = self { return true }
        return false
    }
}

// MARK: - Sorting
enum SortOption: String, CaseIterable {
    case nameAscending = "Name A-Z"
    case nameDescending = "Name Z-A"
    case dateCreatedNewest = "Newest First"
    case dateCreatedOldest = "Oldest First"
    case foldersFirst = "Folders First"
}

enum SubtitleFormat: String, CaseIterable {
    case srt = "srt"
    case vtt = "vtt"
    case ssa = "ssa"
    case ass = "ass"
    
    var displayName: String {
        switch self {
        case .srt: return "SubRip (.srt)"
        case .vtt: return "WebVTT (.vtt)"
        case .ssa, .ass: return "SubStation Alpha (.ssa/.ass)"
        }
    }
}

enum VideoFormat: String, CaseIterable {
    case mp4 = "mp4"
    case mov = "mov"
    case m4v = "m4v"
    case mkv = "mkv"
    case avi = "avi"
    case webm = "webm"
    
    static var supportedExtensions: [String] {
        return VideoFormat.allCases.map { $0.rawValue }
    }
}

// MARK: - Library Descriptor (for multiple libraries)
struct LibraryDescriptor: Codable, Identifiable {
    let id: UUID
    let name: String
    let path: URL
    let lastOpenedDate: Date
    let createdDate: Date
    let version: String
    let thumbnailData: Data?
    let videoCount: Int
    let totalSize: Int64
    
    var isAvailable: Bool {
        return FileManager.default.fileExists(atPath: path.path)
    }
    
    var formattedSize: String {
        let formatter = ByteCountFormatter()
        formatter.countStyle = .file
        return formatter.string(fromByteCount: totalSize)
    }
}

