#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
TOOLS_DIR="$ROOT_DIR/Pangolin/Resources/Tools"
PYTHON_DIR=""
PYTHON_ARCHIVE=""
PIP_PYTHON=""
FFMPEG_SRC=""
FFPROBE_SRC=""
YTDLP_VERSION=""
CERTIFI_VERSION=""
CLEAN_FIRST=0

usage() {
  cat <<'EOF'
Prepare Pangolin's bundled downloader runtime (embedded Python + yt_dlp + ffmpeg/ffprobe).

This script creates the layout expected by RemoteVideoDownloadService:
  Pangolin/Resources/Tools/
    python/
    site-packages/
    ffmpeg
    ffprobe

Required:
  One of:
    --python-runtime-dir PATH      Extracted relocatable Python runtime directory
    --python-runtime-archive PATH  python-build-standalone archive (.tar.gz/.tar.xz/.tar.zst)

Optional:
  --pip-python PATH                Python executable used to install packages into site-packages
                                   (default: the bundled runtime's python3 after copy)
  --ffmpeg PATH                    ffmpeg binary to copy into Tools/ffmpeg
  --ffprobe PATH                   ffprobe binary to copy into Tools/ffprobe
  --yt-dlp-version VERSION         Pin yt-dlp version (default: latest available from pip)
  --certifi-version VERSION        Pin certifi version (default: latest available from pip)
  --tools-dir PATH                 Override destination Tools directory
  --clean                          Remove existing python/ and site-packages/ before vendoring
  -h, --help                       Show this help

Examples:
  scripts/vendor_downloader_runtime.sh \
    --python-runtime-dir ~/Downloads/python/install \
    --ffmpeg /opt/homebrew/bin/ffmpeg \
    --ffprobe /opt/homebrew/bin/ffprobe \
    --yt-dlp-version 2026.02.20 \
    --certifi-version 2026.01.10 \
    --clean

  scripts/vendor_downloader_runtime.sh \
    --python-runtime-archive ~/Downloads/cpython-3.12.9+20260201-aarch64-apple-darwin-install_only.tar.gz \
    --ffmpeg /opt/homebrew/bin/ffmpeg \
    --ffprobe /opt/homebrew/bin/ffprobe
EOF
}

log() {
  printf '[vendor-runtime] %s\n' "$*"
}

die() {
  printf '[vendor-runtime] error: %s\n' "$*" >&2
  exit 1
}

require_cmd() {
  command -v "$1" >/dev/null 2>&1 || die "Missing required command: $1"
}

copy_runtime_dir() {
  local src="$1"
  local dest="$2"
  [[ -d "$src" ]] || die "Python runtime directory not found: $src"
  mkdir -p "$(dirname "$dest")"
  rm -rf "$dest"
  log "Copying Python runtime from $src -> $dest"
  cp -a "$src" "$dest"
}

extract_runtime_archive() {
  local archive="$1"
  local dest="$2"
  [[ -f "$archive" ]] || die "Python runtime archive not found: $archive"
  require_cmd tar

  local tmpdir
  tmpdir="$(mktemp -d)"
  trap 'rm -rf "$tmpdir"' RETURN

  log "Extracting Python runtime archive: $archive"
  case "$archive" in
    *.tar.gz|*.tgz)
      tar -xzf "$archive" -C "$tmpdir"
      ;;
    *.tar.xz)
      tar -xJf "$archive" -C "$tmpdir"
      ;;
    *.tar.zst|*.tar.zstd)
      if tar --help 2>&1 | grep -q -- '--zstd'; then
        tar --zstd -xf "$archive" -C "$tmpdir"
      elif command -v unzstd >/dev/null 2>&1; then
        unzstd -c "$archive" | tar -xf - -C "$tmpdir"
      else
        die "Cannot extract .zst archive (need tar with --zstd or unzstd)"
      fi
      ;;
    *)
      die "Unsupported archive format: $archive"
      ;;
  esac

  local extracted
  extracted="$(find "$tmpdir" -mindepth 1 -maxdepth 2 -type d \
    \( -path '*/install' -o -path '*/python' \) | head -n 1)"
  [[ -n "$extracted" ]] || extracted="$(find "$tmpdir" -mindepth 1 -maxdepth 1 -type d | head -n 1)"
  [[ -n "$extracted" ]] || die "Could not locate extracted runtime directory in archive"

  copy_runtime_dir "$extracted" "$dest"
}

find_python_executable() {
  local runtime_root="$1"
  if [[ -x "$runtime_root/bin/python3" ]]; then
    printf '%s\n' "$runtime_root/bin/python3"
    return 0
  fi
  if [[ -x "$runtime_root/bin/python" ]]; then
    printf '%s\n' "$runtime_root/bin/python"
    return 0
  fi
  return 1
}

copy_tool_binary() {
  local src="$1"
  local dest="$2"
  [[ -n "$src" ]] || return 0
  [[ -f "$src" ]] || die "Binary not found: $src"
  mkdir -p "$(dirname "$dest")"
  log "Copying $(basename "$dest") from $src"
  cp -f "$src" "$dest"
  chmod 755 "$dest"
}

write_manifest() {
  local path="$1"
  local python_bin="$2"
  local ytdlp_spec="$3"
  local certifi_spec="$4"
  mkdir -p "$(dirname "$path")"

  local py_ver
  py_ver="$("$python_bin" -V 2>&1 || true)"
  cat >"$path" <<EOF
# Generated by scripts/vendor_downloader_runtime.sh on $(date -u +"%Y-%m-%dT%H:%M:%SZ")
tools_dir=$TOOLS_DIR
python_runtime_source_dir=${PYTHON_DIR:-}
python_runtime_source_archive=${PYTHON_ARCHIVE:-}
python_runtime_version=${py_ver}
yt_dlp_spec=${ytdlp_spec}
certifi_spec=${certifi_spec}
ffmpeg_source=${FFMPEG_SRC:-}
ffprobe_source=${FFPROBE_SRC:-}
EOF
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --python-runtime-dir)
      PYTHON_DIR="${2:-}"
      shift 2
      ;;
    --python-runtime-archive)
      PYTHON_ARCHIVE="${2:-}"
      shift 2
      ;;
    --pip-python)
      PIP_PYTHON="${2:-}"
      shift 2
      ;;
    --ffmpeg)
      FFMPEG_SRC="${2:-}"
      shift 2
      ;;
    --ffprobe)
      FFPROBE_SRC="${2:-}"
      shift 2
      ;;
    --yt-dlp-version)
      YTDLP_VERSION="${2:-}"
      shift 2
      ;;
    --certifi-version)
      CERTIFI_VERSION="${2:-}"
      shift 2
      ;;
    --tools-dir)
      TOOLS_DIR="${2:-}"
      shift 2
      ;;
    --clean)
      CLEAN_FIRST=1
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      die "Unknown argument: $1 (use --help)"
      ;;
  esac
done

[[ -n "$PYTHON_DIR" || -n "$PYTHON_ARCHIVE" ]] || die "Provide --python-runtime-dir or --python-runtime-archive"
[[ -z "$PYTHON_DIR" || -z "$PYTHON_ARCHIVE" ]] || die "Use only one of --python-runtime-dir or --python-runtime-archive"

mkdir -p "$TOOLS_DIR"
if [[ "$CLEAN_FIRST" -eq 1 ]]; then
  log "Cleaning existing runtime directories under $TOOLS_DIR"
  rm -rf "$TOOLS_DIR/python" "$TOOLS_DIR/site-packages"
fi

if [[ -n "$PYTHON_DIR" ]]; then
  copy_runtime_dir "$PYTHON_DIR" "$TOOLS_DIR/python"
else
  extract_runtime_archive "$PYTHON_ARCHIVE" "$TOOLS_DIR/python"
fi

BUNDLED_PYTHON="$(find_python_executable "$TOOLS_DIR/python" || true)"
[[ -n "$BUNDLED_PYTHON" ]] || die "No executable python found under $TOOLS_DIR/python/bin"
chmod 755 "$BUNDLED_PYTHON" || true

if [[ -z "$PIP_PYTHON" ]]; then
  PIP_PYTHON="$BUNDLED_PYTHON"
fi
[[ -x "$PIP_PYTHON" ]] || die "--pip-python is not executable: $PIP_PYTHON"

SITE_PACKAGES_DIR="$TOOLS_DIR/site-packages"
mkdir -p "$SITE_PACKAGES_DIR"

YTDLP_SPEC='yt-dlp[default]'
CERTIFI_SPEC='certifi'
if [[ -n "$YTDLP_VERSION" ]]; then
  YTDLP_SPEC="yt-dlp[default]==$YTDLP_VERSION"
fi
if [[ -n "$CERTIFI_VERSION" ]]; then
  CERTIFI_SPEC="certifi==$CERTIFI_VERSION"
fi

log "Installing Python packages into $SITE_PACKAGES_DIR"
"$PIP_PYTHON" -m pip install --upgrade --no-compile \
  --target "$SITE_PACKAGES_DIR" \
  "$YTDLP_SPEC" "$CERTIFI_SPEC"

log "Removing caches/bytecode"
find "$SITE_PACKAGES_DIR" -type d -name '__pycache__' -prune -exec rm -rf {} + 2>/dev/null || true
find "$SITE_PACKAGES_DIR" -type f \( -name '*.pyc' -o -name '*.pyo' \) -delete 2>/dev/null || true

copy_tool_binary "$FFMPEG_SRC" "$TOOLS_DIR/ffmpeg"
copy_tool_binary "$FFPROBE_SRC" "$TOOLS_DIR/ffprobe"

write_manifest "$TOOLS_DIR/VERSIONS.txt" "$BUNDLED_PYTHON" "$YTDLP_SPEC" "$CERTIFI_SPEC"

log "Smoke test: bundled python"
"$BUNDLED_PYTHON" -V

log "Smoke test: yt_dlp module"
PYTHONPATH="$SITE_PACKAGES_DIR" \
PYTHONNOUSERSITE=1 \
PYTHONDONTWRITEBYTECODE=1 \
SSL_CERT_FILE="${SITE_PACKAGES_DIR}/certifi/cacert.pem" \
REQUESTS_CA_BUNDLE="${SITE_PACKAGES_DIR}/certifi/cacert.pem" \
  "$BUNDLED_PYTHON" -m yt_dlp --version

if [[ -x "$TOOLS_DIR/ffmpeg" ]]; then
  log "Smoke test: ffmpeg"
  "$TOOLS_DIR/ffmpeg" -version | head -n 1
fi
if [[ -x "$TOOLS_DIR/ffprobe" ]]; then
  log "Smoke test: ffprobe"
  "$TOOLS_DIR/ffprobe" -version | head -n 1
fi

cat <<EOF

Vendored downloader runtime is ready.

Expected bundle resources (target membership required):
  $TOOLS_DIR/python
  $TOOLS_DIR/site-packages
  $TOOLS_DIR/ffmpeg
  $TOOLS_DIR/ffprobe

Next steps:
  1. Add/verify these items in Xcode > Pangolin target > Build Phases > Copy Bundle Resources
  2. Keep the post-copy signing script to chmod + codesign nested binaries
  3. Rebuild and test URL import
EOF
